/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core .
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
/**
 * description: Routing Receive sendInterface description.
 * author: lian zhang
 */
#ifndef V3_ORG_GENIVI_AM_ROUTINGINTERFACE_Routing_Control_Observer_STUB_DEFAULT_HPP_
#define V3_ORG_GENIVI_AM_ROUTINGINTERFACE_Routing_Control_Observer_STUB_DEFAULT_HPP_


#include <v3/org/genivi/am/routinginterface/RoutingControlObserverStub.hpp>
#include <sstream>

namespace v3 {
namespace org {
namespace genivi {
namespace am {
namespace routinginterface {

/**
 * Provides a default implementation for RoutingControlObserverStubRemoteEvent and
 * RoutingControlObserverStub. Method callbacks have an empty implementation,
 * remote set calls on attributes will always change the value of the attribute
 * to the one received.
 *
 * Override this stub if you only want to provide a subset of the functionality
 * that would be defined for this service, and/or if you do not need any non-default
 * behaviour.
 */
class RoutingControlObserverStubDefault
    : public virtual RoutingControlObserverStub {
public:
    RoutingControlObserverStubDefault();

    RoutingControlObserverStubRemoteEvent* initStubAdapter(const std::shared_ptr<RoutingControlObserverStubAdapter> &_adapter);

    const CommonAPI::Version& getInterfaceVersion(std::shared_ptr<CommonAPI::ClientId> _client);

    virtual const ::v3::org::genivi::am_t::am_RoutingReady_e& getRoutingReadyAttribute();
    virtual const ::v3::org::genivi::am_t::am_RoutingReady_e& getRoutingReadyAttribute(const std::shared_ptr<CommonAPI::ClientId> _client);
    virtual void setRoutingReadyAttribute(::v3::org::genivi::am_t::am_RoutingReady_e _value);

    /**
     * description: Registers a domain. (at)return E_OK on success, E_ALREADY_EXISTENT if already
     *   registered E_UNKNOWN on error
     */
    virtual void registerDomain(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::am_Domain_s _domainData, std::string _returnBusname, std::string _returnInterface, registerDomainReply_t _reply);
    /**
     * description: Deregisters a domain. All sources, sinks, gateways and crossfaders from that
     *   domain will be removed as well. (at)return E_OK on success, E_NON_EXISTENT if
     *   not found E_UNKNOWN on error
     */
    virtual void deregisterDomain(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::am_domainID_t _domainID, deregisterDomainReply_t _reply);
    /**
     * description: This function returns the ID to the given domain name. If already a domain is
     *   registered with this name, it will return the corresponding ID, if not it will
     *   reserve an ID but not register the domain. The other parameters of the domain
     *   will be overwritten when the domain is registered. (at)return E_OK on success,
     *   E_UNKNOWN on error     please use pulseAudio as the name to peek domainID. now
     *   all the sources and sinks are defined in domain pulseAudio.
     */
    virtual void peekDomain(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _name, peekDomainReply_t _reply);
    /**
     * description: Registers a sink. If the sink is part of a gateway, the list connection formats
     *   are copied to the gateway information (at)return E_OK on success,
     *   E_ALREADY_EXISTENT if already registered E_UNKNOWN on error
     */
    virtual void registerSink(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::am_Sink_s _sinkData, registerSinkReply_t _reply);
    /**
     * description: Deregisters a sink. (at)return E_OK on success, E_NON_EXISTENT if not found
     *   E_UNKNOWN on error
     */
    virtual void deregisterSink(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::am_sinkID_t _sinkID, deregisterSinkReply_t _reply);
    /**
     * description: This function returns the ID to the given sink name. If already a sink is
     *   registered with this name, it will return the corresponding ID, if not it will
     *   reserve an ID but not register the sink. The other parameters of the sink will
     *   be overwritten when the sink is registered. (at)return E_OK on success,
     *   E_UNKNOWN on error
     */
    virtual void peekSink(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _name, peekSinkReply_t _reply);
    /**
     * description: This function peeks a sink class ID. It is used by the RoutingPlugins to
     *   determine the sink class IDs of a sink class. (at)return E_OK on success,
     *   E_DATABASE_ERROR on error
     */
    virtual void peekSinkClassID(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _name, peekSinkClassIDReply_t _reply);
    /**
     * description: Updates data of a sink. (at)return E_OK on success, E_NON_EXISTENT if the sink
     *   ID is not valid.
     */
    virtual void updateSink(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::am_sinkID_t _sinkID, ::v3::org::genivi::am_t::am_sinkClass_t _sinkClassID, ::v3::org::genivi::am_t::am_SoundProperty_L _listSoundProperties, ::v3::org::genivi::am_t::am_ConnectionFormat_L _listConnectionFormats, ::v3::org::genivi::am_t::am_MainSoundProperty_L _listMainSoundProperties, updateSinkReply_t _reply);
    /**
     * description: Registers a source.  If the source is part of a gateway, the list connection
     *   formats are copied to the gateway information (at)return E_OK on success,
     *   E_UNKNOWN on error, E_ALREADY_EXIST if either name or source ID already exists
     */
    virtual void registerSource(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::am_Source_s _sourceData, registerSourceReply_t _reply);
    /**
     * description: Deregisters a source. (at)return E_OK on success, E_NON_EXISTENT if not found
     *   E_UNKNOWN on error
     */
    virtual void deregisterSource(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::am_sourceID_t _sourceID, deregisterSourceReply_t _reply);
    /**
     * description: This function returns the ID to the given source name. If already a source is
     *   registered with this name, it will return the corresponding ID, if not it will
     *   reserve an ID but not register the source. The other parameters of the source
     *   will be overwritten when the source is registered. (at)return E_OK on success,
     *   E_UNKNOWN on error
     */
    virtual void peekSource(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _name, peekSourceReply_t _reply);
    /**
     * description: Peeks a source class ID. It is used by the RoutingPlugins to determine the
     *   source class IDs of a source class. (at)return E_OK on success,
     *   E_DATABASE_ERROR on error
     */
    virtual void peekSourceClassID(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _name, peekSourceClassIDReply_t _reply);
    /**
     * description: Updates data of a source. (at)return E_OK on success, E_NON_EXISTENT if the
     *   source ID in the struct is not valid.  Please note that only the following
     *   data out of am_Source_s have effect when they are changed: sourceClassID,
     *   listSoundProperties, listConnectionFormats, listMainSoundProperties
     */
    virtual void updateSource(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::am_sourceID_t _sourceID, ::v3::org::genivi::am_t::am_sourceClass_t _sourceClassID, ::v3::org::genivi::am_t::am_SoundProperty_L _listSoundProperties, ::v3::org::genivi::am_t::am_ConnectionFormat_L _listConnectionFormats, ::v3::org::genivi::am_t::am_MainSoundProperty_L _listMainSoundProperties, updateSourceReply_t _reply);
    /**
     * description: Is called when a low level interrupt changes it status.
     */
    virtual void hookInterruptStatusChange(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::am_sourceID_t _sourceID, ::v3::org::genivi::am_t::am_InterruptState_e _interruptState, hookInterruptStatusChangeReply_t _reply);
    /**
     * description: This hook is called when all elements from a domain are registered. Is used by
     *   the Controller to know when all expected domains are finally registered.
     */
    virtual void hookDomainRegistrationComplete(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::am_domainID_t _domainID, hookDomainRegistrationCompleteReply_t _reply);
    /**
     * description: Is called when a sink changes its availability.
     */
    virtual void hookSinkAvailablityStatusChange(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::am_sinkID_t _sinkID, ::v3::org::genivi::am_t::am_Availability_s _availability, hookSinkAvailablityStatusChangeReply_t _reply);
    /**
     * description: Is called when a source changes its availability.
     */
    virtual void hookSourceAvailablityStatusChange(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::am_sourceID_t _sourceID, ::v3::org::genivi::am_t::am_Availability_s _availability, hookSourceAvailablityStatusChangeReply_t _reply);
    /**
     * description: Is called when a domain changes its status. This used for early domains only.
     */
    virtual void hookDomainStateChange(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::am_domainID_t _domainID, ::v3::org::genivi::am_t::am_DomainState_e _domainState, hookDomainStateChangeReply_t _reply);
    /**
     * description: This function is used to send out all data that has been changed in an early
     *   state.
     */
    virtual void sendChangedData(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::am_EarlyData_L _earlyData, sendChangedDataReply_t _reply);
    virtual void writeToDevice(const std::shared_ptr<CommonAPI::ClientId> _client, uint32_t _devAddr, uint32_t _dataSize, CommonAPI::ByteBuffer _data, writeToDeviceReply_t _reply);
    virtual void readFromDevice(const std::shared_ptr<CommonAPI::ClientId> _client, uint32_t _devAddr, uint32_t _dataSize, readFromDeviceReply_t _reply);
    virtual void setFilter(const std::shared_ptr<CommonAPI::ClientId> _client, CommonAPI::ByteBuffer _paramData, uint32_t _paramSize, CommonAPI::ByteBuffer _data, uint32_t _dataSize, setFilterReply_t _reply);
    virtual void getFilter(const std::shared_ptr<CommonAPI::ClientId> _client, CommonAPI::ByteBuffer _paramData, uint32_t _paramSize, getFilterReply_t _reply);
    virtual void setLimiter(const std::shared_ptr<CommonAPI::ClientId> _client, CommonAPI::ByteBuffer _paramData, uint32_t _paramSize, CommonAPI::ByteBuffer _data, uint32_t _dataSize, setLimiterReply_t _reply);
    virtual void getLimiter(const std::shared_ptr<CommonAPI::ClientId> _client, CommonAPI::ByteBuffer _paramData, uint32_t _paramSize, getLimiterReply_t _reply);
    virtual void setVolume(const std::shared_ptr<CommonAPI::ClientId> _client, uint16_t _sinkID, uint8_t _volume, setVolumeReply_t _reply);
    virtual void getVolume(const std::shared_ptr<CommonAPI::ClientId> _client, getVolumeReply_t _reply);
    virtual void setChannelMute(const std::shared_ptr<CommonAPI::ClientId> _client, uint8_t _channelIndex, ::v3::org::genivi::am_t::am_MuteState_e _muteState, setChannelMuteReply_t _reply);
    virtual void setChannelPhase(const std::shared_ptr<CommonAPI::ClientId> _client, uint8_t _channelIndex, bool _phase, setChannelPhaseReply_t _reply);
    virtual void setBMT(const std::shared_ptr<CommonAPI::ClientId> _client, int8_t _bass, int8_t _mid, int8_t _treble, setBMTReply_t _reply);
    virtual void getBMT(const std::shared_ptr<CommonAPI::ClientId> _client, getBMTReply_t _reply);
    /**
     * description: This function send parameters of limiter. If there is no error it will return
     *   0. If not it will return -1.
     */
    virtual void sendLimiter(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::hq_limiterStruct_param _limiter, sendLimiterReply_t _reply);
    /**
     * description: This function send parameters of EQ filter. If there is no error it will return
     *   0. If not it will return -1.
     */
    virtual void sendEQFilter(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::hq_eqFilterStruct_param _bsFilter, sendEQFilterReply_t _reply);
    /**
     * description: This function send parameters of delay time. If there is no error it will
     *   return 0. If not it will return -1.
     */
    virtual void sendDelayTime(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::hq_delayTimeStruct_param _delayTime, sendDelayTimeReply_t _reply);
    /**
     * description: This function send parameters of ClariFi. If there is no error it will return
     *   0. If not it will return -1.
     */
    virtual void sendClariFi(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::hq_ClariFiStruct_param _bs, sendClariFiReply_t _reply);
    /**
     * description: This function send parameters of loudness. If there is no error it will return
     *   0. If not it will return -1.
     */
    virtual void sendLoudness(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::hq_londnessStruct_param _bs, sendLoudnessReply_t _reply);
    /**
     * description: This function send parameters of channel gain. If there is no error it will
     *   return 0. If not it will return -1.
     */
    virtual void sendChannelGain(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::hq_channelGainStruct_param _bs, sendChannelGainReply_t _reply);
    /**
     * description: This function send parameters of maximum volume of source. If there is no error
     *   it will return 0. If not it will return -1.
     */
    virtual void sendVolumeMax(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::hq_sourceID_t _sourceID, ::v3::org::genivi::am_t::hq_volume_t _volume, sendVolumeMaxReply_t _reply);
    /**
     * description: This function send parameters of minimum volume of source. If there is no error
     *   it will return 0. If not it will return -1.
     */
    virtual void sendVolumeMin(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::hq_sourceID_t _sourceID, ::v3::org::genivi::am_t::hq_volume_t _volume, sendVolumeMinReply_t _reply);
    /**
     * description: This function send parameters of absolute volume of source. If there is no
     *   error it will return 0. If not it will return -1.
     */
    virtual void sendVolumeAbs(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::hq_sourceID_t _sourceID, ::v3::org::genivi::am_t::hq_volume_t _volume, sendVolumeAbsReply_t _reply);
    /**
     * description: This function send parameters of ratio volume of source. If there is no error
     *   it will return 0. If not it will return -1.
     */
    virtual void sendVolumeRatio(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::hq_sourceID_t _sourceID, ::v3::org::genivi::am_t::hq_volume_t _volume, sendVolumeRatioReply_t _reply);
    /**
     * description: This function save tuning data into configuration file. If there is no error it
     *   will return 0. If not it will return -1.
     */
    virtual void saveDataToFile(const std::shared_ptr<CommonAPI::ClientId> _client, saveDataToFileReply_t _reply);



protected:
    /**
     * description: This attribute signals the current routing state to the clients. A client
     *   should notify himself to this attribute in order to know the current state and
     *   act accordingly.
     */
    virtual bool trySetRoutingReadyAttribute(::v3::org::genivi::am_t::am_RoutingReady_e _value);
    virtual bool validateRoutingReadyAttributeRequestedValue(const ::v3::org::genivi::am_t::am_RoutingReady_e &_value);
    class RemoteEventHandler: public virtual RoutingControlObserverStubRemoteEvent {
    public:
        RemoteEventHandler(RoutingControlObserverStubDefault *_defaultStub);

        /**
         * description: This attribute signals the current routing state to the clients. A client
         *   should notify himself to this attribute in order to know the current state and
         *   act accordingly.
         */


    private:
        RoutingControlObserverStubDefault *defaultStub_;
    };
private:
    RoutingControlObserverStubDefault::RemoteEventHandler remoteEventHandler_;

    /**
     * description: This attribute signals the current routing state to the clients. A client
     *   should notify himself to this attribute in order to know the current state and
     *   act accordingly.
     */
    ::v3::org::genivi::am_t::am_RoutingReady_e routingReadyAttributeValue_ {};

    CommonAPI::Version interfaceVersion_;
};

} // namespace routinginterface
} // namespace am
} // namespace genivi
} // namespace org
} // namespace v3


// Compatibility
namespace v3_7 = v3;

#endif // V3_ORG_GENIVI_AM_ROUTINGINTERFACE_Routing_Control_Observer_STUB_DEFAULT
