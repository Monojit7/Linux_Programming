/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus .
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
/**
 * description: This is a Common API DBUS control interface of audio presentation controller
 *   for Orinoco 2.0
 * author: AYatheesh
 */
#include <v2/com/harman/audio/audioPresCtrl/audioPresCtrlControlsDBusProxy.hpp>

namespace v2 {
namespace com {
namespace harman {
namespace audio {
namespace audioPresCtrl {

std::shared_ptr<CommonAPI::DBus::DBusProxy> createaudioPresCtrlControlsDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection) {
	return std::make_shared<audioPresCtrlControlsDBusProxy>(_address, _connection);
}

INITIALIZER(registeraudioPresCtrlControlsDBusProxy) {
     CommonAPI::DBus::Factory::get()->registerProxyCreateMethod(
		audioPresCtrlControls::getInterface(),
		&createaudioPresCtrlControlsDBusProxy);
}

audioPresCtrlControlsDBusProxy::audioPresCtrlControlsDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection)
	:	CommonAPI::DBus::DBusProxy(_address, _connection)
,		activeAudioSources_(*this, "onActiveAudioSourcesAttributeChanged", "aq", "getActiveAudioSourcesAttribute", static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr)),
		activeEntSource_(*this, "onActiveEntSourceAttributeChanged", "(iisiys)", "getActiveEntSourceAttribute", static_cast<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes_::sSourceInfoDeployment_t*>(nullptr)),
		entSourceList_(*this, "onEntSourceListAttributeChanged", "a{i(iisiys)}", "getEntSourceListAttribute", static_cast<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes_::mEntSrcsInfoDeployment_t*>(nullptr))
,		entertainmentSrcStatus_(*this, "EntertainmentSrcStatus", "(iisiys)", std::make_tuple(static_cast<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes_::sSourceInfoDeployment_t*>(nullptr)))
{
}

      audioPresCtrlControlsDBusProxy::ActiveAudioSourcesAttribute& audioPresCtrlControlsDBusProxy::getActiveAudioSourcesAttribute() {
          return activeAudioSources_;
      }
      audioPresCtrlControlsDBusProxy::ActiveEntSourceAttribute& audioPresCtrlControlsDBusProxy::getActiveEntSourceAttribute() {
          return activeEntSource_;
      }
      audioPresCtrlControlsDBusProxy::EntSourceListAttribute& audioPresCtrlControlsDBusProxy::getEntSourceListAttribute() {
          return entSourceList_;
      }

audioPresCtrlControlsDBusProxy::EntertainmentSrcStatusEvent& audioPresCtrlControlsDBusProxy::getEntertainmentSrcStatusEvent() {
    return entertainmentSrcStatus_;
}
    
    /**
     * description: This method is used to set audio entertainment sources
    	(at)attribute update
     *   activeAudioSource and activeEntSrc
     */
    void audioPresCtrlControlsDBusProxy::SetEntertainmentSrc(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs &_sourceId, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs, CommonAPI::EmptyDeployment> deploy_sourceId(_sourceId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "SetEntertainmentSrc",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sourceId,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> audioPresCtrlControlsDBusProxy::SetEntertainmentSrcAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs &_sourceId, SetEntertainmentSrcAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs, CommonAPI::EmptyDeployment> deploy_sourceId(_sourceId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "SetEntertainmentSrc",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sourceId,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: This method is used to switch Audio Context to the source in the given
     *   group
    	Group needs to be first mentioned in the audiopres.cfg
    	Project may
     *   choose any naming strategy as long as it doesnt conflict with another json key
     *   in the cfg
    	(at)attribute update activeAudioSource and activeEntSrc if a
     *   source switch has happened
    	(at)return eAudioPresErrors
     */
    void audioPresCtrlControlsDBusProxy::SetSourceGroup(const std::string &_sourceGroupName, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_sourceGroupName(_sourceGroupName, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "SetSourceGroup",
        "s",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sourceGroupName,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> audioPresCtrlControlsDBusProxy::SetSourceGroupAsync(const std::string &_sourceGroupName, SetSourceGroupAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_sourceGroupName(_sourceGroupName, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "SetSourceGroup",
        "s",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sourceGroupName,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: This method is used to toggle source in the source group
    	SetSourceGroup needs
     *   to be invoked in order to select an active group
    	(at)attribute update
     *   activeAudioSource and activeEntSrc if a source switch has happened
    	(at)return
     *   eAudioPresErrors
     */
    void audioPresCtrlControlsDBusProxy::ToggleInSourceGroup(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection &_direction, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection, CommonAPI::EmptyDeployment> deploy_direction(_direction, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "ToggleInSourceGroup",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_direction,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> audioPresCtrlControlsDBusProxy::ToggleInSourceGroupAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection &_direction, ToggleInSourceGroupAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection, CommonAPI::EmptyDeployment> deploy_direction(_direction, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "ToggleInSourceGroup",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_direction,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: This method is used to toggle source in the order specified in
     *   "toggleNextPreviousStrategy" in audiopes.cfg
    	If no cfg item
     *   toggleNextPreviousStrategy with value is defined , method return an
     *   error
    	toggleNextPreviousStrategy should be used to capture the toggle
     *   sequence of entertainment sources in a project
    	(at)attribute update
     *   activeAudioSource and activeEntSrc if a source switch has
     *   happened	
    	(at)return eAudioPresErrors
     */
    void audioPresCtrlControlsDBusProxy::ToggleSource(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection &_direction, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection, CommonAPI::EmptyDeployment> deploy_direction(_direction, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "ToggleSource",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_direction,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> audioPresCtrlControlsDBusProxy::ToggleSourceAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection &_direction, ToggleSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection, CommonAPI::EmptyDeployment> deploy_direction(_direction, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "ToggleSource",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_direction,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: to activate interrupt source with given SourceID
    	Only touchbeep and keytouch
     *   srcs will be supported through requestinformationsource interface
    	as these
     *   are the only sources that will be requested by HMIs
    	Other sources will be
     *   invoked for switch by respective pres ctrl (ex btpres for hfp , projectionpres
     *   for alt audio sources etc)
    	Other sources are kept just so that HMI can track
     *   the active source through attribute activeAudioSource    
    	(at)return
     *   eAudioPresErrors
     */
    void audioPresCtrlControlsDBusProxy::RequestInformationSource(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs &_sourceID, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "RequestInformationSource",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sourceID,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> audioPresCtrlControlsDBusProxy::RequestInformationSourceAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs &_sourceID, RequestInformationSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "RequestInformationSource",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sourceID,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: to deactivate interrupt source with given SourceID
    	(at)return eAudioPresErrors
     */
    void audioPresCtrlControlsDBusProxy::ReleaseInformationSource(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs &_sourceID, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "ReleaseInformationSource",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sourceID,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> audioPresCtrlControlsDBusProxy::ReleaseInformationSourceAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs &_sourceID, ReleaseInformationSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "ReleaseInformationSource",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sourceID,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: to deactivate entertainment source from HMI with given SourceID for example
     *   AudioOff
    	(at)return eAudioPresErrors
     */
    void audioPresCtrlControlsDBusProxy::ReleaseEntertainmentSource(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs &_sourceID, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "ReleaseEntertainmentSource",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sourceID,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> audioPresCtrlControlsDBusProxy::ReleaseEntertainmentSourceAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs &_sourceID, ReleaseEntertainmentSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "ReleaseEntertainmentSource",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sourceID,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }


void audioPresCtrlControlsDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
          ownVersionMajor = 2;
          ownVersionMinor = 1;
      }

      } // namespace audioPresCtrl
      } // namespace audio
      } // namespace harman
      } // namespace com
      } // namespace v2
