/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core .
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
/**
 * author: lian zhang
 */
#ifndef V3_ORG_GENIVI_am_t_HPP_
#define V3_ORG_GENIVI_am_t_HPP_



#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <CommonAPI/Variant.hpp>
#include <cstdint>
#include <memory>
#include <string>
#include <vector>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v3 {
namespace org {
namespace genivi {

struct am_t {
    /**
     * description: A source ID.
     */
    typedef uint16_t am_sourceID_t;
    /**
     * description: A mainConnection ID.
     */
    typedef uint16_t am_mainConnectionID_t;
    /**
     * description: Offset time that is introduced in milliseconds.
     */
    typedef int16_t am_timeSync_t;
    /**
     * description: A sink ID.
     */
    typedef uint16_t am_sinkID_t;
    
    struct am_ConnectionState_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            CS_UNKNOWN = 0,
            CS_CONNECTING = 1,
            CS_CONNECTED = 2,
            CS_DISCONNECTING = 3,
            CS_DISCONNECTED = 4,
            CS_SUSPENDED = 5,
            CS_MAX = 6
        };
        
        am_ConnectionState_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::CS_UNKNOWN)) {}
        am_ConnectionState_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::CS_UNKNOWN):
                case static_cast<int32_t>(Literal::CS_CONNECTING):
                case static_cast<int32_t>(Literal::CS_CONNECTED):
                case static_cast<int32_t>(Literal::CS_DISCONNECTING):
                case static_cast<int32_t>(Literal::CS_DISCONNECTED):
                case static_cast<int32_t>(Literal::CS_SUSPENDED):
                case static_cast<int32_t>(Literal::CS_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_ConnectionState_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_ConnectionState_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_ConnectionState_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_ConnectionState_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_ConnectionState_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_ConnectionState_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: This type holds all information of connections relevant to the HMI.
     */
    struct am_MainConnectionType_s : CommonAPI::Struct<am_mainConnectionID_t, am_sourceID_t, am_sinkID_t, am_timeSync_t, am_ConnectionState_e> {
    	
    	am_MainConnectionType_s() {
    	}
    	am_MainConnectionType_s(const am_mainConnectionID_t &_mainConnectionID, const am_sourceID_t &_sourceID, const am_sinkID_t &_sinkID, const am_timeSync_t &_delay, const am_ConnectionState_e &_connectionState)
    	{
    		std::get<0>(values_) = _mainConnectionID;
    		std::get<1>(values_) = _sourceID;
    		std::get<2>(values_) = _sinkID;
    		std::get<3>(values_) = _delay;
    		std::get<4>(values_) = _connectionState;
    	}
    	/**
    	 * description: The ID of the main connection.
    	 */
    	inline const am_mainConnectionID_t &getMainConnectionID() const { return std::get<0>(values_); }
    	inline void setMainConnectionID(const am_mainConnectionID_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The source ID where the connection starts, we have list all the sourceID
    	 *   enumeration in am_sourceID_e.
    	 */
    	inline const am_sourceID_t &getSourceID() const { return std::get<1>(values_); }
    	inline void setSourceID(const am_sourceID_t &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: The sink ID where the connection ends, we have list all the sourceID
    	 *   enumeration in am_sinkID_e.
    	 */
    	inline const am_sinkID_t &getSinkID() const { return std::get<2>(values_); }
    	inline void setSinkID(const am_sinkID_t &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: The delay of the main connection.
    	 */
    	inline const am_timeSync_t &getDelay() const { return std::get<3>(values_); }
    	inline void setDelay(const am_timeSync_t &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: The current connection state.
    	 */
    	inline const am_ConnectionState_e &getConnectionState() const { return std::get<4>(values_); }
    	inline void setConnectionState(const am_ConnectionState_e &_value) { std::get<4>(values_) = _value; }
    	inline bool operator==(const am_MainConnectionType_s& _other) const {
                return (getMainConnectionID() == _other.getMainConnectionID() && getSourceID() == _other.getSourceID() && getSinkID() == _other.getSinkID() && getDelay() == _other.getDelay() && getConnectionState() == _other.getConnectionState());
        }
    	inline bool operator!=(const am_MainConnectionType_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    typedef std::vector<am_t::am_MainConnectionType_s> am_MainConnection_L;
    /**
     * description: Product specific identifier of property.
     */
    typedef uint16_t am_ClassProperty_pe;
    /**
     * description: Describes class properties.
     */
    struct am_ClassProperty_s : CommonAPI::Struct<am_ClassProperty_pe, int16_t> {
    	
    	am_ClassProperty_s() {
    	}
    	am_ClassProperty_s(const am_ClassProperty_pe &_classProperty, const int16_t &_value)
    	{
    		std::get<0>(values_) = _classProperty;
    		std::get<1>(values_) = _value;
    	}
    	/**
    	 * description: The property as enum.
    	 */
    	inline const am_ClassProperty_pe &getClassProperty() const { return std::get<0>(values_); }
    	inline void setClassProperty(const am_ClassProperty_pe &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The value of the property.
    	 */
    	inline const int16_t &getValue() const { return std::get<1>(values_); }
    	inline void setValue(const int16_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const am_ClassProperty_s& _other) const {
                return (getClassProperty() == _other.getClassProperty() && getValue() == _other.getValue());
        }
    	inline bool operator!=(const am_ClassProperty_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    typedef std::vector<am_t::am_ClassProperty_s> am_ClassProperty_L;
    typedef uint16_t am_sinkClass_t;
    /**
     * description: Struct describing sink classes.
     */
    struct am_SinkClass_s : CommonAPI::Struct<am_sinkClass_t, std::string, am_ClassProperty_L> {
    	
    	am_SinkClass_s() {
    	}
    	am_SinkClass_s(const am_sinkClass_t &_sinkClassID, const std::string &_name, const am_ClassProperty_L &_listClassProperties)
    	{
    		std::get<0>(values_) = _sinkClassID;
    		std::get<1>(values_) = _name;
    		std::get<2>(values_) = _listClassProperties;
    	}
    	/**
    	 * description: The ID of the sink class.
    	 */
    	inline const am_sinkClass_t &getSinkClassID() const { return std::get<0>(values_); }
    	inline void setSinkClassID(const am_sinkClass_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The name of the sink class - must be unique in the system.
    	 */
    	inline const std::string &getName() const { return std::get<1>(values_); }
    	inline void setName(const std::string &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: The list of the class properties. These are pairs of a project specific enum
    	 *   describing the type of the value and an integer holding the value.
    	 */
    	inline const am_ClassProperty_L &getListClassProperties() const { return std::get<2>(values_); }
    	inline void setListClassProperties(const am_ClassProperty_L &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const am_SinkClass_s& _other) const {
                return (getSinkClassID() == _other.getSinkClassID() && getName() == _other.getName() && getListClassProperties() == _other.getListClassProperties());
        }
    	inline bool operator!=(const am_SinkClass_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    typedef std::vector<am_t::am_SinkClass_s> am_SinkClass_L;
    /**
     * description: This is the volume presented on the command interface. It is in the duty of the
     *   controller to change the volumes given here into meaningful values on the
     *   routing interface.
    The range of this type is customer specific.
     */
    typedef int16_t am_mainVolume_t;
    /**
     * description: This project specific value gives the information about reason for source/sink
     *   change.
     */
    typedef uint16_t am_AvailabilityReason_pe;
    
    struct am_Availability_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            A_UNKNOWN = 0,
            A_AVAILABLE = 1,
            A_UNAVAILABLE = 2,
            A_MAX = 3
        };
        
        am_Availability_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::A_UNKNOWN)) {}
        am_Availability_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::A_UNKNOWN):
                case static_cast<int32_t>(Literal::A_AVAILABLE):
                case static_cast<int32_t>(Literal::A_UNAVAILABLE):
                case static_cast<int32_t>(Literal::A_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_Availability_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_Availability_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_Availability_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_Availability_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_Availability_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_Availability_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: This describes the availability of a sink or a source together with the latest
     *   change.
     */
    struct am_Availability_s : CommonAPI::Struct<am_Availability_e, am_AvailabilityReason_pe> {
    	
    	am_Availability_s() {
    	}
    	am_Availability_s(const am_Availability_e &_availability, const am_AvailabilityReason_pe &_availabilityReason)
    	{
    		std::get<0>(values_) = _availability;
    		std::get<1>(values_) = _availabilityReason;
    	}
    	/**
    	 * description: The current availability state.
    	 */
    	inline const am_Availability_e &getAvailability() const { return std::get<0>(values_); }
    	inline void setAvailability(const am_Availability_e &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The reason for the last change. now audioManager don't care about it. the user
    	 *   can always set the value as 0.
    	 */
    	inline const am_AvailabilityReason_pe &getAvailabilityReason() const { return std::get<1>(values_); }
    	inline void setAvailabilityReason(const am_AvailabilityReason_pe &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const am_Availability_s& _other) const {
                return (getAvailability() == _other.getAvailability() && getAvailabilityReason() == _other.getAvailabilityReason());
        }
    	inline bool operator!=(const am_Availability_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    
    struct am_MuteState_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            MS_UNKNOWN = 0,
            MS_MUTED = 1,
            MS_UNMUTED = 2,
            MS_MAX = 3
        };
        
        am_MuteState_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::MS_UNKNOWN)) {}
        am_MuteState_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::MS_UNKNOWN):
                case static_cast<int32_t>(Literal::MS_MUTED):
                case static_cast<int32_t>(Literal::MS_UNMUTED):
                case static_cast<int32_t>(Literal::MS_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_MuteState_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_MuteState_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_MuteState_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_MuteState_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_MuteState_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_MuteState_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: This type holds all information of sinks relevant to the HMI.
     */
    struct am_SinkType_s : CommonAPI::Struct<am_sinkID_t, std::string, am_Availability_s, am_mainVolume_t, am_MuteState_e, am_sinkClass_t> {
    	
    	am_SinkType_s() {
    	}
    	am_SinkType_s(const am_sinkID_t &_sinkID, const std::string &_name, const am_Availability_s &_availability, const am_mainVolume_t &_volume, const am_MuteState_e &_muteState, const am_sinkClass_t &_sinkClassID)
    	{
    		std::get<0>(values_) = _sinkID;
    		std::get<1>(values_) = _name;
    		std::get<2>(values_) = _availability;
    		std::get<3>(values_) = _volume;
    		std::get<4>(values_) = _muteState;
    		std::get<5>(values_) = _sinkClassID;
    	}
    	/**
    	 * description: This is the ID of the sink, it is unique in the system. we have list all the
    	 *   sourceID enumeration in am_sinkID_e.
    	 */
    	inline const am_sinkID_t &getSinkID() const { return std::get<0>(values_); }
    	inline void setSinkID(const am_sinkID_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The name of the sink. Must be unique in the whole system.
    	 */
    	inline const std::string &getName() const { return std::get<1>(values_); }
    	inline void setName(const std::string &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: This attribute reflects the availability of the sink. There are several reasons
    	 *   why a sink could be not available for the moment: for example the shutdown of
    	 *   a sink because of overtemperature or over- &amp; undervoltage. The
    	 *   availability consists of two pieces of information:
    	- Availablility: the
    	 *   status itself, can be A_AVAILABLE, A_UNAVAILABLE or A_UNKNOWN
    	-
    	 *   AvailabilityReason: this informs about the last reason for a change in
    	 *   availability. The reasons itself are product specific.
    	 */
    	inline const am_Availability_s &getAvailability() const { return std::get<2>(values_); }
    	inline void setAvailability(const am_Availability_s &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: This is the representation of the Volume for the commandInterface. It is used
    	 *   by the HMI to set the volume of a sink, the AudioManagerController has to
    	 *   transform this into real source and sink volumes.
    	 */
    	inline const am_mainVolume_t &getVolume() const { return std::get<3>(values_); }
    	inline void setVolume(const am_mainVolume_t &_value) { std::get<3>(values_) = _value; }
    	inline const am_MuteState_e &getMuteState() const { return std::get<4>(values_); }
    	inline void setMuteState(const am_MuteState_e &_value) { std::get<4>(values_) = _value; }
    	/**
    	 * description: The sink class ID references to a sink class. With the help of classification,
    	 *   rules can be setup to define the system behavior. the attribute is not used
    	 *   now.
    	 */
    	inline const am_sinkClass_t &getSinkClassID() const { return std::get<5>(values_); }
    	inline void setSinkClassID(const am_sinkClass_t &_value) { std::get<5>(values_) = _value; }
    	inline bool operator==(const am_SinkType_s& _other) const {
                return (getSinkID() == _other.getSinkID() && getName() == _other.getName() && getAvailability() == _other.getAvailability() && getVolume() == _other.getVolume() && getMuteState() == _other.getMuteState() && getSinkClassID() == _other.getSinkClassID());
        }
    	inline bool operator!=(const am_SinkType_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    typedef std::vector<am_t::am_SinkType_s> am_SinkType_L;
    typedef uint16_t am_sourceClass_t;
    /**
     * description: Struct describing source classes.
     */
    struct am_SourceClass_s : CommonAPI::Struct<am_sourceClass_t, std::string, am_ClassProperty_L> {
    	
    	am_SourceClass_s() {
    	}
    	am_SourceClass_s(const am_sourceClass_t &_sourceClassID, const std::string &_name, const am_ClassProperty_L &_listClassProperties)
    	{
    		std::get<0>(values_) = _sourceClassID;
    		std::get<1>(values_) = _name;
    		std::get<2>(values_) = _listClassProperties;
    	}
    	/**
    	 * description: The source ID.
    	 */
    	inline const am_sourceClass_t &getSourceClassID() const { return std::get<0>(values_); }
    	inline void setSourceClassID(const am_sourceClass_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The name of the source class - must be unique in the system.
    	 */
    	inline const std::string &getName() const { return std::get<1>(values_); }
    	inline void setName(const std::string &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: The list of the class properties. These are pairs of a project specific enum
    	 *   describing the type of the value and an integer holding the value.
    	 */
    	inline const am_ClassProperty_L &getListClassProperties() const { return std::get<2>(values_); }
    	inline void setListClassProperties(const am_ClassProperty_L &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const am_SourceClass_s& _other) const {
                return (getSourceClassID() == _other.getSourceClassID() && getName() == _other.getName() && getListClassProperties() == _other.getListClassProperties());
        }
    	inline bool operator!=(const am_SourceClass_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    typedef std::vector<am_t::am_SourceClass_s> am_SourceClass_L;
    /**
     * description: This type holds all information of sources relevant to the HMI.
     */
    struct am_SourceType_s : CommonAPI::Struct<am_sourceID_t, std::string, am_Availability_s, am_sourceClass_t> {
    	
    	am_SourceType_s() {
    	}
    	am_SourceType_s(const am_sourceID_t &_sourceID, const std::string &_name, const am_Availability_s &_availability, const am_sourceClass_t &_sourceClassID)
    	{
    		std::get<0>(values_) = _sourceID;
    		std::get<1>(values_) = _name;
    		std::get<2>(values_) = _availability;
    		std::get<3>(values_) = _sourceClassID;
    	}
    	/**
    	 * description: This is the ID of the source, it is unique in the system. we have list all the
    	 *   sourceID enumeration in am_sourceID_e.
    	 */
    	inline const am_sourceID_t &getSourceID() const { return std::get<0>(values_); }
    	inline void setSourceID(const am_sourceID_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The name of the source. Must be unique in the whole system.
    	 */
    	inline const std::string &getName() const { return std::get<1>(values_); }
    	inline void setName(const std::string &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: The availability of the source.
    	 */
    	inline const am_Availability_s &getAvailability() const { return std::get<2>(values_); }
    	inline void setAvailability(const am_Availability_s &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: The source class ID, indicates the class the source is in. the attribute is not
    	 *   used.
    	 */
    	inline const am_sourceClass_t &getSourceClassID() const { return std::get<3>(values_); }
    	inline void setSourceClassID(const am_sourceClass_t &_value) { std::get<3>(values_) = _value; }
    	inline bool operator==(const am_SourceType_s& _other) const {
                return (getSourceID() == _other.getSourceID() && getName() == _other.getName() && getAvailability() == _other.getAvailability() && getSourceClassID() == _other.getSourceClassID());
        }
    	inline bool operator!=(const am_SourceType_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    typedef std::vector<am_t::am_SourceType_s> am_SourceType_L;
    
    struct am_SystemPropertyType_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            SYS_UNKNOWN = 0,
            SYS_MASTER_RESET = 1,
            SYS_FACTORY_RESET = 2,
            SYS_EMERGENCY_CALL_MUTE = 3,
            SYS_MULTIMEDIA_REBOOT = 4,
            SYS_AUDIO_OFF = 5,
            SYS_OCCUPANCY_MODE = 6,
            SYS_MYKEY = 7,
            SYS_ESE = 8,
            SYS_DSP_RESET = 9,
            SYS_AA_CONNECT_TYPE = 10,
            SYS_RESUME_LAST_SOURCE = 11,
            SYS_STARTUP_VOLUME = 12,
            SYS_MAX = 13
        };
        
        am_SystemPropertyType_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::SYS_UNKNOWN)) {}
        am_SystemPropertyType_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::SYS_UNKNOWN):
                case static_cast<int32_t>(Literal::SYS_MASTER_RESET):
                case static_cast<int32_t>(Literal::SYS_FACTORY_RESET):
                case static_cast<int32_t>(Literal::SYS_EMERGENCY_CALL_MUTE):
                case static_cast<int32_t>(Literal::SYS_MULTIMEDIA_REBOOT):
                case static_cast<int32_t>(Literal::SYS_AUDIO_OFF):
                case static_cast<int32_t>(Literal::SYS_OCCUPANCY_MODE):
                case static_cast<int32_t>(Literal::SYS_MYKEY):
                case static_cast<int32_t>(Literal::SYS_ESE):
                case static_cast<int32_t>(Literal::SYS_DSP_RESET):
                case static_cast<int32_t>(Literal::SYS_AA_CONNECT_TYPE):
                case static_cast<int32_t>(Literal::SYS_RESUME_LAST_SOURCE):
                case static_cast<int32_t>(Literal::SYS_STARTUP_VOLUME):
                case static_cast<int32_t>(Literal::SYS_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_SystemPropertyType_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_SystemPropertyType_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_SystemPropertyType_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_SystemPropertyType_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_SystemPropertyType_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_SystemPropertyType_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: Struct describing system properties.
     */
    struct am_SystemProperty_s : CommonAPI::Struct<am_SystemPropertyType_e, int16_t> {
    	
    	am_SystemProperty_s() {
    	}
    	am_SystemProperty_s(const am_SystemPropertyType_e &_type, const int16_t &_value)
    	{
    		std::get<0>(values_) = _type;
    		std::get<1>(values_) = _value;
    	}
    	/**
    	 * description: The type that is set.
    	 */
    	inline const am_SystemPropertyType_e &getType() const { return std::get<0>(values_); }
    	inline void setType(const am_SystemPropertyType_e &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The value.
    	 */
    	inline const int16_t &getValue() const { return std::get<1>(values_); }
    	inline void setValue(const int16_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const am_SystemProperty_s& _other) const {
                return (getType() == _other.getType() && getValue() == _other.getValue());
        }
    	inline bool operator!=(const am_SystemProperty_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    typedef std::vector<am_t::am_SystemProperty_s> am_SystemProperty_L;
    /**
     * description: A connection ID.
     */
    typedef uint16_t am_connectionID_t;
    typedef std::vector<am_t::am_connectionID_t> am_ConnectionID_L;
    /**
     * description: The unit is 0.1 db steps. The smallest value -3000 (=am_MUTE). The minimum and
     *   maximum can be limited by actual project.
     */
    typedef int16_t am_volume_t;
    /**
     * description: Project specific sound properties.
     */
    typedef uint16_t am_SoundPropertyType_pe;
    /**
     * description: Data type depends of am_EarlyDataType_e:
    sourceID in case of ED_SOURCE_VOLUME,
     *   ED_SOURCE_PROPERTY
    sinkID in case of ED_SINK_VOLUME, ED_SINK_PROPERTY
     */
    typedef CommonAPI::Variant<am_sinkID_t, am_sourceID_t>  am_DataType_u;
    /**
     * description: Struct describing the sound property.
     */
    struct am_SoundProperty_s : CommonAPI::Struct<am_SoundPropertyType_pe, int16_t> {
    	
    	am_SoundProperty_s() {
    	}
    	am_SoundProperty_s(const am_SoundPropertyType_pe &_type, const int16_t &_value)
    	{
    		std::get<0>(values_) = _type;
    		std::get<1>(values_) = _value;
    	}
    	/**
    	 * description: The type of the property - a project specific enum.
    	 */
    	inline const am_SoundPropertyType_pe &getType() const { return std::get<0>(values_); }
    	inline void setType(const am_SoundPropertyType_pe &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The current value of the property.
    	 */
    	inline const int16_t &getValue() const { return std::get<1>(values_); }
    	inline void setValue(const int16_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const am_SoundProperty_s& _other) const {
                return (getType() == _other.getType() && getValue() == _other.getValue());
        }
    	inline bool operator!=(const am_SoundProperty_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Data type depends of am_EarlyDataType_e:
    am_volume_t in case of
     *   ED_SOURCE_VOLUME, ED_SINK_VOLUME 
    am_soundProperty_t in case of
     *   ED_SOURCE_PROPERTY, ED_SINK_PROPERTY
     */
    typedef CommonAPI::Variant<am_volume_t, am_SoundProperty_s>  am_EarlyData_u;
    
    struct am_EarlyDataType_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            ES_UNKNOWN = 0,
            ED_SOURCE_VOLUME = 1,
            ED_SINK_VOLUME = 2,
            ED_SOURCE_PROPERTY = 3,
            ED_SINK_PROPERTY = 4,
            ED_MAX = 5
        };
        
        am_EarlyDataType_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::ES_UNKNOWN)) {}
        am_EarlyDataType_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::ES_UNKNOWN):
                case static_cast<int32_t>(Literal::ED_SOURCE_VOLUME):
                case static_cast<int32_t>(Literal::ED_SINK_VOLUME):
                case static_cast<int32_t>(Literal::ED_SOURCE_PROPERTY):
                case static_cast<int32_t>(Literal::ED_SINK_PROPERTY):
                case static_cast<int32_t>(Literal::ED_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_EarlyDataType_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_EarlyDataType_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_EarlyDataType_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_EarlyDataType_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_EarlyDataType_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_EarlyDataType_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    struct am_EarlyData_s : CommonAPI::Struct<am_EarlyDataType_e, am_DataType_u, am_EarlyData_u> {
    	
    	am_EarlyData_s() {
    	}
    	am_EarlyData_s(const am_EarlyDataType_e &_type, const am_DataType_u &_sinksource, const am_EarlyData_u &_data)
    	{
    		std::get<0>(values_) = _type;
    		std::get<1>(values_) = _sinksource;
    		std::get<2>(values_) = _data;
    	}
    	inline const am_EarlyDataType_e &getType() const { return std::get<0>(values_); }
    	inline void setType(const am_EarlyDataType_e &_value) { std::get<0>(values_) = _value; }
    	inline const am_DataType_u &getSinksource() const { return std::get<1>(values_); }
    	inline void setSinksource(const am_DataType_u &_value) { std::get<1>(values_) = _value; }
    	inline const am_EarlyData_u &getData() const { return std::get<2>(values_); }
    	inline void setData(const am_EarlyData_u &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const am_EarlyData_s& _other) const {
                return (getType() == _other.getType() && getSinksource() == _other.getSinksource() && getData() == _other.getData());
        }
    	inline bool operator!=(const am_EarlyData_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    typedef std::vector<am_t::am_EarlyData_s> am_EarlyData_L;
    
    struct am_CustomSoundPropertyType_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            SP_UNKNOWN = 0,
            SP_GENIVI_FADE = 1,
            SP_GENIVI_BALANCE = 2,
            SP_GENIVI_BASS = 3,
            SP_GENIVI_MID_LOW = 12,
            SP_GENIVI_MID = 4,
            SP_GENIVI_MID_HIGH = 13,
            SP_GENIVI_TREBLE = 5,
            SP_GENIVI_EQ = 6,
            SP_GENIVI_CLARI_FI = 7,
            SP_GENIVI_LOUDNESS = 8,
            SP_GENIVI_AVC_MODE = 9,
            SP_GENIVI_CHIME_ATTENUATE = 18,
            SP_GENIVI_PROMPT_ATTENUATE = 20,
            SP_GENIVI_PROMPT_ATTENUATE_CANCEL = 21,
            SP_GENIVI_AUDIO_OUTPUT_CHANNEL = 29,
            SP_GENIVI_VOLUME_TO_MAXMIN = 30,
            SP_GENIVI_A2DP_OFFSET = 14,
            SP_GENIVI_MIC_GAIN = 15,
            SP_GENIVI_AUX_OFFSET = 10,
            SP_GENIVI_SOURCE_VOLUME_STEP = 16,
            SP_GENIVI_SOURCE_MUTE = 17,
            SP_GENIVI_CONNECTION_MODE = 22,
            SP_GENIVI_USB_AUTOPLAY = 23,
            SP_GENIVI_DIAG_FREQUENCY = 24,
            SP_GENIVI_DIAG_SPEARKMASK = 25,
            SP_GENIVI_DIAG_VOLUMEPERCENT = 26,
            SP_GENIVI_SOURCE_PRIORITY = 27,
            SP_GENIVI_MIC_LOOP = 28,
            SP_GENIVI_VOLUME_UPDATE = 19,
            SP_GENIVI_AMP_MUTE = 31,
            SP_GENIVI_EQ_USERDEF = 32,
            SP_GENIVI_DIAG_START_FREQUENCY = 33,
            SP_GENIVI_DIAG_END_FREQUENCY = 34,
            SP_GENIVI_DIAG_TONETYPE = 35,
            SP_GENIVI_GALA = 36,
            SP_GENIVI_WVPL_PLAY_STATE = 37,
            SP_GENIVI_SOURCE_EXTERNAL_MUTE = 38,
            SP_MAX = 39
        };
        
        am_CustomSoundPropertyType_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::SP_UNKNOWN)) {}
        am_CustomSoundPropertyType_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::SP_UNKNOWN):
                case static_cast<int32_t>(Literal::SP_GENIVI_FADE):
                case static_cast<int32_t>(Literal::SP_GENIVI_BALANCE):
                case static_cast<int32_t>(Literal::SP_GENIVI_BASS):
                case static_cast<int32_t>(Literal::SP_GENIVI_MID_LOW):
                case static_cast<int32_t>(Literal::SP_GENIVI_MID):
                case static_cast<int32_t>(Literal::SP_GENIVI_MID_HIGH):
                case static_cast<int32_t>(Literal::SP_GENIVI_TREBLE):
                case static_cast<int32_t>(Literal::SP_GENIVI_EQ):
                case static_cast<int32_t>(Literal::SP_GENIVI_CLARI_FI):
                case static_cast<int32_t>(Literal::SP_GENIVI_LOUDNESS):
                case static_cast<int32_t>(Literal::SP_GENIVI_AVC_MODE):
                case static_cast<int32_t>(Literal::SP_GENIVI_CHIME_ATTENUATE):
                case static_cast<int32_t>(Literal::SP_GENIVI_PROMPT_ATTENUATE):
                case static_cast<int32_t>(Literal::SP_GENIVI_PROMPT_ATTENUATE_CANCEL):
                case static_cast<int32_t>(Literal::SP_GENIVI_AUDIO_OUTPUT_CHANNEL):
                case static_cast<int32_t>(Literal::SP_GENIVI_VOLUME_TO_MAXMIN):
                case static_cast<int32_t>(Literal::SP_GENIVI_A2DP_OFFSET):
                case static_cast<int32_t>(Literal::SP_GENIVI_MIC_GAIN):
                case static_cast<int32_t>(Literal::SP_GENIVI_AUX_OFFSET):
                case static_cast<int32_t>(Literal::SP_GENIVI_SOURCE_VOLUME_STEP):
                case static_cast<int32_t>(Literal::SP_GENIVI_SOURCE_MUTE):
                case static_cast<int32_t>(Literal::SP_GENIVI_CONNECTION_MODE):
                case static_cast<int32_t>(Literal::SP_GENIVI_USB_AUTOPLAY):
                case static_cast<int32_t>(Literal::SP_GENIVI_DIAG_FREQUENCY):
                case static_cast<int32_t>(Literal::SP_GENIVI_DIAG_SPEARKMASK):
                case static_cast<int32_t>(Literal::SP_GENIVI_DIAG_VOLUMEPERCENT):
                case static_cast<int32_t>(Literal::SP_GENIVI_SOURCE_PRIORITY):
                case static_cast<int32_t>(Literal::SP_GENIVI_MIC_LOOP):
                case static_cast<int32_t>(Literal::SP_GENIVI_VOLUME_UPDATE):
                case static_cast<int32_t>(Literal::SP_GENIVI_AMP_MUTE):
                case static_cast<int32_t>(Literal::SP_GENIVI_EQ_USERDEF):
                case static_cast<int32_t>(Literal::SP_GENIVI_DIAG_START_FREQUENCY):
                case static_cast<int32_t>(Literal::SP_GENIVI_DIAG_END_FREQUENCY):
                case static_cast<int32_t>(Literal::SP_GENIVI_DIAG_TONETYPE):
                case static_cast<int32_t>(Literal::SP_GENIVI_GALA):
                case static_cast<int32_t>(Literal::SP_GENIVI_WVPL_PLAY_STATE):
                case static_cast<int32_t>(Literal::SP_GENIVI_SOURCE_EXTERNAL_MUTE):
                case static_cast<int32_t>(Literal::SP_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_CustomSoundPropertyType_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_CustomSoundPropertyType_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_CustomSoundPropertyType_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_CustomSoundPropertyType_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_CustomSoundPropertyType_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_CustomSoundPropertyType_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: Struct describing main sound property.
     */
    struct am_MainSoundProperty_s : CommonAPI::Struct<am_CustomSoundPropertyType_e, int16_t> {
    	
    	am_MainSoundProperty_s() {
    	}
    	am_MainSoundProperty_s(const am_CustomSoundPropertyType_e &_type, const int16_t &_value)
    	{
    		std::get<0>(values_) = _type;
    		std::get<1>(values_) = _value;
    	}
    	/**
    	 * description: The type of the property.
    	 */
    	inline const am_CustomSoundPropertyType_e &getType() const { return std::get<0>(values_); }
    	inline void setType(const am_CustomSoundPropertyType_e &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The current value.
    	 */
    	inline const int16_t &getValue() const { return std::get<1>(values_); }
    	inline void setValue(const int16_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const am_MainSoundProperty_s& _other) const {
                return (getType() == _other.getType() && getValue() == _other.getValue());
        }
    	inline bool operator!=(const am_MainSoundProperty_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    typedef std::vector<am_t::am_MainSoundProperty_s> am_MainSoundProperty_L;
    /**
     * description: Gives the type of the Notification.
     */
    typedef uint16_t am_NotificationType_pe;
    
    struct am_NotificationStatus_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            NS_UNKNOWN = 0,
            NS_OFF = 1,
            NS_PERIODIC = 2,
            NS_MINIMUM = 3,
            NS_MAXIMUM = 4,
            NS_CHANGE = 5,
            NS_MAX = 6
        };
        
        am_NotificationStatus_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::NS_UNKNOWN)) {}
        am_NotificationStatus_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::NS_UNKNOWN):
                case static_cast<int32_t>(Literal::NS_OFF):
                case static_cast<int32_t>(Literal::NS_PERIODIC):
                case static_cast<int32_t>(Literal::NS_MINIMUM):
                case static_cast<int32_t>(Literal::NS_MAXIMUM):
                case static_cast<int32_t>(Literal::NS_CHANGE):
                case static_cast<int32_t>(Literal::NS_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_NotificationStatus_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_NotificationStatus_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_NotificationStatus_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_NotificationStatus_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_NotificationStatus_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_NotificationStatus_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: This struct holds information about the configuration for notifications.
     */
    struct am_NotificationConfiguration_s : CommonAPI::Struct<am_NotificationType_pe, am_NotificationStatus_e, int16_t> {
    	
    	am_NotificationConfiguration_s() {
    	}
    	am_NotificationConfiguration_s(const am_NotificationType_pe &_type, const am_NotificationStatus_e &_status, const int16_t &_parameter)
    	{
    		std::get<0>(values_) = _type;
    		std::get<1>(values_) = _status;
    		std::get<2>(values_) = _parameter;
    	}
    	/**
    	 * description: The notification type of the notification.
    	 */
    	inline const am_NotificationType_pe &getType() const { return std::get<0>(values_); }
    	inline void setType(const am_NotificationType_pe &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The Notification status. This can be periodic, min/max value based or even off
    	 *   for example.
    	 */
    	inline const am_NotificationStatus_e &getStatus() const { return std::get<1>(values_); }
    	inline void setStatus(const am_NotificationStatus_e &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: This gives additional information to the notification status.
    	
    	Relation between
    	 *   notification status and the value:
    	NS_PERIODIC - the period in ms
    	NS_MINIMUM -
    	 *   the minimum value that triggers the notification
    	NS_MAXIMUM - the maximum
    	 *   value that triggers the notification
    	NS_CHANGE - the resolution of the change
    	 *   value
    	 */
    	inline const int16_t &getParameter() const { return std::get<2>(values_); }
    	inline void setParameter(const int16_t &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const am_NotificationConfiguration_s& _other) const {
                return (getType() == _other.getType() && getStatus() == _other.getStatus() && getParameter() == _other.getParameter());
        }
    	inline bool operator!=(const am_NotificationConfiguration_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    typedef std::vector<am_t::am_NotificationConfiguration_s> am_NotificationConfiguration_L;
    typedef std::vector<am_t::am_SoundProperty_s> am_SoundProperty_L;
    /**
     * description: Time in ms.
     */
    typedef int16_t am_time_t;
    /**
     * description: For products, different ramp types can be defined here.
    It is in the
     *   responsibility of the product to make sure that the routing plugins are aware
     *   of the ramp types used.
     */
    typedef uint16_t am_RampType_pe;
    
    struct am_VolumeType_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            VT_UNKNOWN = 0,
            VT_SINK = 1,
            VT_SOURCE = 2,
            VT_MAX = 3
        };
        
        am_VolumeType_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::VT_UNKNOWN)) {}
        am_VolumeType_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::VT_UNKNOWN):
                case static_cast<int32_t>(Literal::VT_SINK):
                case static_cast<int32_t>(Literal::VT_SOURCE):
                case static_cast<int32_t>(Literal::VT_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_VolumeType_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_VolumeType_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_VolumeType_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_VolumeType_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_VolumeType_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_VolumeType_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: This types describe a mixed description for source and sinks volumes.
     */
    struct am_Volumes_s : CommonAPI::Struct<am_VolumeType_e, am_DataType_u, am_volume_t, am_RampType_pe, am_time_t> {
    	
    	am_Volumes_s() {
    	}
    	am_Volumes_s(const am_VolumeType_e &_volumeType, const am_DataType_u &_volumeID, const am_volume_t &_volume, const am_RampType_pe &_ramp, const am_time_t &_time)
    	{
    		std::get<0>(values_) = _volumeType;
    		std::get<1>(values_) = _volumeID;
    		std::get<2>(values_) = _volume;
    		std::get<3>(values_) = _ramp;
    		std::get<4>(values_) = _time;
    	}
    	/**
    	 * description: Describes the type of the volume: source or sink.
    	 */
    	inline const am_VolumeType_e &getVolumeType() const { return std::get<0>(values_); }
    	inline void setVolumeType(const am_VolumeType_e &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: Either source ID or sink ID.
    	 */
    	inline const am_DataType_u &getVolumeID() const { return std::get<1>(values_); }
    	inline void setVolumeID(const am_DataType_u &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: The volume.
    	 */
    	inline const am_volume_t &getVolume() const { return std::get<2>(values_); }
    	inline void setVolume(const am_volume_t &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: The ramp that shall be driven.
    	 */
    	inline const am_RampType_pe &getRamp() const { return std::get<3>(values_); }
    	inline void setRamp(const am_RampType_pe &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: The time for the ramp.
    	 */
    	inline const am_time_t &getTime() const { return std::get<4>(values_); }
    	inline void setTime(const am_time_t &_value) { std::get<4>(values_) = _value; }
    	inline bool operator==(const am_Volumes_s& _other) const {
                return (getVolumeType() == _other.getVolumeType() && getVolumeID() == _other.getVolumeID() && getVolume() == _other.getVolume() && getRamp() == _other.getRamp() && getTime() == _other.getTime());
        }
    	inline bool operator!=(const am_Volumes_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    typedef std::vector<am_t::am_Volumes_s> am_Volumes_L;
    /**
     * description: This project specific value classifies the format in which data is exchanged
     *   within a connection.
     */
    typedef uint16_t am_ConnectionFormat_pe;
    typedef std::vector<am_t::am_ConnectionFormat_pe> am_ConnectionFormat_L;
    typedef std::vector<bool> am_Convertion_L;
    /**
     * description: A domain ID.
     */
    typedef uint16_t am_domainID_t;
    /**
     * description: A gateway ID.
     */
    typedef uint16_t am_gatewayID_t;
    /**
     * description: A converter ID.
     */
    typedef uint16_t am_converterID_t;
    /**
     * description: A crossfader ID.
     */
    typedef uint16_t am_crossfaderID_t;
    /**
     * description: Speed.
     */
    typedef uint16_t am_speed_t;
    /**
     * description: Here are all sound properties that can be set via the CommandInterface. Product
     *   specific.
     */
    typedef uint16_t am_MainSoundPropertyType_pe;
    
    struct am_HotSink_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            HS_UNKNOWN = 0,
            HS_SINKA = 1,
            HS_SINKB = 2,
            HS_INTERMEDIATE = 3,
            HS_MAX = 4
        };
        
        am_HotSink_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::HS_UNKNOWN)) {}
        am_HotSink_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::HS_UNKNOWN):
                case static_cast<int32_t>(Literal::HS_SINKA):
                case static_cast<int32_t>(Literal::HS_SINKB):
                case static_cast<int32_t>(Literal::HS_INTERMEDIATE):
                case static_cast<int32_t>(Literal::HS_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_HotSink_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_HotSink_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_HotSink_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_HotSink_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_HotSink_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_HotSink_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: This struct describes the attributes of a crossfader.
     */
    struct am_Crossfader_s : CommonAPI::Struct<am_crossfaderID_t, std::string, am_sinkID_t, am_sinkID_t, am_sourceID_t, am_HotSink_e> {
    	
    	am_Crossfader_s() {
    	}
    	am_Crossfader_s(const am_crossfaderID_t &_crossfaderID, const std::string &_name, const am_sinkID_t &_sinkIDA, const am_sinkID_t &_sinkIDB, const am_sourceID_t &_sourceID, const am_HotSink_e &_hotSink)
    	{
    		std::get<0>(values_) = _crossfaderID;
    		std::get<1>(values_) = _name;
    		std::get<2>(values_) = _sinkIDA;
    		std::get<3>(values_) = _sinkIDB;
    		std::get<4>(values_) = _sourceID;
    		std::get<5>(values_) = _hotSink;
    	}
    	/**
    	 * description: This is the ID of the crossfader, it is unique in the system. There are 2 ways,
    	 *   ID can be created: either it is assigned during the registration process (in a
    	 *   dynamic context, uniqueness will be ensured by the AudioManager daemon), or it
    	 *   is a fixed (the project has to ensure the uniqueness of the ID).
    	 */
    	inline const am_crossfaderID_t &getCrossfaderID() const { return std::get<0>(values_); }
    	inline void setCrossfaderID(const am_crossfaderID_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The name of the crossfader. Must be unique in the whole system.
    	 */
    	inline const std::string &getName() const { return std::get<1>(values_); }
    	inline void setName(const std::string &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: The sink ID of the sink A. Sinks shall be registered before registering the
    	 *   crossfader.
    	 */
    	inline const am_sinkID_t &getSinkIDA() const { return std::get<2>(values_); }
    	inline void setSinkIDA(const am_sinkID_t &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: The sink ID of the sink B. Sinks shall be registered before registering the
    	 *   crossfader.
    	 */
    	inline const am_sinkID_t &getSinkIDB() const { return std::get<3>(values_); }
    	inline void setSinkIDB(const am_sinkID_t &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: The source ID of the crossfader source. The source shall be registered before
    	 *   the crossfader.
    	 */
    	inline const am_sourceID_t &getSourceID() const { return std::get<4>(values_); }
    	inline void setSourceID(const am_sourceID_t &_value) { std::get<4>(values_) = _value; }
    	/**
    	 * description: This enum can have 3 states:
    	    HS_SINKA sink A is the current hot one, sink B
    	 *   is not audible
    	    HS_SINKB sink B is the current hot one, sink B is not
    	 *   audible
    	    HS_INTERMEDIATE the fader is stuck in between a cross-fading
    	 *   action. This could be due to an abort or an error. Before using the
    	 *   crossfader, it must be set to either HS_SINKA or HS_SINKB.
    	 */
    	inline const am_HotSink_e &getHotSink() const { return std::get<5>(values_); }
    	inline void setHotSink(const am_HotSink_e &_value) { std::get<5>(values_) = _value; }
    	inline bool operator==(const am_Crossfader_s& _other) const {
                return (getCrossfaderID() == _other.getCrossfaderID() && getName() == _other.getName() && getSinkIDA() == _other.getSinkIDA() && getSinkIDB() == _other.getSinkIDB() && getSourceID() == _other.getSourceID() && getHotSink() == _other.getHotSink());
        }
    	inline bool operator!=(const am_Crossfader_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: This struct describes the attributes of a gateway.
     */
    struct am_Gateway_s : CommonAPI::Struct<am_gatewayID_t, std::string, am_sinkID_t, am_sourceID_t, am_domainID_t, am_domainID_t, am_domainID_t, am_ConnectionFormat_L, am_ConnectionFormat_L, am_Convertion_L> {
    	
    	am_Gateway_s() {
    	}
    	am_Gateway_s(const am_gatewayID_t &_gatewayID, const std::string &_name, const am_sinkID_t &_sinkID, const am_sourceID_t &_sourceID, const am_domainID_t &_domainSinkID, const am_domainID_t &_domainSourceID, const am_domainID_t &_controlDomainID, const am_ConnectionFormat_L &_listSourceFormats, const am_ConnectionFormat_L &_listSinkFormats, const am_Convertion_L &_convertionMatrix)
    	{
    		std::get<0>(values_) = _gatewayID;
    		std::get<1>(values_) = _name;
    		std::get<2>(values_) = _sinkID;
    		std::get<3>(values_) = _sourceID;
    		std::get<4>(values_) = _domainSinkID;
    		std::get<5>(values_) = _domainSourceID;
    		std::get<6>(values_) = _controlDomainID;
    		std::get<7>(values_) = _listSourceFormats;
    		std::get<8>(values_) = _listSinkFormats;
    		std::get<9>(values_) = _convertionMatrix;
    	}
    	/**
    	 * description: This is the ID of the gateway, it is unique in the system. There are 2 ways, ID
    	 *   can be created: either it is assigned during the registration process (in a
    	 *   dynamic context, uniqueness will be ensured by the AudioManagerDaemon), or it
    	 *   is a fixed (the project has to ensure the uniqueness of the ID).
    	 */
    	inline const am_gatewayID_t &getGatewayID() const { return std::get<0>(values_); }
    	inline void setGatewayID(const am_gatewayID_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The name of the gateway. Must be unique in the whole system.
    	 */
    	inline const std::string &getName() const { return std::get<1>(values_); }
    	inline void setName(const std::string &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: The sinkID of the gateway sink-end. The sink is a full blown sink with
    	 *   connectionFormats, sinkClassIDs etc... It makes sense to register the sinks of
    	 *   a gateway as non-visible. Care needs to be taken that the connectionsFormats
    	 *   match with the ones in the conversionMatrix. If the sink is located in the
    	 *   controllingDomain, the ID needs to be retrieved by registering the sink before
    	 *   registering the gateway. In case the sink is in a different domain, the ID
    	 *   needs to be retrieved via peeking.
    	 */
    	inline const am_sinkID_t &getSinkID() const { return std::get<2>(values_); }
    	inline void setSinkID(const am_sinkID_t &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: The sourceID of the gateway sink-end. The sink is a full blown source with
    	 *   connectionFormats, sinkClassIDs etc... It makes sense to register the sources
    	 *   of a gateway as non-visible. Care needs to be taken that the
    	 *   connectionsFormats match with the ones in the conversionMatrix. If the source
    	 *   is located in the controllingDomain, the ID needs to be retrieved by
    	 *   registering the source before registering the gateway. In case the source is
    	 *   in a different domain, the ID needs to be retrieved via peeking.
    	 */
    	inline const am_sourceID_t &getSourceID() const { return std::get<3>(values_); }
    	inline void setSourceID(const am_sourceID_t &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: The ID of the sink. If the domain is the same like the controlling domain, the
    	 *   ID is known due to registration. If the domain is different, the ID needs to
    	 *   be retrieved via peeking.
    	 */
    	inline const am_domainID_t &getDomainSinkID() const { return std::get<4>(values_); }
    	inline void setDomainSinkID(const am_domainID_t &_value) { std::get<4>(values_) = _value; }
    	/**
    	 * description: The ID of the source. If the domain is the same like the controlling domain,
    	 *   the ID is known due to registration. If the domain is different, the ID needs
    	 *   to be retrieved via peeking.
    	 */
    	inline const am_domainID_t &getDomainSourceID() const { return std::get<5>(values_); }
    	inline void setDomainSourceID(const am_domainID_t &_value) { std::get<5>(values_) = _value; }
    	/**
    	 * description: This is the ID of the domain that registers the gateway.
    	 */
    	inline const am_domainID_t &getControlDomainID() const { return std::get<6>(values_); }
    	inline void setControlDomainID(const am_domainID_t &_value) { std::get<6>(values_) = _value; }
    	/**
    	 * description: This is the list of available formats on the source side of the gateway. It is
    	 *   not defined during the gateway registration but copied from the source
    	 *   registration.
    	 */
    	inline const am_ConnectionFormat_L &getListSourceFormats() const { return std::get<7>(values_); }
    	inline void setListSourceFormats(const am_ConnectionFormat_L &_value) { std::get<7>(values_) = _value; }
    	/**
    	 * description: This is the list of available formats on the sink side of the gateway. It is
    	 *   not defined during the gateway registration but copied from the sink
    	 *   registration.
    	 */
    	inline const am_ConnectionFormat_L &getListSinkFormats() const { return std::get<8>(values_); }
    	inline void setListSinkFormats(const am_ConnectionFormat_L &_value) { std::get<8>(values_) = _value; }
    	/**
    	 * description: This is matrix holding information about the conversion capability of the
    	 *   gateway, it's length is defined by the length(listSinkFormats) x
    	 *   length(listSourceFormats).
    	If a SinkFormat can be converted into a
    	 *   SourceFormat, the vector will hold a 1, if no conversion is possible, a 0.
    	The
    	 *   data is stored row orientated, where the rows are related to the sinksFormats
    	 *   and the columns to the sourceFormats. The first value will hold the conversion
    	 *   information from the first sourceFormat to the first sinkFormat for example
    	 *   and the seventh value the information about the 3rd sinkFormat to the 1st
    	 *   sourceFormat in case we would have 3 sourceFormats.
    	 */
    	inline const am_Convertion_L &getConvertionMatrix() const { return std::get<9>(values_); }
    	inline void setConvertionMatrix(const am_Convertion_L &_value) { std::get<9>(values_) = _value; }
    	inline bool operator==(const am_Gateway_s& _other) const {
                return (getGatewayID() == _other.getGatewayID() && getName() == _other.getName() && getSinkID() == _other.getSinkID() && getSourceID() == _other.getSourceID() && getDomainSinkID() == _other.getDomainSinkID() && getDomainSourceID() == _other.getDomainSourceID() && getControlDomainID() == _other.getControlDomainID() && getListSourceFormats() == _other.getListSourceFormats() && getListSinkFormats() == _other.getListSinkFormats() && getConvertionMatrix() == _other.getConvertionMatrix());
        }
    	inline bool operator!=(const am_Gateway_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    
    struct am_Handle_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            H_UNKNOWN = 0,
            H_CONNECT = 1,
            H_DISCONNECT = 2,
            H_SETSOURCESTATE = 3,
            H_SETSINKVOLUME = 4,
            H_SETSOURCEVOLUME = 5,
            H_SETSINKSOUNDPROPERTY = 6,
            H_SETSOURCESOUNDPROPERTY = 7,
            H_SETSINKSOUNDPROPERTIES = 8,
            H_SETSOURCESOUNDPROPERTIES = 9,
            H_CROSSFADE = 10,
            H_SETVOLUMES = 11,
            H_SETSINKNOTIFICATION = 12,
            H_SETSOURCENOTIFICATION = 13,
            H_MAX = 14
        };
        
        am_Handle_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::H_UNKNOWN)) {}
        am_Handle_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::H_UNKNOWN):
                case static_cast<int32_t>(Literal::H_CONNECT):
                case static_cast<int32_t>(Literal::H_DISCONNECT):
                case static_cast<int32_t>(Literal::H_SETSOURCESTATE):
                case static_cast<int32_t>(Literal::H_SETSINKVOLUME):
                case static_cast<int32_t>(Literal::H_SETSOURCEVOLUME):
                case static_cast<int32_t>(Literal::H_SETSINKSOUNDPROPERTY):
                case static_cast<int32_t>(Literal::H_SETSOURCESOUNDPROPERTY):
                case static_cast<int32_t>(Literal::H_SETSINKSOUNDPROPERTIES):
                case static_cast<int32_t>(Literal::H_SETSOURCESOUNDPROPERTIES):
                case static_cast<int32_t>(Literal::H_CROSSFADE):
                case static_cast<int32_t>(Literal::H_SETVOLUMES):
                case static_cast<int32_t>(Literal::H_SETSINKNOTIFICATION):
                case static_cast<int32_t>(Literal::H_SETSOURCENOTIFICATION):
                case static_cast<int32_t>(Literal::H_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_Handle_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_Handle_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_Handle_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_Handle_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_Handle_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_Handle_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: A handle is used for asynchronous operations and is uniquely assigned for each
     *   of this operations.
     */
    struct am_Handle_s : CommonAPI::Struct<am_Handle_e, uint16_t> {
    	
    	am_Handle_s() {
    	}
    	am_Handle_s(const am_Handle_e &_handleType, const uint16_t &_handle)
    	{
    		std::get<0>(values_) = _handleType;
    		std::get<1>(values_) = _handle;
    	}
    	/**
    	 * description: The handle type.
    	 */
    	inline const am_Handle_e &getHandleType() const { return std::get<0>(values_); }
    	inline void setHandleType(const am_Handle_e &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The handle as value.
    	 */
    	inline const uint16_t &getHandle() const { return std::get<1>(values_); }
    	inline void setHandle(const uint16_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const am_Handle_s& _other) const {
                return (getHandleType() == _other.getHandleType() && getHandle() == _other.getHandle());
        }
    	inline bool operator!=(const am_Handle_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: This struct holds the payload of a notification.
     */
    struct am_NotificationPayload_s : CommonAPI::Struct<am_NotificationType_pe, int16_t> {
    	
    	am_NotificationPayload_s() {
    	}
    	am_NotificationPayload_s(const am_NotificationType_pe &_type, const int16_t &_value)
    	{
    		std::get<0>(values_) = _type;
    		std::get<1>(values_) = _value;
    	}
    	/**
    	 * description: This defines the notification type.
    	 */
    	inline const am_NotificationType_pe &getType() const { return std::get<0>(values_); }
    	inline void setType(const am_NotificationType_pe &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: This is the value of the notification. It's meaning depends on the notification
    	 *   type.
    	 */
    	inline const int16_t &getValue() const { return std::get<1>(values_); }
    	inline void setValue(const int16_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const am_NotificationPayload_s& _other) const {
                return (getType() == _other.getType() && getValue() == _other.getValue());
        }
    	inline bool operator!=(const am_NotificationPayload_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: This struct describes the attributes of a sink.
     */
    struct am_Sink_s : CommonAPI::Struct<am_sinkID_t, std::string, am_domainID_t, am_sinkClass_t, am_volume_t, bool, am_Availability_s, am_MuteState_e, am_mainVolume_t, am_SoundProperty_L, am_ConnectionFormat_L, am_MainSoundProperty_L, am_NotificationConfiguration_L, am_NotificationConfiguration_L> {
    	
    	am_Sink_s() {
    		std::get<5>(values_) = false;
    	}
    	am_Sink_s(const am_sinkID_t &_sinkID, const std::string &_name, const am_domainID_t &_domainID, const am_sinkClass_t &_sinkClassID, const am_volume_t &_volume, const bool &_visible, const am_Availability_s &_available, const am_MuteState_e &_muteState, const am_mainVolume_t &_mainVolume, const am_SoundProperty_L &_listSoundProperties, const am_ConnectionFormat_L &_listConnectionFormats, const am_MainSoundProperty_L &_listMainSoundProperties, const am_NotificationConfiguration_L &_listMainNotificationConfigurations, const am_NotificationConfiguration_L &_listNotificationConfigurations)
    	{
    		std::get<0>(values_) = _sinkID;
    		std::get<1>(values_) = _name;
    		std::get<2>(values_) = _domainID;
    		std::get<3>(values_) = _sinkClassID;
    		std::get<4>(values_) = _volume;
    		std::get<5>(values_) = _visible;
    		std::get<6>(values_) = _available;
    		std::get<7>(values_) = _muteState;
    		std::get<8>(values_) = _mainVolume;
    		std::get<9>(values_) = _listSoundProperties;
    		std::get<10>(values_) = _listConnectionFormats;
    		std::get<11>(values_) = _listMainSoundProperties;
    		std::get<12>(values_) = _listMainNotificationConfigurations;
    		std::get<13>(values_) = _listNotificationConfigurations;
    	}
    	/**
    	 * description: This is the ID of the sink, it is unique in the system. we have list all the
    	 *   sourceID enumeration in am_sinkID_e..
    	 */
    	inline const am_sinkID_t &getSinkID() const { return std::get<0>(values_); }
    	inline void setSinkID(const am_sinkID_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The name of the sink. Must be unique in the whole system.
    	 */
    	inline const std::string &getName() const { return std::get<1>(values_); }
    	inline void setName(const std::string &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: The domain ID is the domain the sink belongs to. A sink can only be in one
    	 *   domain. domainID only can be getten by registerDomain.
    	 */
    	inline const am_domainID_t &getDomainID() const { return std::get<2>(values_); }
    	inline void setDomainID(const am_domainID_t &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: The sink class ID references to a sink class. With the help of classification,
    	 *   rules can be setup to define the system behavior.
    	 */
    	inline const am_sinkClass_t &getSinkClassID() const { return std::get<3>(values_); }
    	inline void setSinkClassID(const am_sinkClass_t &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: This is the volume of the sink. It is set by the AudioManagerController.
    	 */
    	inline const am_volume_t &getVolume() const { return std::get<4>(values_); }
    	inline void setVolume(const am_volume_t &_value) { std::get<4>(values_) = _value; }
    	/**
    	 * description: This Boolean flag indicates whether a sink is visible to the commandInterface
    	 *   or not. If the User must have the possibility to choose the source in the HMI,
    	 *   it must be visible. But there are also good reasons for invisible sinks, for
    	 *   example if the sink is part of a crossfader or gateway. HMI relevant changes
    	 *   in visible sinks will be automatically reported by the daemon to the
    	 *   commandInterface.
    	 */
    	inline const bool &getVisible() const { return std::get<5>(values_); }
    	inline void setVisible(const bool _value) { std::get<5>(values_) = _value; }
    	/**
    	 * description: This attribute reflects the availability of the sink. There are several reasons
    	 *   why a sink could be not available for the moment: for example the shutdown of
    	 *   a sink because of overtemperature or over- &amp; undervoltage. The
    	 *   availability consists of two pieces of information:
    	    Availablility: the
    	 *   status itself, can be A_AVAILABLE, A_UNAVAILABLE or A_UNKNOWN
    	   
    	 *   AvailabilityReason: this informs about the last reason for a change in
    	 *   availability. The reasons itself are product specific.
    	 */
    	inline const am_Availability_s &getAvailable() const { return std::get<6>(values_); }
    	inline void setAvailable(const am_Availability_s &_value) { std::get<6>(values_) = _value; }
    	/**
    	 * description: This attribute reflects the mute state of the sink. The information is not the
    	 *   "real" state of the sink, but the HMI representation for he commandInterface
    	 *   controlled by the AudioManagerController.
    	 */
    	inline const am_MuteState_e &getMuteState() const { return std::get<7>(values_); }
    	inline void setMuteState(const am_MuteState_e &_value) { std::get<7>(values_) = _value; }
    	/**
    	 * description: This is the representation of the Volume for the commandInterface. It is used
    	 *   by the HMI to set the volume of a sink, the AudioManagerController has to
    	 *   transform this into real source and sink volumes.
    	 */
    	inline const am_mainVolume_t &getMainVolume() const { return std::get<8>(values_); }
    	inline void setMainVolume(const am_mainVolume_t &_value) { std::get<8>(values_) = _value; }
    	/**
    	 * description: This is the list of sound properties, that the sink is capable of. The sound
    	 *   properties itself are project specific. For sinks, a possible sound property
    	 *   could be for example settings.
    	 */
    	inline const am_SoundProperty_L &getListSoundProperties() const { return std::get<9>(values_); }
    	inline void setListSoundProperties(const am_SoundProperty_L &_value) { std::get<9>(values_) = _value; }
    	/**
    	 * description: This list holds information about the formats that the Source is capable of
    	 *   supporting when delivering audio.
    	 */
    	inline const am_ConnectionFormat_L &getListConnectionFormats() const { return std::get<10>(values_); }
    	inline void setListConnectionFormats(const am_ConnectionFormat_L &_value) { std::get<10>(values_) = _value; }
    	/**
    	 * description: This is the list of the available mainsound properties. The principle is the
    	 *   same than with sound properties, but they are only visible to the
    	 *   CommandInterface.
    	 */
    	inline const am_MainSoundProperty_L &getListMainSoundProperties() const { return std::get<11>(values_); }
    	inline void setListMainSoundProperties(const am_MainSoundProperty_L &_value) { std::get<11>(values_) = _value; }
    	/**
    	 * description: This is the list of the MainNotificationConfigurations. These notifications
    	 *   work on the level of command interface.
    	 */
    	inline const am_NotificationConfiguration_L &getListMainNotificationConfigurations() const { return std::get<12>(values_); }
    	inline void setListMainNotificationConfigurations(const am_NotificationConfiguration_L &_value) { std::get<12>(values_) = _value; }
    	/**
    	 * description: This is the list of the NotificationConfigurations. These notifications work on
    	 *   the level of RoutingPlugins.
    	 */
    	inline const am_NotificationConfiguration_L &getListNotificationConfigurations() const { return std::get<13>(values_); }
    	inline void setListNotificationConfigurations(const am_NotificationConfiguration_L &_value) { std::get<13>(values_) = _value; }
    	inline bool operator==(const am_Sink_s& _other) const {
                return (getSinkID() == _other.getSinkID() && getName() == _other.getName() && getDomainID() == _other.getDomainID() && getSinkClassID() == _other.getSinkClassID() && getVolume() == _other.getVolume() && getVisible() == _other.getVisible() && getAvailable() == _other.getAvailable() && getMuteState() == _other.getMuteState() && getMainVolume() == _other.getMainVolume() && getListSoundProperties() == _other.getListSoundProperties() && getListConnectionFormats() == _other.getListConnectionFormats() && getListMainSoundProperties() == _other.getListMainSoundProperties() && getListMainNotificationConfigurations() == _other.getListMainNotificationConfigurations() && getListNotificationConfigurations() == _other.getListNotificationConfigurations());
        }
    	inline bool operator!=(const am_Sink_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    
    struct am_InterruptState_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            IS_UNKNOWN = 0,
            IS_OFF = 1,
            IS_INTERRUPTED = 2,
            IS_MAX = 3
        };
        
        am_InterruptState_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::IS_UNKNOWN)) {}
        am_InterruptState_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::IS_UNKNOWN):
                case static_cast<int32_t>(Literal::IS_OFF):
                case static_cast<int32_t>(Literal::IS_INTERRUPTED):
                case static_cast<int32_t>(Literal::IS_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_InterruptState_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_InterruptState_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_InterruptState_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_InterruptState_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_InterruptState_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_InterruptState_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct am_SourceState_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            SS_UNKNNOWN = 0,
            SS_ON = 1,
            SS_OFF = 2,
            SS_PAUSED = 3,
            SS_MAX = 4
        };
        
        am_SourceState_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::SS_UNKNNOWN)) {}
        am_SourceState_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::SS_UNKNNOWN):
                case static_cast<int32_t>(Literal::SS_ON):
                case static_cast<int32_t>(Literal::SS_OFF):
                case static_cast<int32_t>(Literal::SS_PAUSED):
                case static_cast<int32_t>(Literal::SS_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_SourceState_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_SourceState_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_SourceState_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_SourceState_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_SourceState_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_SourceState_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: This struct describes the attributes of a source.
     */
    struct am_Source_s : CommonAPI::Struct<am_sourceID_t, am_domainID_t, std::string, am_sourceClass_t, am_SourceState_e, am_volume_t, bool, am_Availability_s, am_InterruptState_e, am_SoundProperty_L, am_ConnectionFormat_L, am_MainSoundProperty_L, am_NotificationConfiguration_L, am_NotificationConfiguration_L> {
    	
    	am_Source_s() {
    		std::get<6>(values_) = false;
    	}
    	am_Source_s(const am_sourceID_t &_sourceID, const am_domainID_t &_domainID, const std::string &_name, const am_sourceClass_t &_sourceClassID, const am_SourceState_e &_sourceState, const am_volume_t &_volume, const bool &_visible, const am_Availability_s &_available, const am_InterruptState_e &_interruptState, const am_SoundProperty_L &_listSoundProperties, const am_ConnectionFormat_L &_listConnectionFormats, const am_MainSoundProperty_L &_listMainSoundProperties, const am_NotificationConfiguration_L &_listMainNotificationConfigurations, const am_NotificationConfiguration_L &_listNotificationConfigurations)
    	{
    		std::get<0>(values_) = _sourceID;
    		std::get<1>(values_) = _domainID;
    		std::get<2>(values_) = _name;
    		std::get<3>(values_) = _sourceClassID;
    		std::get<4>(values_) = _sourceState;
    		std::get<5>(values_) = _volume;
    		std::get<6>(values_) = _visible;
    		std::get<7>(values_) = _available;
    		std::get<8>(values_) = _interruptState;
    		std::get<9>(values_) = _listSoundProperties;
    		std::get<10>(values_) = _listConnectionFormats;
    		std::get<11>(values_) = _listMainSoundProperties;
    		std::get<12>(values_) = _listMainNotificationConfigurations;
    		std::get<13>(values_) = _listNotificationConfigurations;
    	}
    	/**
    	 * description: This is the ID of the source, it is unique in the system. we have listed all
    	 *   the sourceID in below am_sourceID_e.
    	 */
    	inline const am_sourceID_t &getSourceID() const { return std::get<0>(values_); }
    	inline void setSourceID(const am_sourceID_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The domain ID is the domain the source belongs to. A source can only be in one
    	 *   domain. domainID only can be getten by registerDomain.
    	 */
    	inline const am_domainID_t &getDomainID() const { return std::get<1>(values_); }
    	inline void setDomainID(const am_domainID_t &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: The name of the source. Must be unique in the whole system.
    	 */
    	inline const std::string &getName() const { return std::get<2>(values_); }
    	inline void setName(const std::string &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: The source class ID, indicates the class the source is in. the attribute is not
    	 *   used now.
    	 */
    	inline const am_sourceClass_t &getSourceClassID() const { return std::get<3>(values_); }
    	inline void setSourceClassID(const am_sourceClass_t &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: The source state is an indication towards the source if it is actively heard or
    	 *   not. The source can use this information to implement features like automatic
    	 *   spin down of CD's in case the CD is not the active source or AF following of a
    	 *   tuner that is not actively heard. The source state is set by the
    	 *   AudioManagerController.There are 3 possible states:
    	    SS_ON: the source is
    	 *   active
    	    SS_OFF: the source is off
    	    SS_PAUSED: the source is paused and
    	 *   not active.
    	 */
    	inline const am_SourceState_e &getSourceState() const { return std::get<4>(values_); }
    	inline void setSourceState(const am_SourceState_e &_value) { std::get<4>(values_) = _value; }
    	/**
    	 * description: This is the volume of the source. It is set by the AudioManagerController. It
    	 *   is used to adopt different audio levels in a system and mixing of sources
    	 *   (e.g. navigation hints &amp; music).
    	 */
    	inline const am_volume_t &getVolume() const { return std::get<5>(values_); }
    	inline void setVolume(const am_volume_t &_value) { std::get<5>(values_) = _value; }
    	/**
    	 * description: This Boolean flag indicates whether a source is visible to the commandInterface
    	 *   or not. If the User must have the possibility to choose the source in the HMI,
    	 *   it must be visible. But there are also good reasons for invisible sources, for
    	 *   example if the source is part of a crossfader or gateway. HMI relevant changes
    	 *   in visible sources will be automatically reported by the daemon to the
    	 *   commandInterface.
    	 */
    	inline const bool &getVisible() const { return std::get<6>(values_); }
    	inline void setVisible(const bool _value) { std::get<6>(values_) = _value; }
    	/**
    	 * description: This attribute reflects the availability of the source. There are several
    	 *   reasons why a source could be not available for the moment. For example a CD
    	 *   player which has no CD entered in the slot can be unavailable, or a USB player
    	 *   with no or unreadable stick attached. Other scenarios involve the shutdown of
    	 *   a source because of overtemperature or over- &amp; undervoltage. The
    	 *   availability consists of two information:
    	    Availablility: the status
    	 *   itself, can be A_AVAILABLE, A_UNAVAILABLE or A_UNKNOWN
    	    AvailabilityReason:
    	 *   this informs about the last reason for a change in availability. The reasons
    	 *   itself are product specific.
    	 */
    	inline const am_Availability_s &getAvailable() const { return std::get<7>(values_); }
    	inline void setAvailable(const am_Availability_s &_value) { std::get<7>(values_) = _value; }
    	/**
    	 * description: Some special sources can have special behaviors, the are so called "Low Level
    	 *   Interrupts". Here the current status is documented. The information can be
    	 *   used by the AudioManagerController to react to the changes by for example
    	 *   lowering the volume of the main sources. The two states are
    	    IS_OFF: the
    	 *   interrupt is not active at the moment
    	    IS_INTERRUPTED: the interrupt is
    	 *   playing at the moment.
    	 */
    	inline const am_InterruptState_e &getInterruptState() const { return std::get<8>(values_); }
    	inline void setInterruptState(const am_InterruptState_e &_value) { std::get<8>(values_) = _value; }
    	/**
    	 * description: This is the list of sound properties, that the source is capable of. The sound
    	 *   properties itself are project specific. For sources, a possible sound property
    	 *   could be navigation volume offset, for example.
    	                           for
    	 *   method registerSource, this params is option.
    	 */
    	inline const am_SoundProperty_L &getListSoundProperties() const { return std::get<9>(values_); }
    	inline void setListSoundProperties(const am_SoundProperty_L &_value) { std::get<9>(values_) = _value; }
    	/**
    	 * description: This list holds information about the formats that the Source is capable of
    	 *   supporting when delivering audio.
    	 */
    	inline const am_ConnectionFormat_L &getListConnectionFormats() const { return std::get<10>(values_); }
    	inline void setListConnectionFormats(const am_ConnectionFormat_L &_value) { std::get<10>(values_) = _value; }
    	/**
    	 * description: This is the list of the available main sound properties. The principle is the
    	 *   same than with sound properties, but they are only visible to the
    	 *   CommandInterface.
    	                           for method registerSource, this
    	 *   params is option.
    	 */
    	inline const am_MainSoundProperty_L &getListMainSoundProperties() const { return std::get<11>(values_); }
    	inline void setListMainSoundProperties(const am_MainSoundProperty_L &_value) { std::get<11>(values_) = _value; }
    	/**
    	 * description: The list of MainNotificationConfigurations. These notifications work on the
    	 *   level of CommandInterface.
    	                           for method
    	 *   registerSource, this params is option.
    	 */
    	inline const am_NotificationConfiguration_L &getListMainNotificationConfigurations() const { return std::get<12>(values_); }
    	inline void setListMainNotificationConfigurations(const am_NotificationConfiguration_L &_value) { std::get<12>(values_) = _value; }
    	/**
    	 * description: The list of MainNotificationConfigurations. These notifications work on the
    	 *   level of RoutingInterface.
    	                           for method
    	 *   registerSource, this params is option.
    	 */
    	inline const am_NotificationConfiguration_L &getListNotificationConfigurations() const { return std::get<13>(values_); }
    	inline void setListNotificationConfigurations(const am_NotificationConfiguration_L &_value) { std::get<13>(values_) = _value; }
    	inline bool operator==(const am_Source_s& _other) const {
                return (getSourceID() == _other.getSourceID() && getDomainID() == _other.getDomainID() && getName() == _other.getName() && getSourceClassID() == _other.getSourceClassID() && getSourceState() == _other.getSourceState() && getVolume() == _other.getVolume() && getVisible() == _other.getVisible() && getAvailable() == _other.getAvailable() && getInterruptState() == _other.getInterruptState() && getListSoundProperties() == _other.getListSoundProperties() && getListConnectionFormats() == _other.getListConnectionFormats() && getListMainSoundProperties() == _other.getListMainSoundProperties() && getListMainNotificationConfigurations() == _other.getListMainNotificationConfigurations() && getListNotificationConfigurations() == _other.getListNotificationConfigurations());
        }
    	inline bool operator!=(const am_Source_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    
    struct am_DomainState_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            DS_UNKNOWN = 0,
            DS_CONTROLLED = 1,
            DS_INDEPENDENT_STARTUP = 2,
            DS_INDEPENDENT_RUNDOWN = 3,
            DS_MAX = 4
        };
        
        am_DomainState_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::DS_UNKNOWN)) {}
        am_DomainState_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::DS_UNKNOWN):
                case static_cast<int32_t>(Literal::DS_CONTROLLED):
                case static_cast<int32_t>(Literal::DS_INDEPENDENT_STARTUP):
                case static_cast<int32_t>(Literal::DS_INDEPENDENT_RUNDOWN):
                case static_cast<int32_t>(Literal::DS_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_DomainState_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_DomainState_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_DomainState_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_DomainState_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_DomainState_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_DomainState_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: This struct describes the attributes of a domain.
     */
    struct am_Domain_s : CommonAPI::Struct<am_domainID_t, std::string, std::string, std::string, bool, bool, am_DomainState_e> {
    	
    	am_Domain_s() {
    		std::get<4>(values_) = false;
    		std::get<5>(values_) = false;
    	}
    	am_Domain_s(const am_domainID_t &_domainID, const std::string &_name, const std::string &_busname, const std::string &_nodename, const bool &_early, const bool &_complete, const am_DomainState_e &_state)
    	{
    		std::get<0>(values_) = _domainID;
    		std::get<1>(values_) = _name;
    		std::get<2>(values_) = _busname;
    		std::get<3>(values_) = _nodename;
    		std::get<4>(values_) = _early;
    		std::get<5>(values_) = _complete;
    		std::get<6>(values_) = _state;
    	}
    	/**
    	 * description: The domain ID.it is unique in the system. it is assigned during the
    	 *   registration process (in a dynamic context, uniqueness will be ensured by the
    	 *   AudioManagerDaemon).
    	 */
    	inline const am_domainID_t &getDomainID() const { return std::get<0>(values_); }
    	inline void setDomainID(const am_domainID_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The name of the domain.
    	 */
    	inline const std::string &getName() const { return std::get<1>(values_); }
    	inline void setName(const std::string &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: The busname. it is assigned by the routingPlugin during the registration
    	 *   process. the user don't need to care about it.
    	 */
    	inline const std::string &getBusname() const { return std::get<2>(values_); }
    	inline void setBusname(const std::string &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: The name of the node.
    	 */
    	inline const std::string &getNodename() const { return std::get<3>(values_); }
    	inline void setNodename(const std::string &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: Indicates if the domain is independent of audioManager at startup or not.
    	 */
    	inline const bool &getEarly() const { return std::get<4>(values_); }
    	inline void setEarly(const bool _value) { std::get<4>(values_) = _value; }
    	/**
    	 * description: Indicates if the domain registration is complete or not.
    	 */
    	inline const bool &getComplete() const { return std::get<5>(values_); }
    	inline void setComplete(const bool _value) { std::get<5>(values_) = _value; }
    	/**
    	 * description: The current domain state.
    	 */
    	inline const am_DomainState_e &getState() const { return std::get<6>(values_); }
    	inline void setState(const am_DomainState_e &_value) { std::get<6>(values_) = _value; }
    	inline bool operator==(const am_Domain_s& _other) const {
                return (getDomainID() == _other.getDomainID() && getName() == _other.getName() && getBusname() == _other.getBusname() && getNodename() == _other.getNodename() && getEarly() == _other.getEarly() && getComplete() == _other.getComplete() && getState() == _other.getState());
        }
    	inline bool operator!=(const am_Domain_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: This struct describes the attributes of a converter.
     */
    struct am_Converter_s : CommonAPI::Struct<am_converterID_t, std::string, am_sinkID_t, am_sourceID_t, am_domainID_t, am_ConnectionFormat_L, am_ConnectionFormat_L, am_Convertion_L> {
    	
    	am_Converter_s() {
    	}
    	am_Converter_s(const am_converterID_t &_converterID, const std::string &_name, const am_sinkID_t &_sinkID, const am_sourceID_t &_sourceID, const am_domainID_t &_domainID, const am_ConnectionFormat_L &_listSourceFormats, const am_ConnectionFormat_L &_listSinkFormats, const am_Convertion_L &_convertionMatrix)
    	{
    		std::get<0>(values_) = _converterID;
    		std::get<1>(values_) = _name;
    		std::get<2>(values_) = _sinkID;
    		std::get<3>(values_) = _sourceID;
    		std::get<4>(values_) = _domainID;
    		std::get<5>(values_) = _listSourceFormats;
    		std::get<6>(values_) = _listSinkFormats;
    		std::get<7>(values_) = _convertionMatrix;
    	}
    	/**
    	 * description: This is the ID of the converter, it is unique in the system. There are 2 ways,
    	 *   ID can be created: either it is assigned during the registration process (in a
    	 *   dynamic context, uniqueness will be ensured by the AudioManagerDaemon), or it
    	 *   is a fixed (the project has to ensure the uniqueness of the ID).
    	 */
    	inline const am_converterID_t &getConverterID() const { return std::get<0>(values_); }
    	inline void setConverterID(const am_converterID_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The name of the converter. Must be unique in the whole system.
    	 */
    	inline const std::string &getName() const { return std::get<1>(values_); }
    	inline void setName(const std::string &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: The sink ID of the converter sink-end. The sink is a full blown sink with
    	 *   connection formats, sink class IDs etc... It makes sense to register the sinks
    	 *   of a gateway as non-visible. Care needs to be taken that the connection
    	 *   formats match with the ones in the conversion matrix. If the sink is located
    	 *   in the controlling domain, the ID needs to be retrieved by registering the
    	 *   sink before registering the gateway. In case the sink is in a different
    	 *   domain, the ID needs to be retrieved via peeking.
    	 */
    	inline const am_sinkID_t &getSinkID() const { return std::get<2>(values_); }
    	inline void setSinkID(const am_sinkID_t &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: The source ID of the converter sink-end. The sink is a full blown source with
    	 *   connection formats, source class IDs etc... It makes sense to register the
    	 *   sources of a gateway as non-visible. Care needs to be taken that the
    	 *   connection formats match with the ones in the conversion matrix. If the source
    	 *   is located in the controlling domain, the ID needs to be retrieved by
    	 *   registering the source before registering the gateway. In case the source is
    	 *   in a different domain, the ID needs to be retrieved via peeking.
    	 */
    	inline const am_sourceID_t &getSourceID() const { return std::get<3>(values_); }
    	inline void setSourceID(const am_sourceID_t &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: This is the ID of the domain that registers the converter.
    	 */
    	inline const am_domainID_t &getDomainID() const { return std::get<4>(values_); }
    	inline void setDomainID(const am_domainID_t &_value) { std::get<4>(values_) = _value; }
    	/**
    	 * description: This is the list of available formats on the source side of the converter. It
    	 *   is not defined during the gateway registration but copied from the source
    	 *   registration.
    	 */
    	inline const am_ConnectionFormat_L &getListSourceFormats() const { return std::get<5>(values_); }
    	inline void setListSourceFormats(const am_ConnectionFormat_L &_value) { std::get<5>(values_) = _value; }
    	/**
    	 * description: This is the list of available formats on the sink side of the gateway. It is
    	 *   not defined during the converter registration but copied from the sink
    	 *   registration.
    	 */
    	inline const am_ConnectionFormat_L &getListSinkFormats() const { return std::get<6>(values_); }
    	inline void setListSinkFormats(const am_ConnectionFormat_L &_value) { std::get<6>(values_) = _value; }
    	/**
    	 * description: This is matrix holding information about the conversion capability of the
    	 *   converter, it's length is defined by the length(listSinkFormats) x
    	 *   length(listSourceFormats).
    	If a sink format can be converted into a source
    	 *   format, the vector will hold a 1, if no conversion is possible, a 0.
    	The data
    	 *   is stored row orientated, where the rows are related to the sink formats and
    	 *   the columns to the source formats. The first value will hold the conversion
    	 *   information from the first source format to the first sink format for example
    	 *   and the seventh value the information about the 3rd sink format to the 1st
    	 *   source format in case we would have 3 source formats.
    	 */
    	inline const am_Convertion_L &getConvertionMatrix() const { return std::get<7>(values_); }
    	inline void setConvertionMatrix(const am_Convertion_L &_value) { std::get<7>(values_) = _value; }
    	inline bool operator==(const am_Converter_s& _other) const {
                return (getConverterID() == _other.getConverterID() && getName() == _other.getName() && getSinkID() == _other.getSinkID() && getSourceID() == _other.getSourceID() && getDomainID() == _other.getDomainID() && getListSourceFormats() == _other.getListSourceFormats() && getListSinkFormats() == _other.getListSinkFormats() && getConvertionMatrix() == _other.getConvertionMatrix());
        }
    	inline bool operator!=(const am_Converter_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    
    struct am_sourceID_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            eSRC_UNKNOWN = 0,
            eSRC_SERVICE_CALL = 1,
            eSRC_VOICERECORDER = 2,
            eSRC_SDS = 3,
            eSRC_TTS = 4,
            eSRC_NAV = 5,
            eSRC_ETC_WARNING = 6,
            eSRC_ETC_INFO = 7,
            eSRC_TEL_HANDSFREE = 8,
            eSRC_TEL_RINGING = 9,
            eSRC_DIPO_PHONE = 10,
            eSRC_DIPO_PHONE_RINGING = 11,
            eSRC_DIPO_SIRI = 12,
            eSRC_DIPO_ALT = 13,
            eSRC_FU_TEL_HANDSFREE = 14,
            eSRC_FU_TEL_RINGING = 15,
            eSRC_GAL_VOICE = 16,
            eSRC_GAL_NAVI = 17,
            eSRC_GAL_UI = 18,
            eSRC_GAL_VR = 19,
            eSRC_IN_CAR_COM = 20,
            eSRC_UXI_INF = 21,
            eSRC_CARLIFE_NAVI = 22,
            eSRC_CARLIFE_VR = 23,
            eSRC_MIRRORLINK_VR = 24,
            eSRC_TBOX_ECALL = 25,
            eSRC_TBOX_ICALL = 26,
            eSRC_CHIME_CONFIRMATION = 27,
            eSRC_CHIME_INDICATION = 28,
            eSRC_CHIME_WARNING = 29,
            eSRC_CHIME_KEYPAD = 30,
            eSRC_BEEP = 31,
            eSRC_BLUETOOTH_VR = 32,
            eSRC_TUNER_TA = 33,
            eSRC_TUNER_DAB_TA = 34,
            eSRC_TUNER_FM = 35,
            eSRC_TUNER_AM = 36,
            eSRC_TUNER_DAB = 37,
            eSRC_TUNER_DAB_FM = 38,
            eSRC_TUNER_LW = 39,
            eSRC_TUNER_MW = 40,
            eSRC_TUNER_SW = 41,
            eSRC_TUNER_WB = 42,
            eSRC_TUNER_SDARS = 43,
            eSRC_TUNER_TRF = 44,
            eSRC_CDA = 45,
            eSRC_CDA_MC = 46,
            eSRC_CDA_DOWNMIX = 47,
            eSRC_DVDA = 48,
            eSRC_DVDA_MC = 49,
            eSRC_DVDV = 50,
            eSRC_DVDV_MC = 51,
            eSRC_AF = 52,
            eSRC_AF_MC = 53,
            eSRC_HDD = 54,
            eSRC_USB1 = 55,
            eSRC_USB2 = 56,
            eSRC_SD_CARD = 57,
            eSRC_UCI_AF = 58,
            eSRC_UCI_AUXIN = 59,
            eSRC_AUDIO_AUX1 = 60,
            eSRC_AUDIO_AUX2 = 61,
            eSRC_VIDEO_AUX1 = 62,
            eSRC_TONE_PREVIEW = 63,
            eSRC_BT_TTS_SMS = 64,
            eSRC_BT_A2DP = 65,
            eSRC_BT_A2DP2 = 66,
            eSRC_BT_TTS_PROMPT = 67,
            eSRC_BROWSER = 68,
            eSRC_BROWSER_HP = 69,
            eSRC_BROWSER_FUL = 70,
            eSRC_BROWSER_FUR = 71,
            eSRC_IP_RADIO = 72,
            eSRC_POI = 73,
            eSRC_TUNERBOX = 74,
            eSRC_TUNERBOX_VIDEO = 75,
            eSRC_DIPO_MEDIA = 76,
            eSRC_GAL_MEDIA = 77,
            eSRC_CARLIFE_MEDIA = 78,
            eSRC_MIRRORLINK_MEDIA = 79,
            eSRC_FU_CDA = 80,
            eSRC_FU_DVD_MC = 81,
            eSRC_FU_IPOD = 82,
            eSRC_FU_MP3 = 83,
            eSRC_FU_AUXA = 84,
            eSRC_FU_BTA = 85,
            eSRC_FU_BRO = 86,
            eSRC_MANUAL_MUTE = 87,
            eSRC_APPLINK_MEDIA = 88,
            eSRC_APPLINK_NAVI = 89,
            eSRC_APPLINK_VR = 90,
            eSRC_ECALL_PHONE = 91,
            eSRC_ECALL_PROMPT_PSAP = 92,
            eSRC_RELEASE_ALL = 93,
            eSRC_ECALL_PROMPT_IN_VEHICLE = 94,
            eSRC_MIC = 95,
            eSRC_TESTTONE = 96,
            eSRC_AUDIO_OFF = 97,
            eSRC_TUNER_DRM = 98,
            eSRC_APPLINK_TTS = 99,
            eSRC_SAL_MEDIA = 100,
            eSRC_CHIME_ALARM = 101,
            eSRC_USB3 = 102,
            eSRC_USB4 = 103,
            eSRC_RECORDED_PLAYBACK = 104,
            eSRC_SAL_MEDIA_USB = 105,
            eSRC_TUNER_PTY_NEWS = 106,
            eSRC_DLNA = 107,
            eSRC_FU_IPOD2 = 108,
            eSRC_MAX = 109
        };
        
        am_sourceID_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::eSRC_UNKNOWN)) {}
        am_sourceID_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::eSRC_UNKNOWN):
                case static_cast<int32_t>(Literal::eSRC_SERVICE_CALL):
                case static_cast<int32_t>(Literal::eSRC_VOICERECORDER):
                case static_cast<int32_t>(Literal::eSRC_SDS):
                case static_cast<int32_t>(Literal::eSRC_TTS):
                case static_cast<int32_t>(Literal::eSRC_NAV):
                case static_cast<int32_t>(Literal::eSRC_ETC_WARNING):
                case static_cast<int32_t>(Literal::eSRC_ETC_INFO):
                case static_cast<int32_t>(Literal::eSRC_TEL_HANDSFREE):
                case static_cast<int32_t>(Literal::eSRC_TEL_RINGING):
                case static_cast<int32_t>(Literal::eSRC_DIPO_PHONE):
                case static_cast<int32_t>(Literal::eSRC_DIPO_PHONE_RINGING):
                case static_cast<int32_t>(Literal::eSRC_DIPO_SIRI):
                case static_cast<int32_t>(Literal::eSRC_DIPO_ALT):
                case static_cast<int32_t>(Literal::eSRC_FU_TEL_HANDSFREE):
                case static_cast<int32_t>(Literal::eSRC_FU_TEL_RINGING):
                case static_cast<int32_t>(Literal::eSRC_GAL_VOICE):
                case static_cast<int32_t>(Literal::eSRC_GAL_NAVI):
                case static_cast<int32_t>(Literal::eSRC_GAL_UI):
                case static_cast<int32_t>(Literal::eSRC_GAL_VR):
                case static_cast<int32_t>(Literal::eSRC_IN_CAR_COM):
                case static_cast<int32_t>(Literal::eSRC_UXI_INF):
                case static_cast<int32_t>(Literal::eSRC_CARLIFE_NAVI):
                case static_cast<int32_t>(Literal::eSRC_CARLIFE_VR):
                case static_cast<int32_t>(Literal::eSRC_MIRRORLINK_VR):
                case static_cast<int32_t>(Literal::eSRC_TBOX_ECALL):
                case static_cast<int32_t>(Literal::eSRC_TBOX_ICALL):
                case static_cast<int32_t>(Literal::eSRC_CHIME_CONFIRMATION):
                case static_cast<int32_t>(Literal::eSRC_CHIME_INDICATION):
                case static_cast<int32_t>(Literal::eSRC_CHIME_WARNING):
                case static_cast<int32_t>(Literal::eSRC_CHIME_KEYPAD):
                case static_cast<int32_t>(Literal::eSRC_BEEP):
                case static_cast<int32_t>(Literal::eSRC_BLUETOOTH_VR):
                case static_cast<int32_t>(Literal::eSRC_TUNER_TA):
                case static_cast<int32_t>(Literal::eSRC_TUNER_DAB_TA):
                case static_cast<int32_t>(Literal::eSRC_TUNER_FM):
                case static_cast<int32_t>(Literal::eSRC_TUNER_AM):
                case static_cast<int32_t>(Literal::eSRC_TUNER_DAB):
                case static_cast<int32_t>(Literal::eSRC_TUNER_DAB_FM):
                case static_cast<int32_t>(Literal::eSRC_TUNER_LW):
                case static_cast<int32_t>(Literal::eSRC_TUNER_MW):
                case static_cast<int32_t>(Literal::eSRC_TUNER_SW):
                case static_cast<int32_t>(Literal::eSRC_TUNER_WB):
                case static_cast<int32_t>(Literal::eSRC_TUNER_SDARS):
                case static_cast<int32_t>(Literal::eSRC_TUNER_TRF):
                case static_cast<int32_t>(Literal::eSRC_CDA):
                case static_cast<int32_t>(Literal::eSRC_CDA_MC):
                case static_cast<int32_t>(Literal::eSRC_CDA_DOWNMIX):
                case static_cast<int32_t>(Literal::eSRC_DVDA):
                case static_cast<int32_t>(Literal::eSRC_DVDA_MC):
                case static_cast<int32_t>(Literal::eSRC_DVDV):
                case static_cast<int32_t>(Literal::eSRC_DVDV_MC):
                case static_cast<int32_t>(Literal::eSRC_AF):
                case static_cast<int32_t>(Literal::eSRC_AF_MC):
                case static_cast<int32_t>(Literal::eSRC_HDD):
                case static_cast<int32_t>(Literal::eSRC_USB1):
                case static_cast<int32_t>(Literal::eSRC_USB2):
                case static_cast<int32_t>(Literal::eSRC_SD_CARD):
                case static_cast<int32_t>(Literal::eSRC_UCI_AF):
                case static_cast<int32_t>(Literal::eSRC_UCI_AUXIN):
                case static_cast<int32_t>(Literal::eSRC_AUDIO_AUX1):
                case static_cast<int32_t>(Literal::eSRC_AUDIO_AUX2):
                case static_cast<int32_t>(Literal::eSRC_VIDEO_AUX1):
                case static_cast<int32_t>(Literal::eSRC_TONE_PREVIEW):
                case static_cast<int32_t>(Literal::eSRC_BT_TTS_SMS):
                case static_cast<int32_t>(Literal::eSRC_BT_A2DP):
                case static_cast<int32_t>(Literal::eSRC_BT_A2DP2):
                case static_cast<int32_t>(Literal::eSRC_BT_TTS_PROMPT):
                case static_cast<int32_t>(Literal::eSRC_BROWSER):
                case static_cast<int32_t>(Literal::eSRC_BROWSER_HP):
                case static_cast<int32_t>(Literal::eSRC_BROWSER_FUL):
                case static_cast<int32_t>(Literal::eSRC_BROWSER_FUR):
                case static_cast<int32_t>(Literal::eSRC_IP_RADIO):
                case static_cast<int32_t>(Literal::eSRC_POI):
                case static_cast<int32_t>(Literal::eSRC_TUNERBOX):
                case static_cast<int32_t>(Literal::eSRC_TUNERBOX_VIDEO):
                case static_cast<int32_t>(Literal::eSRC_DIPO_MEDIA):
                case static_cast<int32_t>(Literal::eSRC_GAL_MEDIA):
                case static_cast<int32_t>(Literal::eSRC_CARLIFE_MEDIA):
                case static_cast<int32_t>(Literal::eSRC_MIRRORLINK_MEDIA):
                case static_cast<int32_t>(Literal::eSRC_FU_CDA):
                case static_cast<int32_t>(Literal::eSRC_FU_DVD_MC):
                case static_cast<int32_t>(Literal::eSRC_FU_IPOD):
                case static_cast<int32_t>(Literal::eSRC_FU_MP3):
                case static_cast<int32_t>(Literal::eSRC_FU_AUXA):
                case static_cast<int32_t>(Literal::eSRC_FU_BTA):
                case static_cast<int32_t>(Literal::eSRC_FU_BRO):
                case static_cast<int32_t>(Literal::eSRC_MANUAL_MUTE):
                case static_cast<int32_t>(Literal::eSRC_APPLINK_MEDIA):
                case static_cast<int32_t>(Literal::eSRC_APPLINK_NAVI):
                case static_cast<int32_t>(Literal::eSRC_APPLINK_VR):
                case static_cast<int32_t>(Literal::eSRC_ECALL_PHONE):
                case static_cast<int32_t>(Literal::eSRC_ECALL_PROMPT_PSAP):
                case static_cast<int32_t>(Literal::eSRC_RELEASE_ALL):
                case static_cast<int32_t>(Literal::eSRC_ECALL_PROMPT_IN_VEHICLE):
                case static_cast<int32_t>(Literal::eSRC_MIC):
                case static_cast<int32_t>(Literal::eSRC_TESTTONE):
                case static_cast<int32_t>(Literal::eSRC_AUDIO_OFF):
                case static_cast<int32_t>(Literal::eSRC_TUNER_DRM):
                case static_cast<int32_t>(Literal::eSRC_APPLINK_TTS):
                case static_cast<int32_t>(Literal::eSRC_SAL_MEDIA):
                case static_cast<int32_t>(Literal::eSRC_CHIME_ALARM):
                case static_cast<int32_t>(Literal::eSRC_USB3):
                case static_cast<int32_t>(Literal::eSRC_USB4):
                case static_cast<int32_t>(Literal::eSRC_RECORDED_PLAYBACK):
                case static_cast<int32_t>(Literal::eSRC_SAL_MEDIA_USB):
                case static_cast<int32_t>(Literal::eSRC_TUNER_PTY_NEWS):
                case static_cast<int32_t>(Literal::eSRC_DLNA):
                case static_cast<int32_t>(Literal::eSRC_FU_IPOD2):
                case static_cast<int32_t>(Literal::eSRC_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_sourceID_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_sourceID_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_sourceID_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_sourceID_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_sourceID_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_sourceID_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct am_sourceClassID_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            SOURCE_CLASS_UNKNOWN = 0,
            SOURCE_CLASS_ENTERTAINMENT = 1,
            SOURCE_CLASS_PHONE = 2,
            SOURCE_CLASS_NAVIGATION = 3,
            SOURCE_CLASS_BEEP = 4,
            SOURCE_CLASS_MUTE = 5,
            SOURCE_CLASS_MAX = 6
        };
        
        am_sourceClassID_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::SOURCE_CLASS_UNKNOWN)) {}
        am_sourceClassID_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::SOURCE_CLASS_UNKNOWN):
                case static_cast<int32_t>(Literal::SOURCE_CLASS_ENTERTAINMENT):
                case static_cast<int32_t>(Literal::SOURCE_CLASS_PHONE):
                case static_cast<int32_t>(Literal::SOURCE_CLASS_NAVIGATION):
                case static_cast<int32_t>(Literal::SOURCE_CLASS_BEEP):
                case static_cast<int32_t>(Literal::SOURCE_CLASS_MUTE):
                case static_cast<int32_t>(Literal::SOURCE_CLASS_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_sourceClassID_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_sourceClassID_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_sourceClassID_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_sourceClassID_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_sourceClassID_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_sourceClassID_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct am_sinkID_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            eSNK_UNKNOWN = 0,
            eSNK_SPKS = 1,
            eSNK_HUHP = 2,
            eSNK_WHPL = 3,
            eSNK_WHPR = 4,
            eSNK_ESE = 5,
            eSNK_MAX = 6
        };
        
        am_sinkID_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::eSNK_UNKNOWN)) {}
        am_sinkID_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::eSNK_UNKNOWN):
                case static_cast<int32_t>(Literal::eSNK_SPKS):
                case static_cast<int32_t>(Literal::eSNK_HUHP):
                case static_cast<int32_t>(Literal::eSNK_WHPL):
                case static_cast<int32_t>(Literal::eSNK_WHPR):
                case static_cast<int32_t>(Literal::eSNK_ESE):
                case static_cast<int32_t>(Literal::eSNK_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_sinkID_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_sinkID_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_sinkID_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_sinkID_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_sinkID_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_sinkID_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct am_EQ_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            EQ_UNKNOWN = 0,
            NORMAL = 1,
            ROCK = 2,
            POP = 3,
            JAZZ = 4,
            CLASSIC = 5,
            VOCAL = 6,
            HIPHOP = 7,
            FLAT = 8,
            USERDEF = 9,
            EQ_MAX = 10
        };
        
        am_EQ_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::EQ_UNKNOWN)) {}
        am_EQ_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::EQ_UNKNOWN):
                case static_cast<int32_t>(Literal::NORMAL):
                case static_cast<int32_t>(Literal::ROCK):
                case static_cast<int32_t>(Literal::POP):
                case static_cast<int32_t>(Literal::JAZZ):
                case static_cast<int32_t>(Literal::CLASSIC):
                case static_cast<int32_t>(Literal::VOCAL):
                case static_cast<int32_t>(Literal::HIPHOP):
                case static_cast<int32_t>(Literal::FLAT):
                case static_cast<int32_t>(Literal::USERDEF):
                case static_cast<int32_t>(Literal::EQ_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_EQ_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_EQ_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_EQ_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_EQ_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_EQ_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_EQ_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct am_ConnectionMode_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            CM_UNKNOWN = 0,
            CM_MANUAL = 1,
            CM_AUTO = 2,
            CM_MAX = 3
        };
        
        am_ConnectionMode_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::CM_UNKNOWN)) {}
        am_ConnectionMode_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::CM_UNKNOWN):
                case static_cast<int32_t>(Literal::CM_MANUAL):
                case static_cast<int32_t>(Literal::CM_AUTO):
                case static_cast<int32_t>(Literal::CM_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_ConnectionMode_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_ConnectionMode_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_ConnectionMode_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_ConnectionMode_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_ConnectionMode_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_ConnectionMode_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct am_USBAutoPlay_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            UAP_UNKNOWN = 0,
            UAP_ON = 1,
            UAP_OFF = 2,
            UAP_MAX = 3
        };
        
        am_USBAutoPlay_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::UAP_UNKNOWN)) {}
        am_USBAutoPlay_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::UAP_UNKNOWN):
                case static_cast<int32_t>(Literal::UAP_ON):
                case static_cast<int32_t>(Literal::UAP_OFF):
                case static_cast<int32_t>(Literal::UAP_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_USBAutoPlay_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_USBAutoPlay_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_USBAutoPlay_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_USBAutoPlay_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_USBAutoPlay_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_USBAutoPlay_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct am_VolumeUpdate_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            VU_UNKNOWN = 0,
            VU_UPDATE = 1,
            VU_NOUPDATE = 2,
            VU_ENT_UPDATE = 3,
            VU_VR_UPDATE = 4,
            VU_PROMPT_UPDATE = 5,
            VU_PHONE_UPDATE = 6,
            VU_TA_UPDATE = 7,
            AP_MAX = 8
        };
        
        am_VolumeUpdate_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::VU_UNKNOWN)) {}
        am_VolumeUpdate_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::VU_UNKNOWN):
                case static_cast<int32_t>(Literal::VU_UPDATE):
                case static_cast<int32_t>(Literal::VU_NOUPDATE):
                case static_cast<int32_t>(Literal::VU_ENT_UPDATE):
                case static_cast<int32_t>(Literal::VU_VR_UPDATE):
                case static_cast<int32_t>(Literal::VU_PROMPT_UPDATE):
                case static_cast<int32_t>(Literal::VU_PHONE_UPDATE):
                case static_cast<int32_t>(Literal::VU_TA_UPDATE):
                case static_cast<int32_t>(Literal::AP_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_VolumeUpdate_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_VolumeUpdate_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_VolumeUpdate_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_VolumeUpdate_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_VolumeUpdate_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_VolumeUpdate_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct am_EmergencyCAll_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            ECALL_UNKNOWN = 0,
            ECALL_UNMUTE = 1,
            ECALL_AUTO_MUTE = 2,
            ECALL_MANUAL_MUTE = 3,
            ECALL_MAX = 4
        };
        
        am_EmergencyCAll_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::ECALL_UNKNOWN)) {}
        am_EmergencyCAll_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::ECALL_UNKNOWN):
                case static_cast<int32_t>(Literal::ECALL_UNMUTE):
                case static_cast<int32_t>(Literal::ECALL_AUTO_MUTE):
                case static_cast<int32_t>(Literal::ECALL_MANUAL_MUTE):
                case static_cast<int32_t>(Literal::ECALL_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_EmergencyCAll_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_EmergencyCAll_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_EmergencyCAll_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_EmergencyCAll_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_EmergencyCAll_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_EmergencyCAll_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct am_Clarifi_control_Type_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            CCT_UNKNOWN = -1,
            CCT_ENABLE = 0,
            CCT_DISABLE = 1,
            CCT_MAX = 3
        };
        
        am_Clarifi_control_Type_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::CCT_UNKNOWN)) {}
        am_Clarifi_control_Type_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::CCT_UNKNOWN):
                case static_cast<int32_t>(Literal::CCT_ENABLE):
                case static_cast<int32_t>(Literal::CCT_DISABLE):
                case static_cast<int32_t>(Literal::CCT_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_Clarifi_control_Type_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_Clarifi_control_Type_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_Clarifi_control_Type_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_Clarifi_control_Type_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_Clarifi_control_Type_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_Clarifi_control_Type_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct am_loudness_Type_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            AM_LOUDNESS_UNKNOWN = -1,
            AM_LOUDNESS_DISABLE = 0,
            AM_LOUDNESS_ENABLE = 1,
            AM_LOUDNESS_MAX = 3
        };
        
        am_loudness_Type_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::AM_LOUDNESS_UNKNOWN)) {}
        am_loudness_Type_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::AM_LOUDNESS_UNKNOWN):
                case static_cast<int32_t>(Literal::AM_LOUDNESS_DISABLE):
                case static_cast<int32_t>(Literal::AM_LOUDNESS_ENABLE):
                case static_cast<int32_t>(Literal::AM_LOUDNESS_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_loudness_Type_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_loudness_Type_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_loudness_Type_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_loudness_Type_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_loudness_Type_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_loudness_Type_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct am_avcMode_Type_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            AM_AVC_MODE_UNKNOWN = -1,
            AM_AVC_MODE_OFF = 0,
            AM_AVC_MODE_LOW = 1,
            AM_AVC_MODE_MID = 2,
            AM_AVC_MODE_HIGH = 3,
            AM_AVC_MODE_EXT_1 = 4,
            AM_AVC_MODE_EXT_2 = 5,
            AM_AVC_MODE_MAX = 7
        };
        
        am_avcMode_Type_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::AM_AVC_MODE_UNKNOWN)) {}
        am_avcMode_Type_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::AM_AVC_MODE_UNKNOWN):
                case static_cast<int32_t>(Literal::AM_AVC_MODE_OFF):
                case static_cast<int32_t>(Literal::AM_AVC_MODE_LOW):
                case static_cast<int32_t>(Literal::AM_AVC_MODE_MID):
                case static_cast<int32_t>(Literal::AM_AVC_MODE_HIGH):
                case static_cast<int32_t>(Literal::AM_AVC_MODE_EXT_1):
                case static_cast<int32_t>(Literal::AM_AVC_MODE_EXT_2):
                case static_cast<int32_t>(Literal::AM_AVC_MODE_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_avcMode_Type_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_avcMode_Type_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_avcMode_Type_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_avcMode_Type_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_avcMode_Type_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_avcMode_Type_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct am_MyKey_Type_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            MYKEY_UNKNOWN = -1,
            MYKEY_VOLUMEDEFAULT = 0,
            MYKEY_VOLUMELIMITED = 1,
            MYKEY_VOLUMEUNLIMITED = 2,
            MYKEY_VOLUMEMUTEED = 3,
            MYKEY_VOLUMEUNMUTEED = 4
        };
        
        am_MyKey_Type_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::MYKEY_UNKNOWN)) {}
        am_MyKey_Type_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::MYKEY_UNKNOWN):
                case static_cast<int32_t>(Literal::MYKEY_VOLUMEDEFAULT):
                case static_cast<int32_t>(Literal::MYKEY_VOLUMELIMITED):
                case static_cast<int32_t>(Literal::MYKEY_VOLUMEUNLIMITED):
                case static_cast<int32_t>(Literal::MYKEY_VOLUMEMUTEED):
                case static_cast<int32_t>(Literal::MYKEY_VOLUMEUNMUTEED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_MyKey_Type_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_MyKey_Type_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_MyKey_Type_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_MyKey_Type_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_MyKey_Type_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_MyKey_Type_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct am_ESE_Type_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            ESE_UNKNOWN = -1,
            ESE_OTHER_UNMUTE = 0,
            ESE_OTHER_MUTE = 1,
            ESE_ESE_UNMUTE = 2,
            ESE_ESE_MUTE = 3
        };
        
        am_ESE_Type_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::ESE_UNKNOWN)) {}
        am_ESE_Type_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::ESE_UNKNOWN):
                case static_cast<int32_t>(Literal::ESE_OTHER_UNMUTE):
                case static_cast<int32_t>(Literal::ESE_OTHER_MUTE):
                case static_cast<int32_t>(Literal::ESE_ESE_UNMUTE):
                case static_cast<int32_t>(Literal::ESE_ESE_MUTE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_ESE_Type_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_ESE_Type_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_ESE_Type_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_ESE_Type_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_ESE_Type_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_ESE_Type_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct am_Occupancy_Mode_Type_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            OCCUPANCY_INACTIVE = 0,
            OCCUPANCY_ALL_SEATS = 1,
            OCCUPANCY_DRIVER_SEAT = 2,
            OCCUPANCY_PASSENGER = 3,
            OCCUPANCY_FRONT_SEATS = 7,
            OCCUPANCY_REAR_SEATS = 8
        };
        
        am_Occupancy_Mode_Type_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::OCCUPANCY_INACTIVE)) {}
        am_Occupancy_Mode_Type_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::OCCUPANCY_INACTIVE):
                case static_cast<int32_t>(Literal::OCCUPANCY_ALL_SEATS):
                case static_cast<int32_t>(Literal::OCCUPANCY_DRIVER_SEAT):
                case static_cast<int32_t>(Literal::OCCUPANCY_PASSENGER):
                case static_cast<int32_t>(Literal::OCCUPANCY_FRONT_SEATS):
                case static_cast<int32_t>(Literal::OCCUPANCY_REAR_SEATS):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_Occupancy_Mode_Type_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_Occupancy_Mode_Type_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_Occupancy_Mode_Type_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_Occupancy_Mode_Type_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_Occupancy_Mode_Type_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_Occupancy_Mode_Type_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct am_Android_Auto_Request_Type_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            ANDROID_AUTO_REQUEST_INACTIVE = 0,
            ANDROID_AUTO_GAIN = 1,
            ANDROID_AUTO_GAIN_TRANSIENT = 2,
            ANDROID_AUTO_GAIN_TRANSIENT_MAY_DUCK = 3,
            ANDROID_AUTO_RELEASE = 4
        };
        
        am_Android_Auto_Request_Type_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::ANDROID_AUTO_REQUEST_INACTIVE)) {}
        am_Android_Auto_Request_Type_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::ANDROID_AUTO_REQUEST_INACTIVE):
                case static_cast<int32_t>(Literal::ANDROID_AUTO_GAIN):
                case static_cast<int32_t>(Literal::ANDROID_AUTO_GAIN_TRANSIENT):
                case static_cast<int32_t>(Literal::ANDROID_AUTO_GAIN_TRANSIENT_MAY_DUCK):
                case static_cast<int32_t>(Literal::ANDROID_AUTO_RELEASE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_Android_Auto_Request_Type_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_Android_Auto_Request_Type_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_Android_Auto_Request_Type_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_Android_Auto_Request_Type_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_Android_Auto_Request_Type_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_Android_Auto_Request_Type_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct am_Android_Auto_Response_Type_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            ANDROID_AUTO_RESPONSE_INACTIVE = 0,
            ANDROID_AUTO_STATE_GAIN = 1,
            ANDROID_AUTO_STATE_GAIN_TRANSIENT = 2,
            ANDROID_AUTO_STATE_GAIN_TRANSIENT_GUIDE_ONLY = 3,
            ANDROID_AUTO_STATE_GAIN_MEDIA_ONLY = 4,
            ANDROID_AUTO_STATE_GAIN_LOSS = 5,
            ANDROID_AUTO_STATE_GAIN_LOSS_TRANSIENT = 6,
            ANDROID_AUTO_STATE_GAIN_LOSS_TRANSIENT_MAY_DUCK = 7
        };
        
        am_Android_Auto_Response_Type_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::ANDROID_AUTO_RESPONSE_INACTIVE)) {}
        am_Android_Auto_Response_Type_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::ANDROID_AUTO_RESPONSE_INACTIVE):
                case static_cast<int32_t>(Literal::ANDROID_AUTO_STATE_GAIN):
                case static_cast<int32_t>(Literal::ANDROID_AUTO_STATE_GAIN_TRANSIENT):
                case static_cast<int32_t>(Literal::ANDROID_AUTO_STATE_GAIN_TRANSIENT_GUIDE_ONLY):
                case static_cast<int32_t>(Literal::ANDROID_AUTO_STATE_GAIN_MEDIA_ONLY):
                case static_cast<int32_t>(Literal::ANDROID_AUTO_STATE_GAIN_LOSS):
                case static_cast<int32_t>(Literal::ANDROID_AUTO_STATE_GAIN_LOSS_TRANSIENT):
                case static_cast<int32_t>(Literal::ANDROID_AUTO_STATE_GAIN_LOSS_TRANSIENT_MAY_DUCK):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_Android_Auto_Response_Type_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_Android_Auto_Response_Type_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_Android_Auto_Response_Type_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_Android_Auto_Response_Type_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_Android_Auto_Response_Type_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_Android_Auto_Response_Type_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct am_Audio_Off_Type_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            AUDIO_OFF_UNKNOWN = -1,
            AUDIO_OFF_INACTIVE = 0,
            AUDIO_OFF_ACTIVE = 1
        };
        
        am_Audio_Off_Type_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::AUDIO_OFF_UNKNOWN)) {}
        am_Audio_Off_Type_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::AUDIO_OFF_UNKNOWN):
                case static_cast<int32_t>(Literal::AUDIO_OFF_INACTIVE):
                case static_cast<int32_t>(Literal::AUDIO_OFF_ACTIVE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_Audio_Off_Type_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_Audio_Off_Type_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_Audio_Off_Type_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_Audio_Off_Type_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_Audio_Off_Type_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_Audio_Off_Type_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct am_Last_Source_Type_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            LAST_SOURCE_TYPE_UNKNOWN = -1,
            LAST_SOURCE_TYPE_ANDROID_AUTO = 0,
            LAST_SOURCE_TYPE_CARPLAY = 1,
            LAST_SOURCE_TYPE_CARLIFE = 2
        };
        
        am_Last_Source_Type_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::LAST_SOURCE_TYPE_UNKNOWN)) {}
        am_Last_Source_Type_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::LAST_SOURCE_TYPE_UNKNOWN):
                case static_cast<int32_t>(Literal::LAST_SOURCE_TYPE_ANDROID_AUTO):
                case static_cast<int32_t>(Literal::LAST_SOURCE_TYPE_CARPLAY):
                case static_cast<int32_t>(Literal::LAST_SOURCE_TYPE_CARLIFE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_Last_Source_Type_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_Last_Source_Type_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_Last_Source_Type_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_Last_Source_Type_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_Last_Source_Type_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_Last_Source_Type_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct am_Error_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            E_OK = 0,
            E_UNKNOWN = 1,
            E_OUT_OF_RANGE = 2,
            E_NOT_USED = 3,
            E_DATABASE_ERROR = 4,
            E_ALREADY_EXISTS = 5,
            E_NO_CHANGE = 6,
            E_NOT_POSSIBLE = 7,
            E_NON_EXISTENT = 8,
            E_ABORTED = 9,
            E_WRONG_FORMAT = 10,
            E_MAX = 11
        };
        
        am_Error_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::E_OK)) {}
        am_Error_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::E_OK):
                case static_cast<int32_t>(Literal::E_UNKNOWN):
                case static_cast<int32_t>(Literal::E_OUT_OF_RANGE):
                case static_cast<int32_t>(Literal::E_NOT_USED):
                case static_cast<int32_t>(Literal::E_DATABASE_ERROR):
                case static_cast<int32_t>(Literal::E_ALREADY_EXISTS):
                case static_cast<int32_t>(Literal::E_NO_CHANGE):
                case static_cast<int32_t>(Literal::E_NOT_POSSIBLE):
                case static_cast<int32_t>(Literal::E_NON_EXISTENT):
                case static_cast<int32_t>(Literal::E_ABORTED):
                case static_cast<int32_t>(Literal::E_WRONG_FORMAT):
                case static_cast<int32_t>(Literal::E_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_Error_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_Error_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_Error_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_Error_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_Error_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_Error_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct am_RoutingReady_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            RR_UNKNOWN = 0,
            RR_READY = 1,
            RR_RUNDOWN = 2
        };
        
        am_RoutingReady_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::RR_UNKNOWN)) {}
        am_RoutingReady_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::RR_UNKNOWN):
                case static_cast<int32_t>(Literal::RR_READY):
                case static_cast<int32_t>(Literal::RR_RUNDOWN):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_RoutingReady_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_RoutingReady_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_RoutingReady_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_RoutingReady_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_RoutingReady_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_RoutingReady_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct am_AvailabilityReason_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            USER_DISCONNECTED = 0,
            PEER_DISCONNECTED = 1,
            OUT_OF_RANGE_DISCONNECTED = 2,
            DATALINK_DISCONNECTED = 3,
            CONNECTION_FAILURE_DISCONNECTED = 4,
            ON_CONNECTION_RESET_DISCONNECTED = 5
        };
        
        am_AvailabilityReason_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::USER_DISCONNECTED)) {}
        am_AvailabilityReason_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::USER_DISCONNECTED):
                case static_cast<int32_t>(Literal::PEER_DISCONNECTED):
                case static_cast<int32_t>(Literal::OUT_OF_RANGE_DISCONNECTED):
                case static_cast<int32_t>(Literal::DATALINK_DISCONNECTED):
                case static_cast<int32_t>(Literal::CONNECTION_FAILURE_DISCONNECTED):
                case static_cast<int32_t>(Literal::ON_CONNECTION_RESET_DISCONNECTED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_AvailabilityReason_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_AvailabilityReason_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_AvailabilityReason_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_AvailabilityReason_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_AvailabilityReason_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_AvailabilityReason_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct am_DiagnosticSpeakerMask_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            DIAG_SPEAKER_UNKNOWN = 0,
            DIAG_SPEAKER_FL = 1,
            DIAG_SPEAKER_FR = 2,
            DIAG_SPEAKER_RL = 4,
            DIAG_SPEAKER_RR = 8,
            DIAG_SPEAKER_CENTER = 16,
            DIAG_SPEAKER_LINEOUT = 32,
            DIAG_SPEAKER_MAX = 64
        };
        
        am_DiagnosticSpeakerMask_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::DIAG_SPEAKER_UNKNOWN)) {}
        am_DiagnosticSpeakerMask_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::DIAG_SPEAKER_UNKNOWN):
                case static_cast<int32_t>(Literal::DIAG_SPEAKER_FL):
                case static_cast<int32_t>(Literal::DIAG_SPEAKER_FR):
                case static_cast<int32_t>(Literal::DIAG_SPEAKER_RL):
                case static_cast<int32_t>(Literal::DIAG_SPEAKER_RR):
                case static_cast<int32_t>(Literal::DIAG_SPEAKER_CENTER):
                case static_cast<int32_t>(Literal::DIAG_SPEAKER_LINEOUT):
                case static_cast<int32_t>(Literal::DIAG_SPEAKER_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_DiagnosticSpeakerMask_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_DiagnosticSpeakerMask_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_DiagnosticSpeakerMask_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_DiagnosticSpeakerMask_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_DiagnosticSpeakerMask_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_DiagnosticSpeakerMask_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct am_DiagnosticTestToneType_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            DIAG_TESTTONE_UNKNOWN = 0,
            DIAG_TESTTONE_SINE = 1,
            DIAG_TESTTONE_WHITE_NOISE = 2,
            DIAG_TESTTONE_PINK_NOISE = 3,
            DIAG_TESTTONE_WHITE_NOISE_BAND_LIMITED = 4,
            DIAG_TESTTONE_PINK_NOISE_BAND_LIMITED = 5,
            DIAG_TESTTONE_SWEEP = 6,
            DIAG_TESTTONE_MAX = 7
        };
        
        am_DiagnosticTestToneType_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::DIAG_TESTTONE_UNKNOWN)) {}
        am_DiagnosticTestToneType_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::DIAG_TESTTONE_UNKNOWN):
                case static_cast<int32_t>(Literal::DIAG_TESTTONE_SINE):
                case static_cast<int32_t>(Literal::DIAG_TESTTONE_WHITE_NOISE):
                case static_cast<int32_t>(Literal::DIAG_TESTTONE_PINK_NOISE):
                case static_cast<int32_t>(Literal::DIAG_TESTTONE_WHITE_NOISE_BAND_LIMITED):
                case static_cast<int32_t>(Literal::DIAG_TESTTONE_PINK_NOISE_BAND_LIMITED):
                case static_cast<int32_t>(Literal::DIAG_TESTTONE_SWEEP):
                case static_cast<int32_t>(Literal::DIAG_TESTTONE_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_DiagnosticTestToneType_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_DiagnosticTestToneType_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_DiagnosticTestToneType_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_DiagnosticTestToneType_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_DiagnosticTestToneType_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_DiagnosticTestToneType_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: unsigned char.
     */
    typedef uint8_t hq_uInt8_t;
    /**
     * description: unsigned short.
     */
    typedef uint16_t hq_uInt16_t;
    /**
     * description: unsigned int.
     */
    typedef uint32_t hq_uInt32_t;
    /**
     * description: signed char.
     */
    typedef int8_t hq_sInt8_t;
    /**
     * description: signed short.
     */
    typedef int16_t hq_sInt16_t;
    /**
     * description: signed int.
     */
    typedef int32_t hq_sInt32_t;
    /**
     * description: signed int.
     */
    typedef float hq_float32_t;
    /**
     * description: unsigned short.
     */
    typedef uint16_t hq_sourceID_t;
    /**
     * description: signed short.
     */
    typedef int16_t hq_volume_t;
    /**
     * description: unsigned char array.
     */
    typedef std::vector<am_t::hq_uInt8_t> hq_uInt8_t_L;
    /**
     * description: unsigned short array.
     */
    typedef std::vector<am_t::hq_uInt16_t> hq_uInt16_t_L;
    /**
     * description: unsigned int array.
     */
    typedef std::vector<am_t::hq_uInt32_t> hq_uInt32_t_L;
    /**
     * description: signed char array.
     */
    typedef std::vector<am_t::hq_sInt8_t> hq_sInt8_t_L;
    /**
     * description: signed short array.
     */
    typedef std::vector<am_t::hq_sInt16_t> hq_sInt16_t_L;
    /**
     * description: signed int array.
     */
    typedef std::vector<am_t::hq_sInt32_t> hq_sInt32_t_L;
    /**
     * description: signed int array.
     */
    typedef std::vector<am_t::hq_float32_t> hq_float32_t_L;
    /**
     * description: This struct describes the attributes of a limiter.
     */
    struct hq_limiterStruct_s : CommonAPI::Struct<hq_uInt8_t, hq_float32_t, hq_sInt8_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t> {
    	
    	hq_limiterStruct_s() {
    	}
    	hq_limiterStruct_s(const hq_uInt8_t &_channel, const hq_float32_t &_gain, const hq_sInt8_t &_threshold, const hq_float32_t &_attackTime, const hq_float32_t &_releaseTime, const hq_float32_t &_holdThreshold, const hq_float32_t &_holdTime)
    	{
    		std::get<0>(values_) = _channel;
    		std::get<1>(values_) = _gain;
    		std::get<2>(values_) = _threshold;
    		std::get<3>(values_) = _attackTime;
    		std::get<4>(values_) = _releaseTime;
    		std::get<5>(values_) = _holdThreshold;
    		std::get<6>(values_) = _holdTime;
    	}
    	/**
    	 * description: This is the channel number.
    	 */
    	inline const hq_uInt8_t &getChannel() const { return std::get<0>(values_); }
    	inline void setChannel(const hq_uInt8_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: This is the gain value, unit: db
    	 */
    	inline const hq_float32_t &getGain() const { return std::get<1>(values_); }
    	inline void setGain(const hq_float32_t &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: This is the threshold value, unit: db
    	 */
    	inline const hq_sInt8_t &getThreshold() const { return std::get<2>(values_); }
    	inline void setThreshold(const hq_sInt8_t &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: This is the attack time of limiter, unit: ms
    	 */
    	inline const hq_float32_t &getAttackTime() const { return std::get<3>(values_); }
    	inline void setAttackTime(const hq_float32_t &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: This is the release time of limiter, unit: ms.
    	 */
    	inline const hq_float32_t &getReleaseTime() const { return std::get<4>(values_); }
    	inline void setReleaseTime(const hq_float32_t &_value) { std::get<4>(values_) = _value; }
    	/**
    	 * description: This is the hold threshold of limiter, unit: db.
    	 */
    	inline const hq_float32_t &getHoldThreshold() const { return std::get<5>(values_); }
    	inline void setHoldThreshold(const hq_float32_t &_value) { std::get<5>(values_) = _value; }
    	/**
    	 * description: This is the hold time of limiter, unit: ms.
    	 */
    	inline const hq_float32_t &getHoldTime() const { return std::get<6>(values_); }
    	inline void setHoldTime(const hq_float32_t &_value) { std::get<6>(values_) = _value; }
    	inline bool operator==(const hq_limiterStruct_s& _other) const {
                return (getChannel() == _other.getChannel() && getGain() == _other.getGain() && getThreshold() == _other.getThreshold() && getAttackTime() == _other.getAttackTime() && getReleaseTime() == _other.getReleaseTime() && getHoldThreshold() == _other.getHoldThreshold() && getHoldTime() == _other.getHoldTime());
        }
    	inline bool operator!=(const hq_limiterStruct_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: array of hq_limiterStruct_s.
     */
    typedef std::vector<am_t::hq_limiterStruct_s> hq_limiterStruct_s_L;
    /**
     * description: This struct describes the attributes of a limiter.
     */
    struct hq_eqFilterStruct_s : CommonAPI::Struct<hq_uInt8_t, hq_uInt16_t, hq_sInt16_t, hq_float32_t, hq_uInt8_t, hq_uInt8_t> {
    	
    	hq_eqFilterStruct_s() {
    	}
    	hq_eqFilterStruct_s(const hq_uInt8_t &_bandIndex, const hq_uInt16_t &_frequency, const hq_sInt16_t &_gain, const hq_float32_t &_quality, const hq_uInt8_t &_type, const hq_uInt8_t &_order)
    	{
    		std::get<0>(values_) = _bandIndex;
    		std::get<1>(values_) = _frequency;
    		std::get<2>(values_) = _gain;
    		std::get<3>(values_) = _quality;
    		std::get<4>(values_) = _type;
    		std::get<5>(values_) = _order;
    	}
    	/**
    	 * description: This is the band index.
    	 */
    	inline const hq_uInt8_t &getBandIndex() const { return std::get<0>(values_); }
    	inline void setBandIndex(const hq_uInt8_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: This is the frequency of filter, unit Hz
    	 */
    	inline const hq_uInt16_t &getFrequency() const { return std::get<1>(values_); }
    	inline void setFrequency(const hq_uInt16_t &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: This is the gain value, unit: db
    	 */
    	inline const hq_sInt16_t &getGain() const { return std::get<2>(values_); }
    	inline void setGain(const hq_sInt16_t &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: This is the quality of filter.
    	 */
    	inline const hq_float32_t &getQuality() const { return std::get<3>(values_); }
    	inline void setQuality(const hq_float32_t &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: This is the type of filter.
    	 */
    	inline const hq_uInt8_t &getType() const { return std::get<4>(values_); }
    	inline void setType(const hq_uInt8_t &_value) { std::get<4>(values_) = _value; }
    	/**
    	 * description: This is the order of filter.
    	 */
    	inline const hq_uInt8_t &getOrder() const { return std::get<5>(values_); }
    	inline void setOrder(const hq_uInt8_t &_value) { std::get<5>(values_) = _value; }
    	inline bool operator==(const hq_eqFilterStruct_s& _other) const {
                return (getBandIndex() == _other.getBandIndex() && getFrequency() == _other.getFrequency() && getGain() == _other.getGain() && getQuality() == _other.getQuality() && getType() == _other.getType() && getOrder() == _other.getOrder());
        }
    	inline bool operator!=(const hq_eqFilterStruct_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: array of hq_eqFilterStruct_s.
     */
    typedef std::vector<am_t::hq_eqFilterStruct_s> hq_eqFilterStruct_s_L;
    /**
     * description: This struct describes the attributes of a limiter.
     */
    struct hq_delayTimeStruct_s : CommonAPI::Struct<hq_uInt8_t, hq_float32_t> {
    	
    	hq_delayTimeStruct_s() {
    	}
    	hq_delayTimeStruct_s(const hq_uInt8_t &_channel, const hq_float32_t &_delayTime)
    	{
    		std::get<0>(values_) = _channel;
    		std::get<1>(values_) = _delayTime;
    	}
    	/**
    	 * description: This is the channel number.
    	 */
    	inline const hq_uInt8_t &getChannel() const { return std::get<0>(values_); }
    	inline void setChannel(const hq_uInt8_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: This is the delay time of delay component.
    	 */
    	inline const hq_float32_t &getDelayTime() const { return std::get<1>(values_); }
    	inline void setDelayTime(const hq_float32_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const hq_delayTimeStruct_s& _other) const {
                return (getChannel() == _other.getChannel() && getDelayTime() == _other.getDelayTime());
        }
    	inline bool operator!=(const hq_delayTimeStruct_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: array of hq_delayTimeStruct_s.
     */
    typedef std::vector<am_t::hq_delayTimeStruct_s> hq_delayTimeStruct_s_L;
    /**
     * description: This struct describes the attributes of a loudness.
     */
    struct hq_londnessStruct_s : CommonAPI::Struct<hq_sInt16_t, hq_sInt16_t, hq_sInt16_t, hq_sInt16_t> {
    	
    	hq_londnessStruct_s() {
    	}
    	hq_londnessStruct_s(const hq_sInt16_t &_volumeLow, const hq_sInt16_t &_volumeHigh, const hq_sInt16_t &_gainLow, const hq_sInt16_t &_gainHigh)
    	{
    		std::get<0>(values_) = _volumeLow;
    		std::get<1>(values_) = _volumeHigh;
    		std::get<2>(values_) = _gainLow;
    		std::get<3>(values_) = _gainHigh;
    	}
    	/**
    	 * description: This is the bass volume  of londness.
    	 */
    	inline const hq_sInt16_t &getVolumeLow() const { return std::get<0>(values_); }
    	inline void setVolumeLow(const hq_sInt16_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: This is the treble volume of londness.
    	 */
    	inline const hq_sInt16_t &getVolumeHigh() const { return std::get<1>(values_); }
    	inline void setVolumeHigh(const hq_sInt16_t &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: This is the bass addition gain of londness.
    	 */
    	inline const hq_sInt16_t &getGainLow() const { return std::get<2>(values_); }
    	inline void setGainLow(const hq_sInt16_t &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: This is the treble addition gain of londness.
    	 */
    	inline const hq_sInt16_t &getGainHigh() const { return std::get<3>(values_); }
    	inline void setGainHigh(const hq_sInt16_t &_value) { std::get<3>(values_) = _value; }
    	inline bool operator==(const hq_londnessStruct_s& _other) const {
                return (getVolumeLow() == _other.getVolumeLow() && getVolumeHigh() == _other.getVolumeHigh() && getGainLow() == _other.getGainLow() && getGainHigh() == _other.getGainHigh());
        }
    	inline bool operator!=(const hq_londnessStruct_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: array of hq_londnessStruct_s.
     */
    typedef std::vector<am_t::hq_londnessStruct_s> hq_londnessStruct_s_L;
    /**
     * description: This struct describes the attributes of a channel gain.
     */
    struct hq_channelGainStruct_s : CommonAPI::Struct<hq_uInt8_t, hq_float32_t, hq_uInt8_t> {
    	
    	hq_channelGainStruct_s() {
    	}
    	hq_channelGainStruct_s(const hq_uInt8_t &_channel, const hq_float32_t &_gain, const hq_uInt8_t &_phase)
    	{
    		std::get<0>(values_) = _channel;
    		std::get<1>(values_) = _gain;
    		std::get<2>(values_) = _phase;
    	}
    	/**
    	 * description: This is the channel number.
    	 */
    	inline const hq_uInt8_t &getChannel() const { return std::get<0>(values_); }
    	inline void setChannel(const hq_uInt8_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: This is the gain value of channelGain.
    	 */
    	inline const hq_float32_t &getGain() const { return std::get<1>(values_); }
    	inline void setGain(const hq_float32_t &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: This is the phase value of channelGain.
    	 */
    	inline const hq_uInt8_t &getPhase() const { return std::get<2>(values_); }
    	inline void setPhase(const hq_uInt8_t &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const hq_channelGainStruct_s& _other) const {
                return (getChannel() == _other.getChannel() && getGain() == _other.getGain() && getPhase() == _other.getPhase());
        }
    	inline bool operator!=(const hq_channelGainStruct_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: array of hq_channelGainStruct_s.
     */
    typedef std::vector<am_t::hq_channelGainStruct_s> hq_channelGainStruct_s_L;
    /**
     * description: parameter of limiter function.
     */
    struct hq_limiterStruct_param : CommonAPI::Struct<hq_uInt8_t, hq_limiterStruct_s_L> {
    	
    	hq_limiterStruct_param() {
    	}
    	hq_limiterStruct_param(const hq_uInt8_t &_activateChlIndex, const hq_limiterStruct_s_L &_limiterStructArry)
    	{
    		std::get<0>(values_) = _activateChlIndex;
    		std::get<1>(values_) = _limiterStructArry;
    	}
    	/**
    	 * description: the index of one channel which's parameter need to be sended. If all channel
    	 *   need to be sended, the value is 0xff.
    	 */
    	inline const hq_uInt8_t &getActivateChlIndex() const { return std::get<0>(values_); }
    	inline void setActivateChlIndex(const hq_uInt8_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: the array of limiter paramter struct which can save all channels' parameter.
    	 */
    	inline const hq_limiterStruct_s_L &getLimiterStructArry() const { return std::get<1>(values_); }
    	inline void setLimiterStructArry(const hq_limiterStruct_s_L &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const hq_limiterStruct_param& _other) const {
                return (getActivateChlIndex() == _other.getActivateChlIndex() && getLimiterStructArry() == _other.getLimiterStructArry());
        }
    	inline bool operator!=(const hq_limiterStruct_param &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: parameter of eq function.
     */
    struct hq_eqFilterStruct_param : CommonAPI::Struct<hq_uInt8_t, hq_uInt8_t, hq_uInt8_t, hq_uInt8_t, hq_eqFilterStruct_s_L> {
    	
    	hq_eqFilterStruct_param() {
    	}
    	hq_eqFilterStruct_param(const hq_uInt8_t &_activateBandIndex, const hq_uInt8_t &_channel, const hq_uInt8_t &_startBandIndex, const hq_uInt8_t &_bandNum, const hq_eqFilterStruct_s_L &_eqFilterStructArry)
    	{
    		std::get<0>(values_) = _activateBandIndex;
    		std::get<1>(values_) = _channel;
    		std::get<2>(values_) = _startBandIndex;
    		std::get<3>(values_) = _bandNum;
    		std::get<4>(values_) = _eqFilterStructArry;
    	}
    	/**
    	 * description: the index of one channel which's parameter need to be sended. If all channel
    	 *   need to be sended, the value is 0xff.
    	 */
    	inline const hq_uInt8_t &getActivateBandIndex() const { return std::get<0>(values_); }
    	inline void setActivateBandIndex(const hq_uInt8_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: This is the Index of the channel whose filters shall be updated.
    	 */
    	inline const hq_uInt8_t &getChannel() const { return std::get<1>(values_); }
    	inline void setChannel(const hq_uInt8_t &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: This is the index of the first filter that shall be updated.
    	 */
    	inline const hq_uInt8_t &getStartBandIndex() const { return std::get<2>(values_); }
    	inline void setStartBandIndex(const hq_uInt8_t &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: This is the number of filters to be exchanged for this channel ( beginning from
    	 *   startBandIndex).
    	 */
    	inline const hq_uInt8_t &getBandNum() const { return std::get<3>(values_); }
    	inline void setBandNum(const hq_uInt8_t &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: The settings for the individual filters.
    	 */
    	inline const hq_eqFilterStruct_s_L &getEqFilterStructArry() const { return std::get<4>(values_); }
    	inline void setEqFilterStructArry(const hq_eqFilterStruct_s_L &_value) { std::get<4>(values_) = _value; }
    	inline bool operator==(const hq_eqFilterStruct_param& _other) const {
                return (getActivateBandIndex() == _other.getActivateBandIndex() && getChannel() == _other.getChannel() && getStartBandIndex() == _other.getStartBandIndex() && getBandNum() == _other.getBandNum() && getEqFilterStructArry() == _other.getEqFilterStructArry());
        }
    	inline bool operator!=(const hq_eqFilterStruct_param &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: This struct describes the attributes of a shaping fitler.
     */
    struct hq_shapingFilterStruct_s : CommonAPI::Struct<hq_uInt16_t, hq_float32_t, hq_float32_t> {
    	
    	hq_shapingFilterStruct_s() {
    	}
    	hq_shapingFilterStruct_s(const hq_uInt16_t &_frequency, const hq_float32_t &_quality, const hq_float32_t &_gain)
    	{
    		std::get<0>(values_) = _frequency;
    		std::get<1>(values_) = _quality;
    		std::get<2>(values_) = _gain;
    	}
    	/**
    	 * description: This is the frequency of filter, unit Hz
    	 */
    	inline const hq_uInt16_t &getFrequency() const { return std::get<0>(values_); }
    	inline void setFrequency(const hq_uInt16_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: This is the quality of filter.
    	 */
    	inline const hq_float32_t &getQuality() const { return std::get<1>(values_); }
    	inline void setQuality(const hq_float32_t &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: This is the gain value, unit: db
    	 */
    	inline const hq_float32_t &getGain() const { return std::get<2>(values_); }
    	inline void setGain(const hq_float32_t &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const hq_shapingFilterStruct_s& _other) const {
                return (getFrequency() == _other.getFrequency() && getQuality() == _other.getQuality() && getGain() == _other.getGain());
        }
    	inline bool operator!=(const hq_shapingFilterStruct_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: parameter of shaping filter function.
     */
    struct hq_shapingFilterStruct_param : CommonAPI::Struct<am_sinkID_t, hq_uInt8_t, hq_shapingFilterStruct_s> {
    	
    	hq_shapingFilterStruct_param() {
    	}
    	hq_shapingFilterStruct_param(const am_sinkID_t &_sinkID, const hq_uInt8_t &_bandIndex, const hq_shapingFilterStruct_s &_shapingFilterStruct)
    	{
    		std::get<0>(values_) = _sinkID;
    		std::get<1>(values_) = _bandIndex;
    		std::get<2>(values_) = _shapingFilterStruct;
    	}
    	/**
    	 * description: This is the ID of the sink, it is unique in the system. we have list all the
    	 *   sourceID enumeration in am_sinkID_e.
    	 */
    	inline const am_sinkID_t &getSinkID() const { return std::get<0>(values_); }
    	inline void setSinkID(const am_sinkID_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: This is the band index.
    	 */
    	inline const hq_uInt8_t &getBandIndex() const { return std::get<1>(values_); }
    	inline void setBandIndex(const hq_uInt8_t &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: The settings for the individual filters.
    	 */
    	inline const hq_shapingFilterStruct_s &getShapingFilterStruct() const { return std::get<2>(values_); }
    	inline void setShapingFilterStruct(const hq_shapingFilterStruct_s &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const hq_shapingFilterStruct_param& _other) const {
                return (getSinkID() == _other.getSinkID() && getBandIndex() == _other.getBandIndex() && getShapingFilterStruct() == _other.getShapingFilterStruct());
        }
    	inline bool operator!=(const hq_shapingFilterStruct_param &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: parameter of delayTime function.
     */
    struct hq_delayTimeStruct_param : CommonAPI::Struct<hq_uInt8_t, hq_delayTimeStruct_s_L> {
    	
    	hq_delayTimeStruct_param() {
    	}
    	hq_delayTimeStruct_param(const hq_uInt8_t &_activateChlIndex, const hq_delayTimeStruct_s_L &_delayTimeStructArry)
    	{
    		std::get<0>(values_) = _activateChlIndex;
    		std::get<1>(values_) = _delayTimeStructArry;
    	}
    	/**
    	 * description: the index of one channel which's parameter need to be sended. If all channel
    	 *   need to be sended, the value is 0xff.
    	 */
    	inline const hq_uInt8_t &getActivateChlIndex() const { return std::get<0>(values_); }
    	inline void setActivateChlIndex(const hq_uInt8_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: the array of delay time paramter struct which can save all channels' parameter.
    	 */
    	inline const hq_delayTimeStruct_s_L &getDelayTimeStructArry() const { return std::get<1>(values_); }
    	inline void setDelayTimeStructArry(const hq_delayTimeStruct_s_L &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const hq_delayTimeStruct_param& _other) const {
                return (getActivateChlIndex() == _other.getActivateChlIndex() && getDelayTimeStructArry() == _other.getDelayTimeStructArry());
        }
    	inline bool operator!=(const hq_delayTimeStruct_param &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: parameter of loudness function.
     */
    struct hq_londnessStruct_param : CommonAPI::Struct<hq_uInt8_t, hq_uInt8_t, hq_uInt16_t, hq_uInt16_t, hq_float32_t, hq_float32_t, hq_uInt8_t, hq_uInt8_t, hq_uInt8_t, hq_londnessStruct_s_L> {
    	
    	hq_londnessStruct_param() {
    	}
    	hq_londnessStruct_param(const hq_uInt8_t &_activateldIndex, const hq_uInt8_t &_calculationMode, const hq_uInt16_t &_frequencyLow, const hq_uInt16_t &_frequencyHigh, const hq_float32_t &_qualityLow, const hq_float32_t &_qualityHigh, const hq_uInt8_t &_filterTypeLow, const hq_uInt8_t &_filterTypeHigh, const hq_uInt8_t &_numTableEntries, const hq_londnessStruct_s_L &_londnessStructArry)
    	{
    		std::get<0>(values_) = _activateldIndex;
    		std::get<1>(values_) = _calculationMode;
    		std::get<2>(values_) = _frequencyLow;
    		std::get<3>(values_) = _frequencyHigh;
    		std::get<4>(values_) = _qualityLow;
    		std::get<5>(values_) = _qualityHigh;
    		std::get<6>(values_) = _filterTypeLow;
    		std::get<7>(values_) = _filterTypeHigh;
    		std::get<8>(values_) = _numTableEntries;
    		std::get<9>(values_) = _londnessStructArry;
    	}
    	/**
    	 * description: the index of one channel which's parameter need to be sended. If all channel
    	 *   need to be sended, the value is 0xff.
    	 */
    	inline const hq_uInt8_t &getActivateldIndex() const { return std::get<0>(values_); }
    	inline void setActivateldIndex(const hq_uInt8_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The way the loudness gain is calculated.
    	 */
    	inline const hq_uInt8_t &getCalculationMode() const { return std::get<1>(values_); }
    	inline void setCalculationMode(const hq_uInt8_t &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: This is the bass frequency of londness, unit Hz.
    	 */
    	inline const hq_uInt16_t &getFrequencyLow() const { return std::get<2>(values_); }
    	inline void setFrequencyLow(const hq_uInt16_t &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: This is the trible frequency of londness, unit Hz.
    	 */
    	inline const hq_uInt16_t &getFrequencyHigh() const { return std::get<3>(values_); }
    	inline void setFrequencyHigh(const hq_uInt16_t &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: This is the bass quality of londness.
    	 */
    	inline const hq_float32_t &getQualityLow() const { return std::get<4>(values_); }
    	inline void setQualityLow(const hq_float32_t &_value) { std::get<4>(values_) = _value; }
    	/**
    	 * description: This is the trible quality of londness.
    	 */
    	inline const hq_float32_t &getQualityHigh() const { return std::get<5>(values_); }
    	inline void setQualityHigh(const hq_float32_t &_value) { std::get<5>(values_) = _value; }
    	/**
    	 * description: This is the bass filter type of londness.
    	 */
    	inline const hq_uInt8_t &getFilterTypeLow() const { return std::get<6>(values_); }
    	inline void setFilterTypeLow(const hq_uInt8_t &_value) { std::get<6>(values_) = _value; }
    	/**
    	 * description: This is the trible filter type of londness.
    	 */
    	inline const hq_uInt8_t &getFilterTypeHigh() const { return std::get<7>(values_); }
    	inline void setFilterTypeHigh(const hq_uInt8_t &_value) { std::get<7>(values_) = _value; }
    	/**
    	 * description: This is the trible filter type of londness.
    	 */
    	inline const hq_uInt8_t &getNumTableEntries() const { return std::get<8>(values_); }
    	inline void setNumTableEntries(const hq_uInt8_t &_value) { std::get<8>(values_) = _value; }
    	/**
    	 * description: the array of loudness struct which can save all channels' parameter.
    	 */
    	inline const hq_londnessStruct_s_L &getLondnessStructArry() const { return std::get<9>(values_); }
    	inline void setLondnessStructArry(const hq_londnessStruct_s_L &_value) { std::get<9>(values_) = _value; }
    	inline bool operator==(const hq_londnessStruct_param& _other) const {
                return (getActivateldIndex() == _other.getActivateldIndex() && getCalculationMode() == _other.getCalculationMode() && getFrequencyLow() == _other.getFrequencyLow() && getFrequencyHigh() == _other.getFrequencyHigh() && getQualityLow() == _other.getQualityLow() && getQualityHigh() == _other.getQualityHigh() && getFilterTypeLow() == _other.getFilterTypeLow() && getFilterTypeHigh() == _other.getFilterTypeHigh() && getNumTableEntries() == _other.getNumTableEntries() && getLondnessStructArry() == _other.getLondnessStructArry());
        }
    	inline bool operator!=(const hq_londnessStruct_param &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: parameter of ClariFi function.
     */
    struct hq_ClariFiStruct_param : CommonAPI::Struct<hq_uInt8_t, hq_uInt8_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t> {
    	
    	hq_ClariFiStruct_param() {
    	}
    	hq_ClariFiStruct_param(const hq_uInt8_t &_writtenBack, const hq_uInt8_t &_needUpdate, const hq_float32_t &_MODE, const hq_float32_t &_SBR_MODE, const hq_float32_t &_VERB_LF, const hq_float32_t &_VERB_HF, const hq_float32_t &_SourceBitRate_Control, const hq_float32_t &_VocalAir_Control, const hq_float32_t &_VocalAir0_Control, const hq_float32_t &_VocalAir50_Control, const hq_float32_t &_VocalAirK_Control, const hq_float32_t &_VocAirLimit_Control, const hq_float32_t &_ASW_Control, const hq_float32_t &_ASW0_Control, const hq_float32_t &_DirectSignalGain_Control, const hq_float32_t &_OctaveFullBWExtGain_Control, const hq_float32_t &_OctaveFullBWExtGain0_Control, const hq_float32_t &_OctaveFullBWExtGain50_Control, const hq_float32_t &_OctaveFullBWExtGainK_Control, const hq_float32_t &_HardPanBoostGain_Control, const hq_float32_t &_HardPanBoostGain0_Control, const hq_float32_t &_VerbFillGain_Control, const hq_float32_t &_VerbFillGain0_Control, const hq_float32_t &_DrumFillGain_Control, const hq_float32_t &_DrumFillGain0_Control, const hq_float32_t &_DrumFillGain50_Control, const hq_float32_t &_DrumFillGainK_Control, const hq_float32_t &_MaskSpread_Control, const hq_float32_t &_MaskSpread0_Control, const hq_float32_t &_MaskSpread50_Control, const hq_float32_t &_MaskSpreadK_Control, const hq_float32_t &_ScaleGain_Control, const hq_float32_t &_SDBypass_Control, const hq_float32_t &_SDMode_Control, const hq_float32_t &_Intensity_Control, const hq_float32_t &_Softness_Control, const hq_float32_t &_Softness0_Control, const hq_float32_t &_Softness50_Control, const hq_float32_t &_SoftnessK_Control, const hq_float32_t &_TransBoost_Control, const hq_float32_t &_TransBoost0_Control, const hq_float32_t &_BassOverallBoost_Control, const hq_float32_t &_BassOverallBoost0_Control, const hq_float32_t &_Limiter_Control, const hq_float32_t &_SourceType_Control, const hq_float32_t &_GapThresh_Control, const hq_float32_t &_SNR_Control, const hq_float32_t &_LevelDiff_Control, const hq_float32_t &_VerbBWE_Control, const hq_float32_t &_VerbBWE0_Control, const hq_float32_t &_Dirac_Control, const hq_float32_t &_Dirac0_Control, const hq_float32_t &_ForceBinX_Control, const hq_float32_t &_ManualBinX_Control, const hq_float32_t &_SBRRx_Control, const hq_float32_t &_SBRsmoothing_Control, const hq_float32_t &_SBRsens_Control, const hq_float32_t &_BWELimit_Control, const hq_float32_t &_SpeechRx_Control, const hq_float32_t &_SpeechMode_Control, const hq_float32_t &_BWSensitivity_Control, const hq_float32_t &_DecorrMix_Control, const hq_float32_t &_DecorrMix0_Control, const hq_float32_t &_MonoThreshold, const hq_float32_t &_MONO_SENS, const hq_float32_t &_M2S_RATE, const hq_float32_t &_S2M_RATE, const hq_float32_t &_Speech_SCORE, const hq_float32_t &_Input_LEVEL, const hq_float32_t &_MONO_PROB)
    	{
    		std::get<0>(values_) = _writtenBack;
    		std::get<1>(values_) = _needUpdate;
    		std::get<2>(values_) = _MODE;
    		std::get<3>(values_) = _SBR_MODE;
    		std::get<4>(values_) = _VERB_LF;
    		std::get<5>(values_) = _VERB_HF;
    		std::get<6>(values_) = _SourceBitRate_Control;
    		std::get<7>(values_) = _VocalAir_Control;
    		std::get<8>(values_) = _VocalAir0_Control;
    		std::get<9>(values_) = _VocalAir50_Control;
    		std::get<10>(values_) = _VocalAirK_Control;
    		std::get<11>(values_) = _VocAirLimit_Control;
    		std::get<12>(values_) = _ASW_Control;
    		std::get<13>(values_) = _ASW0_Control;
    		std::get<14>(values_) = _DirectSignalGain_Control;
    		std::get<15>(values_) = _OctaveFullBWExtGain_Control;
    		std::get<16>(values_) = _OctaveFullBWExtGain0_Control;
    		std::get<17>(values_) = _OctaveFullBWExtGain50_Control;
    		std::get<18>(values_) = _OctaveFullBWExtGainK_Control;
    		std::get<19>(values_) = _HardPanBoostGain_Control;
    		std::get<20>(values_) = _HardPanBoostGain0_Control;
    		std::get<21>(values_) = _VerbFillGain_Control;
    		std::get<22>(values_) = _VerbFillGain0_Control;
    		std::get<23>(values_) = _DrumFillGain_Control;
    		std::get<24>(values_) = _DrumFillGain0_Control;
    		std::get<25>(values_) = _DrumFillGain50_Control;
    		std::get<26>(values_) = _DrumFillGainK_Control;
    		std::get<27>(values_) = _MaskSpread_Control;
    		std::get<28>(values_) = _MaskSpread0_Control;
    		std::get<29>(values_) = _MaskSpread50_Control;
    		std::get<30>(values_) = _MaskSpreadK_Control;
    		std::get<31>(values_) = _ScaleGain_Control;
    		std::get<32>(values_) = _SDBypass_Control;
    		std::get<33>(values_) = _SDMode_Control;
    		std::get<34>(values_) = _Intensity_Control;
    		std::get<35>(values_) = _Softness_Control;
    		std::get<36>(values_) = _Softness0_Control;
    		std::get<37>(values_) = _Softness50_Control;
    		std::get<38>(values_) = _SoftnessK_Control;
    		std::get<39>(values_) = _TransBoost_Control;
    		std::get<40>(values_) = _TransBoost0_Control;
    		std::get<41>(values_) = _BassOverallBoost_Control;
    		std::get<42>(values_) = _BassOverallBoost0_Control;
    		std::get<43>(values_) = _Limiter_Control;
    		std::get<44>(values_) = _SourceType_Control;
    		std::get<45>(values_) = _GapThresh_Control;
    		std::get<46>(values_) = _SNR_Control;
    		std::get<47>(values_) = _LevelDiff_Control;
    		std::get<48>(values_) = _VerbBWE_Control;
    		std::get<49>(values_) = _VerbBWE0_Control;
    		std::get<50>(values_) = _Dirac_Control;
    		std::get<51>(values_) = _Dirac0_Control;
    		std::get<52>(values_) = _ForceBinX_Control;
    		std::get<53>(values_) = _ManualBinX_Control;
    		std::get<54>(values_) = _SBRRx_Control;
    		std::get<55>(values_) = _SBRsmoothing_Control;
    		std::get<56>(values_) = _SBRsens_Control;
    		std::get<57>(values_) = _BWELimit_Control;
    		std::get<58>(values_) = _SpeechRx_Control;
    		std::get<59>(values_) = _SpeechMode_Control;
    		std::get<60>(values_) = _BWSensitivity_Control;
    		std::get<61>(values_) = _DecorrMix_Control;
    		std::get<62>(values_) = _DecorrMix0_Control;
    		std::get<63>(values_) = _MonoThreshold;
    		std::get<64>(values_) = _MONO_SENS;
    		std::get<65>(values_) = _M2S_RATE;
    		std::get<66>(values_) = _S2M_RATE;
    		std::get<67>(values_) = _Speech_SCORE;
    		std::get<68>(values_) = _Input_LEVEL;
    		std::get<69>(values_) = _MONO_PROB;
    	}
    	inline const hq_uInt8_t &getWrittenBack() const { return std::get<0>(values_); }
    	inline void setWrittenBack(const hq_uInt8_t &_value) { std::get<0>(values_) = _value; }
    	inline const hq_uInt8_t &getNeedUpdate() const { return std::get<1>(values_); }
    	inline void setNeedUpdate(const hq_uInt8_t &_value) { std::get<1>(values_) = _value; }
    	inline const hq_float32_t &getMODE() const { return std::get<2>(values_); }
    	inline void setMODE(const hq_float32_t &_value) { std::get<2>(values_) = _value; }
    	inline const hq_float32_t &getSBR_MODE() const { return std::get<3>(values_); }
    	inline void setSBR_MODE(const hq_float32_t &_value) { std::get<3>(values_) = _value; }
    	inline const hq_float32_t &getVERB_LF() const { return std::get<4>(values_); }
    	inline void setVERB_LF(const hq_float32_t &_value) { std::get<4>(values_) = _value; }
    	inline const hq_float32_t &getVERB_HF() const { return std::get<5>(values_); }
    	inline void setVERB_HF(const hq_float32_t &_value) { std::get<5>(values_) = _value; }
    	inline const hq_float32_t &getSourceBitRate_Control() const { return std::get<6>(values_); }
    	inline void setSourceBitRate_Control(const hq_float32_t &_value) { std::get<6>(values_) = _value; }
    	inline const hq_float32_t &getVocalAir_Control() const { return std::get<7>(values_); }
    	inline void setVocalAir_Control(const hq_float32_t &_value) { std::get<7>(values_) = _value; }
    	inline const hq_float32_t &getVocalAir0_Control() const { return std::get<8>(values_); }
    	inline void setVocalAir0_Control(const hq_float32_t &_value) { std::get<8>(values_) = _value; }
    	inline const hq_float32_t &getVocalAir50_Control() const { return std::get<9>(values_); }
    	inline void setVocalAir50_Control(const hq_float32_t &_value) { std::get<9>(values_) = _value; }
    	inline const hq_float32_t &getVocalAirK_Control() const { return std::get<10>(values_); }
    	inline void setVocalAirK_Control(const hq_float32_t &_value) { std::get<10>(values_) = _value; }
    	inline const hq_float32_t &getVocAirLimit_Control() const { return std::get<11>(values_); }
    	inline void setVocAirLimit_Control(const hq_float32_t &_value) { std::get<11>(values_) = _value; }
    	inline const hq_float32_t &getASW_Control() const { return std::get<12>(values_); }
    	inline void setASW_Control(const hq_float32_t &_value) { std::get<12>(values_) = _value; }
    	inline const hq_float32_t &getASW0_Control() const { return std::get<13>(values_); }
    	inline void setASW0_Control(const hq_float32_t &_value) { std::get<13>(values_) = _value; }
    	inline const hq_float32_t &getDirectSignalGain_Control() const { return std::get<14>(values_); }
    	inline void setDirectSignalGain_Control(const hq_float32_t &_value) { std::get<14>(values_) = _value; }
    	inline const hq_float32_t &getOctaveFullBWExtGain_Control() const { return std::get<15>(values_); }
    	inline void setOctaveFullBWExtGain_Control(const hq_float32_t &_value) { std::get<15>(values_) = _value; }
    	inline const hq_float32_t &getOctaveFullBWExtGain0_Control() const { return std::get<16>(values_); }
    	inline void setOctaveFullBWExtGain0_Control(const hq_float32_t &_value) { std::get<16>(values_) = _value; }
    	inline const hq_float32_t &getOctaveFullBWExtGain50_Control() const { return std::get<17>(values_); }
    	inline void setOctaveFullBWExtGain50_Control(const hq_float32_t &_value) { std::get<17>(values_) = _value; }
    	inline const hq_float32_t &getOctaveFullBWExtGainK_Control() const { return std::get<18>(values_); }
    	inline void setOctaveFullBWExtGainK_Control(const hq_float32_t &_value) { std::get<18>(values_) = _value; }
    	inline const hq_float32_t &getHardPanBoostGain_Control() const { return std::get<19>(values_); }
    	inline void setHardPanBoostGain_Control(const hq_float32_t &_value) { std::get<19>(values_) = _value; }
    	inline const hq_float32_t &getHardPanBoostGain0_Control() const { return std::get<20>(values_); }
    	inline void setHardPanBoostGain0_Control(const hq_float32_t &_value) { std::get<20>(values_) = _value; }
    	inline const hq_float32_t &getVerbFillGain_Control() const { return std::get<21>(values_); }
    	inline void setVerbFillGain_Control(const hq_float32_t &_value) { std::get<21>(values_) = _value; }
    	inline const hq_float32_t &getVerbFillGain0_Control() const { return std::get<22>(values_); }
    	inline void setVerbFillGain0_Control(const hq_float32_t &_value) { std::get<22>(values_) = _value; }
    	inline const hq_float32_t &getDrumFillGain_Control() const { return std::get<23>(values_); }
    	inline void setDrumFillGain_Control(const hq_float32_t &_value) { std::get<23>(values_) = _value; }
    	inline const hq_float32_t &getDrumFillGain0_Control() const { return std::get<24>(values_); }
    	inline void setDrumFillGain0_Control(const hq_float32_t &_value) { std::get<24>(values_) = _value; }
    	inline const hq_float32_t &getDrumFillGain50_Control() const { return std::get<25>(values_); }
    	inline void setDrumFillGain50_Control(const hq_float32_t &_value) { std::get<25>(values_) = _value; }
    	inline const hq_float32_t &getDrumFillGainK_Control() const { return std::get<26>(values_); }
    	inline void setDrumFillGainK_Control(const hq_float32_t &_value) { std::get<26>(values_) = _value; }
    	inline const hq_float32_t &getMaskSpread_Control() const { return std::get<27>(values_); }
    	inline void setMaskSpread_Control(const hq_float32_t &_value) { std::get<27>(values_) = _value; }
    	inline const hq_float32_t &getMaskSpread0_Control() const { return std::get<28>(values_); }
    	inline void setMaskSpread0_Control(const hq_float32_t &_value) { std::get<28>(values_) = _value; }
    	inline const hq_float32_t &getMaskSpread50_Control() const { return std::get<29>(values_); }
    	inline void setMaskSpread50_Control(const hq_float32_t &_value) { std::get<29>(values_) = _value; }
    	inline const hq_float32_t &getMaskSpreadK_Control() const { return std::get<30>(values_); }
    	inline void setMaskSpreadK_Control(const hq_float32_t &_value) { std::get<30>(values_) = _value; }
    	inline const hq_float32_t &getScaleGain_Control() const { return std::get<31>(values_); }
    	inline void setScaleGain_Control(const hq_float32_t &_value) { std::get<31>(values_) = _value; }
    	inline const hq_float32_t &getSDBypass_Control() const { return std::get<32>(values_); }
    	inline void setSDBypass_Control(const hq_float32_t &_value) { std::get<32>(values_) = _value; }
    	inline const hq_float32_t &getSDMode_Control() const { return std::get<33>(values_); }
    	inline void setSDMode_Control(const hq_float32_t &_value) { std::get<33>(values_) = _value; }
    	inline const hq_float32_t &getIntensity_Control() const { return std::get<34>(values_); }
    	inline void setIntensity_Control(const hq_float32_t &_value) { std::get<34>(values_) = _value; }
    	inline const hq_float32_t &getSoftness_Control() const { return std::get<35>(values_); }
    	inline void setSoftness_Control(const hq_float32_t &_value) { std::get<35>(values_) = _value; }
    	inline const hq_float32_t &getSoftness0_Control() const { return std::get<36>(values_); }
    	inline void setSoftness0_Control(const hq_float32_t &_value) { std::get<36>(values_) = _value; }
    	inline const hq_float32_t &getSoftness50_Control() const { return std::get<37>(values_); }
    	inline void setSoftness50_Control(const hq_float32_t &_value) { std::get<37>(values_) = _value; }
    	inline const hq_float32_t &getSoftnessK_Control() const { return std::get<38>(values_); }
    	inline void setSoftnessK_Control(const hq_float32_t &_value) { std::get<38>(values_) = _value; }
    	inline const hq_float32_t &getTransBoost_Control() const { return std::get<39>(values_); }
    	inline void setTransBoost_Control(const hq_float32_t &_value) { std::get<39>(values_) = _value; }
    	inline const hq_float32_t &getTransBoost0_Control() const { return std::get<40>(values_); }
    	inline void setTransBoost0_Control(const hq_float32_t &_value) { std::get<40>(values_) = _value; }
    	inline const hq_float32_t &getBassOverallBoost_Control() const { return std::get<41>(values_); }
    	inline void setBassOverallBoost_Control(const hq_float32_t &_value) { std::get<41>(values_) = _value; }
    	inline const hq_float32_t &getBassOverallBoost0_Control() const { return std::get<42>(values_); }
    	inline void setBassOverallBoost0_Control(const hq_float32_t &_value) { std::get<42>(values_) = _value; }
    	inline const hq_float32_t &getLimiter_Control() const { return std::get<43>(values_); }
    	inline void setLimiter_Control(const hq_float32_t &_value) { std::get<43>(values_) = _value; }
    	inline const hq_float32_t &getSourceType_Control() const { return std::get<44>(values_); }
    	inline void setSourceType_Control(const hq_float32_t &_value) { std::get<44>(values_) = _value; }
    	inline const hq_float32_t &getGapThresh_Control() const { return std::get<45>(values_); }
    	inline void setGapThresh_Control(const hq_float32_t &_value) { std::get<45>(values_) = _value; }
    	inline const hq_float32_t &getSNR_Control() const { return std::get<46>(values_); }
    	inline void setSNR_Control(const hq_float32_t &_value) { std::get<46>(values_) = _value; }
    	inline const hq_float32_t &getLevelDiff_Control() const { return std::get<47>(values_); }
    	inline void setLevelDiff_Control(const hq_float32_t &_value) { std::get<47>(values_) = _value; }
    	inline const hq_float32_t &getVerbBWE_Control() const { return std::get<48>(values_); }
    	inline void setVerbBWE_Control(const hq_float32_t &_value) { std::get<48>(values_) = _value; }
    	inline const hq_float32_t &getVerbBWE0_Control() const { return std::get<49>(values_); }
    	inline void setVerbBWE0_Control(const hq_float32_t &_value) { std::get<49>(values_) = _value; }
    	inline const hq_float32_t &getDirac_Control() const { return std::get<50>(values_); }
    	inline void setDirac_Control(const hq_float32_t &_value) { std::get<50>(values_) = _value; }
    	inline const hq_float32_t &getDirac0_Control() const { return std::get<51>(values_); }
    	inline void setDirac0_Control(const hq_float32_t &_value) { std::get<51>(values_) = _value; }
    	inline const hq_float32_t &getForceBinX_Control() const { return std::get<52>(values_); }
    	inline void setForceBinX_Control(const hq_float32_t &_value) { std::get<52>(values_) = _value; }
    	inline const hq_float32_t &getManualBinX_Control() const { return std::get<53>(values_); }
    	inline void setManualBinX_Control(const hq_float32_t &_value) { std::get<53>(values_) = _value; }
    	inline const hq_float32_t &getSBRRx_Control() const { return std::get<54>(values_); }
    	inline void setSBRRx_Control(const hq_float32_t &_value) { std::get<54>(values_) = _value; }
    	inline const hq_float32_t &getSBRsmoothing_Control() const { return std::get<55>(values_); }
    	inline void setSBRsmoothing_Control(const hq_float32_t &_value) { std::get<55>(values_) = _value; }
    	inline const hq_float32_t &getSBRsens_Control() const { return std::get<56>(values_); }
    	inline void setSBRsens_Control(const hq_float32_t &_value) { std::get<56>(values_) = _value; }
    	inline const hq_float32_t &getBWELimit_Control() const { return std::get<57>(values_); }
    	inline void setBWELimit_Control(const hq_float32_t &_value) { std::get<57>(values_) = _value; }
    	inline const hq_float32_t &getSpeechRx_Control() const { return std::get<58>(values_); }
    	inline void setSpeechRx_Control(const hq_float32_t &_value) { std::get<58>(values_) = _value; }
    	inline const hq_float32_t &getSpeechMode_Control() const { return std::get<59>(values_); }
    	inline void setSpeechMode_Control(const hq_float32_t &_value) { std::get<59>(values_) = _value; }
    	inline const hq_float32_t &getBWSensitivity_Control() const { return std::get<60>(values_); }
    	inline void setBWSensitivity_Control(const hq_float32_t &_value) { std::get<60>(values_) = _value; }
    	inline const hq_float32_t &getDecorrMix_Control() const { return std::get<61>(values_); }
    	inline void setDecorrMix_Control(const hq_float32_t &_value) { std::get<61>(values_) = _value; }
    	inline const hq_float32_t &getDecorrMix0_Control() const { return std::get<62>(values_); }
    	inline void setDecorrMix0_Control(const hq_float32_t &_value) { std::get<62>(values_) = _value; }
    	inline const hq_float32_t &getMonoThreshold() const { return std::get<63>(values_); }
    	inline void setMonoThreshold(const hq_float32_t &_value) { std::get<63>(values_) = _value; }
    	inline const hq_float32_t &getMONO_SENS() const { return std::get<64>(values_); }
    	inline void setMONO_SENS(const hq_float32_t &_value) { std::get<64>(values_) = _value; }
    	inline const hq_float32_t &getM2S_RATE() const { return std::get<65>(values_); }
    	inline void setM2S_RATE(const hq_float32_t &_value) { std::get<65>(values_) = _value; }
    	inline const hq_float32_t &getS2M_RATE() const { return std::get<66>(values_); }
    	inline void setS2M_RATE(const hq_float32_t &_value) { std::get<66>(values_) = _value; }
    	inline const hq_float32_t &getSpeech_SCORE() const { return std::get<67>(values_); }
    	inline void setSpeech_SCORE(const hq_float32_t &_value) { std::get<67>(values_) = _value; }
    	inline const hq_float32_t &getInput_LEVEL() const { return std::get<68>(values_); }
    	inline void setInput_LEVEL(const hq_float32_t &_value) { std::get<68>(values_) = _value; }
    	inline const hq_float32_t &getMONO_PROB() const { return std::get<69>(values_); }
    	inline void setMONO_PROB(const hq_float32_t &_value) { std::get<69>(values_) = _value; }
    	inline bool operator==(const hq_ClariFiStruct_param& _other) const {
                return (getWrittenBack() == _other.getWrittenBack() && getNeedUpdate() == _other.getNeedUpdate() && getMODE() == _other.getMODE() && getSBR_MODE() == _other.getSBR_MODE() && getVERB_LF() == _other.getVERB_LF() && getVERB_HF() == _other.getVERB_HF() && getSourceBitRate_Control() == _other.getSourceBitRate_Control() && getVocalAir_Control() == _other.getVocalAir_Control() && getVocalAir0_Control() == _other.getVocalAir0_Control() && getVocalAir50_Control() == _other.getVocalAir50_Control() && getVocalAirK_Control() == _other.getVocalAirK_Control() && getVocAirLimit_Control() == _other.getVocAirLimit_Control() && getASW_Control() == _other.getASW_Control() && getASW0_Control() == _other.getASW0_Control() && getDirectSignalGain_Control() == _other.getDirectSignalGain_Control() && getOctaveFullBWExtGain_Control() == _other.getOctaveFullBWExtGain_Control() && getOctaveFullBWExtGain0_Control() == _other.getOctaveFullBWExtGain0_Control() && getOctaveFullBWExtGain50_Control() == _other.getOctaveFullBWExtGain50_Control() && getOctaveFullBWExtGainK_Control() == _other.getOctaveFullBWExtGainK_Control() && getHardPanBoostGain_Control() == _other.getHardPanBoostGain_Control() && getHardPanBoostGain0_Control() == _other.getHardPanBoostGain0_Control() && getVerbFillGain_Control() == _other.getVerbFillGain_Control() && getVerbFillGain0_Control() == _other.getVerbFillGain0_Control() && getDrumFillGain_Control() == _other.getDrumFillGain_Control() && getDrumFillGain0_Control() == _other.getDrumFillGain0_Control() && getDrumFillGain50_Control() == _other.getDrumFillGain50_Control() && getDrumFillGainK_Control() == _other.getDrumFillGainK_Control() && getMaskSpread_Control() == _other.getMaskSpread_Control() && getMaskSpread0_Control() == _other.getMaskSpread0_Control() && getMaskSpread50_Control() == _other.getMaskSpread50_Control() && getMaskSpreadK_Control() == _other.getMaskSpreadK_Control() && getScaleGain_Control() == _other.getScaleGain_Control() && getSDBypass_Control() == _other.getSDBypass_Control() && getSDMode_Control() == _other.getSDMode_Control() && getIntensity_Control() == _other.getIntensity_Control() && getSoftness_Control() == _other.getSoftness_Control() && getSoftness0_Control() == _other.getSoftness0_Control() && getSoftness50_Control() == _other.getSoftness50_Control() && getSoftnessK_Control() == _other.getSoftnessK_Control() && getTransBoost_Control() == _other.getTransBoost_Control() && getTransBoost0_Control() == _other.getTransBoost0_Control() && getBassOverallBoost_Control() == _other.getBassOverallBoost_Control() && getBassOverallBoost0_Control() == _other.getBassOverallBoost0_Control() && getLimiter_Control() == _other.getLimiter_Control() && getSourceType_Control() == _other.getSourceType_Control() && getGapThresh_Control() == _other.getGapThresh_Control() && getSNR_Control() == _other.getSNR_Control() && getLevelDiff_Control() == _other.getLevelDiff_Control() && getVerbBWE_Control() == _other.getVerbBWE_Control() && getVerbBWE0_Control() == _other.getVerbBWE0_Control() && getDirac_Control() == _other.getDirac_Control() && getDirac0_Control() == _other.getDirac0_Control() && getForceBinX_Control() == _other.getForceBinX_Control() && getManualBinX_Control() == _other.getManualBinX_Control() && getSBRRx_Control() == _other.getSBRRx_Control() && getSBRsmoothing_Control() == _other.getSBRsmoothing_Control() && getSBRsens_Control() == _other.getSBRsens_Control() && getBWELimit_Control() == _other.getBWELimit_Control() && getSpeechRx_Control() == _other.getSpeechRx_Control() && getSpeechMode_Control() == _other.getSpeechMode_Control() && getBWSensitivity_Control() == _other.getBWSensitivity_Control() && getDecorrMix_Control() == _other.getDecorrMix_Control() && getDecorrMix0_Control() == _other.getDecorrMix0_Control() && getMonoThreshold() == _other.getMonoThreshold() && getMONO_SENS() == _other.getMONO_SENS() && getM2S_RATE() == _other.getM2S_RATE() && getS2M_RATE() == _other.getS2M_RATE() && getSpeech_SCORE() == _other.getSpeech_SCORE() && getInput_LEVEL() == _other.getInput_LEVEL() && getMONO_PROB() == _other.getMONO_PROB());
        }
    	inline bool operator!=(const hq_ClariFiStruct_param &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: parameter of channel gain function.
     */
    struct hq_channelGainStruct_param : CommonAPI::Struct<hq_uInt8_t, hq_uInt8_t, hq_channelGainStruct_s_L> {
    	
    	hq_channelGainStruct_param() {
    	}
    	hq_channelGainStruct_param(const hq_uInt8_t &_activateChlIndex, const hq_uInt8_t &_channelNum, const hq_channelGainStruct_s_L &_channelGainStructArry)
    	{
    		std::get<0>(values_) = _activateChlIndex;
    		std::get<1>(values_) = _channelNum;
    		std::get<2>(values_) = _channelGainStructArry;
    	}
    	/**
    	 * description: the index of one channel which's parameter need to be sended. If all channel
    	 *   need to be sended, the value is 0xff.
    	 */
    	inline const hq_uInt8_t &getActivateChlIndex() const { return std::get<0>(values_); }
    	inline void setActivateChlIndex(const hq_uInt8_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: this is the sum of channel
    	 */
    	inline const hq_uInt8_t &getChannelNum() const { return std::get<1>(values_); }
    	inline void setChannelNum(const hq_uInt8_t &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: the array of channel gain struct which can save all channels' parameter.
    	 */
    	inline const hq_channelGainStruct_s_L &getChannelGainStructArry() const { return std::get<2>(values_); }
    	inline void setChannelGainStructArry(const hq_channelGainStruct_s_L &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const hq_channelGainStruct_param& _other) const {
                return (getActivateChlIndex() == _other.getActivateChlIndex() && getChannelNum() == _other.getChannelNum() && getChannelGainStructArry() == _other.getChannelGainStructArry());
        }
    	inline bool operator!=(const hq_channelGainStruct_param &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: This struct describes the attributes of EQ filter
     */
    struct eq_filter_ford_s : CommonAPI::Struct<uint8_t, uint8_t, uint8_t, uint8_t, uint8_t, uint8_t> {
    	
    	eq_filter_ford_s() {
    	}
    	eq_filter_ford_s(const uint8_t &_precision, const uint8_t &_chIndex, const uint8_t &_filterIndex, const uint8_t &_coefficientDataLength, const uint8_t &_filterType, const uint8_t &_filterOrder)
    	{
    		std::get<0>(values_) = _precision;
    		std::get<1>(values_) = _chIndex;
    		std::get<2>(values_) = _filterIndex;
    		std::get<3>(values_) = _coefficientDataLength;
    		std::get<4>(values_) = _filterType;
    		std::get<5>(values_) = _filterOrder;
    	}
    	/**
    	 * description: This is precision.
    	 */
    	inline const uint8_t &getPrecision() const { return std::get<0>(values_); }
    	inline void setPrecision(const uint8_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: This is channel index.
    	 */
    	inline const uint8_t &getChIndex() const { return std::get<1>(values_); }
    	inline void setChIndex(const uint8_t &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: This is filter index.
    	 */
    	inline const uint8_t &getFilterIndex() const { return std::get<2>(values_); }
    	inline void setFilterIndex(const uint8_t &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: This is length of the coefficientData.
    	 */
    	inline const uint8_t &getCoefficientDataLength() const { return std::get<3>(values_); }
    	inline void setCoefficientDataLength(const uint8_t &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: This is filter type.
    	 */
    	inline const uint8_t &getFilterType() const { return std::get<4>(values_); }
    	inline void setFilterType(const uint8_t &_value) { std::get<4>(values_) = _value; }
    	/**
    	 * description: This is filter order.
    	 */
    	inline const uint8_t &getFilterOrder() const { return std::get<5>(values_); }
    	inline void setFilterOrder(const uint8_t &_value) { std::get<5>(values_) = _value; }
    	inline bool operator==(const eq_filter_ford_s& _other) const {
                return (getPrecision() == _other.getPrecision() && getChIndex() == _other.getChIndex() && getFilterIndex() == _other.getFilterIndex() && getCoefficientDataLength() == _other.getCoefficientDataLength() && getFilterType() == _other.getFilterType() && getFilterOrder() == _other.getFilterOrder());
        }
    	inline bool operator!=(const eq_filter_ford_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: This struct describes the attributes of limiter
     */
    struct eq_limiter_ford_s : CommonAPI::Struct<uint8_t, uint8_t> {
    	
    	eq_limiter_ford_s() {
    	}
    	eq_limiter_ford_s(const uint8_t &_limiterindex, const uint8_t &_limiterDataLength)
    	{
    		std::get<0>(values_) = _limiterindex;
    		std::get<1>(values_) = _limiterDataLength;
    	}
    	/**
    	 * description: This is limiter index.
    	 */
    	inline const uint8_t &getLimiterindex() const { return std::get<0>(values_); }
    	inline void setLimiterindex(const uint8_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: This is length of the limiterData.
    	 */
    	inline const uint8_t &getLimiterDataLength() const { return std::get<1>(values_); }
    	inline void setLimiterDataLength(const uint8_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const eq_limiter_ford_s& _other) const {
                return (getLimiterindex() == _other.getLimiterindex() && getLimiterDataLength() == _other.getLimiterDataLength());
        }
    	inline bool operator!=(const eq_limiter_ford_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };



static inline const char* getTypeCollectionName() {
    static const char* typeCollectionName = "org.genivi.am_t";
    return typeCollectionName;
}

inline CommonAPI::Version getTypeCollectionVersion() {
    return CommonAPI::Version(3, 32);
}

}; // struct am_t

} // namespace genivi
} // namespace org
} // namespace v3

namespace CommonAPI {
}


namespace std {
    //Hash for am_Availability_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_Availability_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_Availability_e& am_Availability_e) const {
            return static_cast<int32_t>(am_Availability_e);
        }
    };
    //Hash for am_HotSink_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_HotSink_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_HotSink_e& am_HotSink_e) const {
            return static_cast<int32_t>(am_HotSink_e);
        }
    };
    //Hash for am_ConnectionState_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_ConnectionState_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_ConnectionState_e& am_ConnectionState_e) const {
            return static_cast<int32_t>(am_ConnectionState_e);
        }
    };
    //Hash for am_sourceID_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_sourceID_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_sourceID_e& am_sourceID_e) const {
            return static_cast<int32_t>(am_sourceID_e);
        }
    };
    //Hash for am_sourceClassID_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_sourceClassID_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_sourceClassID_e& am_sourceClassID_e) const {
            return static_cast<int32_t>(am_sourceClassID_e);
        }
    };
    //Hash for am_sinkID_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_sinkID_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_sinkID_e& am_sinkID_e) const {
            return static_cast<int32_t>(am_sinkID_e);
        }
    };
    //Hash for am_EQ_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_EQ_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_EQ_e& am_EQ_e) const {
            return static_cast<int32_t>(am_EQ_e);
        }
    };
    //Hash for am_ConnectionMode_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_ConnectionMode_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_ConnectionMode_e& am_ConnectionMode_e) const {
            return static_cast<int32_t>(am_ConnectionMode_e);
        }
    };
    //Hash for am_USBAutoPlay_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_USBAutoPlay_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_USBAutoPlay_e& am_USBAutoPlay_e) const {
            return static_cast<int32_t>(am_USBAutoPlay_e);
        }
    };
    //Hash for am_VolumeUpdate_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_VolumeUpdate_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_VolumeUpdate_e& am_VolumeUpdate_e) const {
            return static_cast<int32_t>(am_VolumeUpdate_e);
        }
    };
    //Hash for am_EmergencyCAll_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_EmergencyCAll_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_EmergencyCAll_e& am_EmergencyCAll_e) const {
            return static_cast<int32_t>(am_EmergencyCAll_e);
        }
    };
    //Hash for am_Clarifi_control_Type_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_Clarifi_control_Type_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_Clarifi_control_Type_e& am_Clarifi_control_Type_e) const {
            return static_cast<int32_t>(am_Clarifi_control_Type_e);
        }
    };
    //Hash for am_loudness_Type_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_loudness_Type_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_loudness_Type_e& am_loudness_Type_e) const {
            return static_cast<int32_t>(am_loudness_Type_e);
        }
    };
    //Hash for am_avcMode_Type_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_avcMode_Type_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_avcMode_Type_e& am_avcMode_Type_e) const {
            return static_cast<int32_t>(am_avcMode_Type_e);
        }
    };
    //Hash for am_MyKey_Type_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_MyKey_Type_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_MyKey_Type_e& am_MyKey_Type_e) const {
            return static_cast<int32_t>(am_MyKey_Type_e);
        }
    };
    //Hash for am_ESE_Type_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_ESE_Type_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_ESE_Type_e& am_ESE_Type_e) const {
            return static_cast<int32_t>(am_ESE_Type_e);
        }
    };
    //Hash for am_Occupancy_Mode_Type_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_Occupancy_Mode_Type_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_Occupancy_Mode_Type_e& am_Occupancy_Mode_Type_e) const {
            return static_cast<int32_t>(am_Occupancy_Mode_Type_e);
        }
    };
    //Hash for am_Android_Auto_Request_Type_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_Android_Auto_Request_Type_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_Android_Auto_Request_Type_e& am_Android_Auto_Request_Type_e) const {
            return static_cast<int32_t>(am_Android_Auto_Request_Type_e);
        }
    };
    //Hash for am_Android_Auto_Response_Type_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_Android_Auto_Response_Type_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_Android_Auto_Response_Type_e& am_Android_Auto_Response_Type_e) const {
            return static_cast<int32_t>(am_Android_Auto_Response_Type_e);
        }
    };
    //Hash for am_Audio_Off_Type_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_Audio_Off_Type_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_Audio_Off_Type_e& am_Audio_Off_Type_e) const {
            return static_cast<int32_t>(am_Audio_Off_Type_e);
        }
    };
    //Hash for am_CustomSoundPropertyType_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_CustomSoundPropertyType_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_CustomSoundPropertyType_e& am_CustomSoundPropertyType_e) const {
            return static_cast<int32_t>(am_CustomSoundPropertyType_e);
        }
    };
    //Hash for am_SystemPropertyType_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_SystemPropertyType_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_SystemPropertyType_e& am_SystemPropertyType_e) const {
            return static_cast<int32_t>(am_SystemPropertyType_e);
        }
    };
    //Hash for am_Last_Source_Type_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_Last_Source_Type_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_Last_Source_Type_e& am_Last_Source_Type_e) const {
            return static_cast<int32_t>(am_Last_Source_Type_e);
        }
    };
    //Hash for am_DomainState_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_DomainState_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_DomainState_e& am_DomainState_e) const {
            return static_cast<int32_t>(am_DomainState_e);
        }
    };
    //Hash for am_EarlyDataType_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_EarlyDataType_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_EarlyDataType_e& am_EarlyDataType_e) const {
            return static_cast<int32_t>(am_EarlyDataType_e);
        }
    };
    //Hash for am_Error_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_Error_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_Error_e& am_Error_e) const {
            return static_cast<int32_t>(am_Error_e);
        }
    };
    //Hash for am_MuteState_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_MuteState_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_MuteState_e& am_MuteState_e) const {
            return static_cast<int32_t>(am_MuteState_e);
        }
    };
    //Hash for am_InterruptState_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_InterruptState_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_InterruptState_e& am_InterruptState_e) const {
            return static_cast<int32_t>(am_InterruptState_e);
        }
    };
    //Hash for am_VolumeType_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_VolumeType_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_VolumeType_e& am_VolumeType_e) const {
            return static_cast<int32_t>(am_VolumeType_e);
        }
    };
    //Hash for am_NotificationStatus_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_NotificationStatus_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_NotificationStatus_e& am_NotificationStatus_e) const {
            return static_cast<int32_t>(am_NotificationStatus_e);
        }
    };
    //Hash for am_Handle_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_Handle_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_Handle_e& am_Handle_e) const {
            return static_cast<int32_t>(am_Handle_e);
        }
    };
    //Hash for am_SourceState_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_SourceState_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_SourceState_e& am_SourceState_e) const {
            return static_cast<int32_t>(am_SourceState_e);
        }
    };
    //Hash for am_RoutingReady_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_RoutingReady_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_RoutingReady_e& am_RoutingReady_e) const {
            return static_cast<int32_t>(am_RoutingReady_e);
        }
    };
    //Hash for am_AvailabilityReason_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_AvailabilityReason_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_AvailabilityReason_e& am_AvailabilityReason_e) const {
            return static_cast<int32_t>(am_AvailabilityReason_e);
        }
    };
    //Hash for am_DiagnosticSpeakerMask_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_DiagnosticSpeakerMask_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_DiagnosticSpeakerMask_e& am_DiagnosticSpeakerMask_e) const {
            return static_cast<int32_t>(am_DiagnosticSpeakerMask_e);
        }
    };
    //Hash for am_DiagnosticTestToneType_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_DiagnosticTestToneType_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_DiagnosticTestToneType_e& am_DiagnosticTestToneType_e) const {
            return static_cast<int32_t>(am_DiagnosticTestToneType_e);
        }
    };
}


// Compatibility
namespace v3_32 = v3;

#endif // V3_ORG_GENIVI_am_t_HPP_
