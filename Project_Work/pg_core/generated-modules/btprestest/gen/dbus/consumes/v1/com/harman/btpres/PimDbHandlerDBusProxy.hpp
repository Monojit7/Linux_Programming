/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Thu Sep 22 00:23:23 IST 2016
*/
#ifndef V1_COM_HARMAN_BTPRES_Pim_Db_Handler_DBUS_PROXY_HPP_
#define V1_COM_HARMAN_BTPRES_Pim_Db_Handler_DBUS_PROXY_HPP_

#include <v1/com/harman/btpres/PimDbHandlerProxyBase.hpp>
#include "v1/com/harman/btpres/PimDbHandlerDBusDeployment.hpp"

#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/DBus/DBusAddress.hpp>
#include <CommonAPI/DBus/DBusFactory.hpp>
#include <CommonAPI/DBus/DBusProxy.hpp>
#include <CommonAPI/DBus/DBusAddressTranslator.hpp>
#include <CommonAPI/DBus/DBusAttribute.hpp>
#include <CommonAPI/DBus/DBusEvent.hpp>
#include <CommonAPI/Types.hpp>
#include <CommonAPI/DBus/DBusSelectiveEvent.hpp>

#undef COMMONAPI_INTERNAL_COMPILATION

#include <string>

namespace v1 {
namespace com {
namespace harman {
namespace btpres {

class PimDbHandlerDBusProxy
    : virtual public PimDbHandlerProxyBase, 
      virtual public CommonAPI::DBus::DBusProxy {
public:
    PimDbHandlerDBusProxy(
        const CommonAPI::DBus::DBusAddress &_address,
        const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection);

    virtual ~PimDbHandlerDBusProxy() { }

    virtual ContactNameOrderAttribute& getContactNameOrderAttribute();
    virtual DeviceListAttribute& getDeviceListAttribute();

    virtual SessionQueryUpdateSelectiveEvent& getSessionQueryUpdateSelectiveEvent();
    virtual SessionQueryWindowUpdateSelectiveEvent& getSessionQueryWindowUpdateSelectiveEvent();
    virtual SessionClosedSelectiveEvent& getSessionClosedSelectiveEvent();
    virtual UnreadMissedCallEvent& getUnreadMissedCallEvent();
    virtual NewCallListEvent& getNewCallListEvent();
    virtual SMSNotificationEvent& getSMSNotificationEvent();

    /**
     * description: Opens a session for the client communication. This session will be used
     *   internally to uniquely identify a client, and to maintain client specific
     *   caches.
                         The client need not create a new session for
     *   every request, this is rather used to identify different instances of clients.
     *     
                         
           returns: sessionID: Session identifier
     *   allocated to the client.
     */
    virtual void openSession(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, uint8_t &_sessionID, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_ErrorCode, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> openSessionAsync(const std::string &_inAddress, OpenSessionAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: Close a client session and release all associated resources.
     * param: sessionID: The Session ID to close.
     */
    virtual void closeSession(const uint8_t &_sessionID, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_ErrorCode, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> closeSessionAsync(const uint8_t &_sessionID, CloseSessionAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: Sets a session query. This api handles all requests to fetch Phonebook results,
     *   database searches, etc. 
                         As an example. If the HMI wanted
     *   to fetch a list of all contacts. The filterID's' and filter's' will be empty,
     *   and the result type would be set to Required field list.
     * param: filterIDs: The previously communicated numeric identifiers of the different
     *   filter categories.
     * param: filters: The string filters which should be applied to the result.
     * param: resultType: The data which is expected from the query.
     * param: sessionID: Session ID obtained from OpenSession.
     * param: databaseType: Related database for this sessionquery.
     * param: RequiredField: List of required field , if default is set browsing item will be
     *   sent with default avlues based on config
     * param: resetPrevious: Whether to use old history or not.If true treat this as a new
     *   session query, do not use any old selection history.
     * param: AutoUpdateEnabled: This is applicable for result sets which might update
     *   dynamically,Call stack or Fav list
              							 
           returns:
     *   numResults: The number of records matching the search criteria.
          
     *   returns: SessionQueryID:The sessionQueryID allotted.This uniquely identifies a
     *   particular session query/filter for retrieving data in a session and it has to
     *   be passed 
                                    for furthur setting the
     *   sessionQuery window and retrieving the contents of that window.
     */
    virtual void setSessionQuery(const uint8_t &_sessionID, const ::v1::com::harman::btpres::BTPresTypes::eDatabaseType &_databaseType, const ::v1::com::harman::btpres::BTPresTypes::phonebookResultMap &_filterIDs, const ::v1::com::harman::btpres::BTPresTypes::filterMap &_filters, const ::v1::com::harman::btpres::BTPresTypes::requiredFieldMap &_RequiredField, const bool &_resetPrevious, const bool &_AutoUpdateEnabled, const bool &_AlphaJumpTable, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, uint32_t &_numResults, uint8_t &_sessionQueryID, uint8_t &_unreadCount, ::v1::com::harman::btpres::BTPresTypes::alphaJumpList &_alphaList, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> setSessionQueryAsync(const uint8_t &_sessionID, const ::v1::com::harman::btpres::BTPresTypes::eDatabaseType &_databaseType, const ::v1::com::harman::btpres::BTPresTypes::phonebookResultMap &_filterIDs, const ::v1::com::harman::btpres::BTPresTypes::filterMap &_filters, const ::v1::com::harman::btpres::BTPresTypes::requiredFieldMap &_RequiredField, const bool &_resetPrevious, const bool &_AutoUpdateEnabled, const bool &_AlphaJumpTable, SetSessionQueryAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: Essentially re-initializes a session and stops all background tasks.
     * param: sessionID: The Session ID alloted.
     */
    virtual void cancelSessionQuery(const uint8_t &_sessionID, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> cancelSessionQueryAsync(const uint8_t &_sessionID, CancelSessionQueryAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: Ask presentation control to fetch the desired set of entries for a particular
     *   session query. This call does not block for the result to complete, and will
     *   override
                         the last request given to Pres Ctrl.
     * param: sessionID: The Session ID alloted.
     * param: sessionQueryID: The sessionQueryID allotted.This uniquely identifies a
     *   particular session query/filter for retrieving data in a session and it has to
     *   be passed 
                                   for furthur setting the sessionQuery
     *   window and retrieving the contents of that window.
     * param: startIndex: The index to start fetching.
     * param: numItems: The number of items to fetch.     
             
           returns:
     *   windowID: A unique identifier for the client to track data responses to the
     *   queries.
     */
    virtual void setSessionQueryWindow(const uint8_t &_sessionID, const uint8_t &_sessionQueryID, const uint16_t &_startIndex, const uint8_t &_numItems, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> setSessionQueryWindowAsync(const uint8_t &_sessionID, const uint8_t &_sessionQueryID, const uint16_t &_startIndex, const uint8_t &_numItems, SetSessionQueryWindowAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: This method is used for inserting contacts to Favourite list 
                     
     *      Hence the only acceptable value for "database" parameter is "ab".
     * param: inAddress: BD Address of Device
     * param: databaseType: Different database of Pim, Only Fav is allowed
     * param: requestID: Different type of user initiated DB operation
     * param: itemDetails: This list is a union of contactID list, NewPhonebook entry,
     *   SMSTemplateID list, SMStemplate
    	 		     
           returns: This method returns
     *   errorcode
     */
    virtual void dbOperation(const std::string &_inAddress, const ::v1::com::harman::btpres::BTPresTypes::eDatabaseType &_databaseType, const ::v1::com::harman::btpres::BTPresTypes::eDbOperationId &_requestID, const ::v1::com::harman::btpres::BTPresTypes::InsertItems &_itemDetails, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> dbOperationAsync(const std::string &_inAddress, const ::v1::com::harman::btpres::BTPresTypes::eDatabaseType &_databaseType, const ::v1::com::harman::btpres::BTPresTypes::eDbOperationId &_requestID, const ::v1::com::harman::btpres::BTPresTypes::InsertItems &_itemDetails, DbOperationAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: This API can be used to get Contact Name by contactID
     * param: inAddress: BD Address of Device
     * param: databaseType: Different database of Pim.Currently only available for "pb" or
     *   "ab"
     * param: contactID: contactID for which contact details should be extracted
     * param: fieldList: Required filedlist using bit masking ()
    	 		     
           returns:	  
     *    phonebookEntry which will contain all the field
     */
    virtual void getContactsByID(const std::string &_inAddress, const ::v1::com::harman::btpres::BTPresTypes::eDatabaseType &_databaseType, const uint16_t &_contactID, const ::v1::com::harman::btpres::BTPresTypes::phonebookResultMap &_FieldList, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, ::v1::com::harman::btpres::BTPresTypes::phonebookEntry &_detailedContact, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> getContactsByIDAsync(const std::string &_inAddress, const ::v1::com::harman::btpres::BTPresTypes::eDatabaseType &_databaseType, const uint16_t &_contactID, const ::v1::com::harman::btpres::BTPresTypes::phonebookResultMap &_FieldList, GetContactsByIDAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: This API is used to get the full details of the SMS; this takes a unique id as
     *   input, which is received from the signal
     * param: inAddress: BD Address of Device
     * param: smsId: Unique id for SMS that is returned as part of the signal (multiple uid’s
     *   can be sent, separated)
    	 		     
           returns: This method returns SMS entry
     */
    virtual void getSMSById(const std::string &_inAddress, const int64_t &_smsId, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, ::v1::com::harman::btpres::BTPresTypes::smsEntry &_sms, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> getSMSByIdAsync(const std::string &_inAddress, const int64_t &_smsId, GetSMSByIdAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: This API can be used to get the following details on either phonebook 
            
     *               1.	The next valid characters mask that match the input string.
       
     *                    2.	The count of the names that matched the input string.
        
     *                   3.	The index of the first match of the input string sorted by
     *   givenName column. (This index can be used in getItems API to query for the
     *   details but the same sort criteria need to be applied).
     * param: inAddress: BD Address of Device
     * param: databaseType: Different database of Pim. Currently only available for Pb or ab
     * param: inputName: String to be searched
     * param: sortOrder: ascending or descending
     * param: condition: either or all based on notnullcolumnList 
           	 		     
          
     *   returns:      contactsCount:The count of the names that matched the input
     *   string.
           returns:      index:The index of the first match of the input
     *   string sorted by formattedName column.
           returns:      charactersMask:The
     *   next valid characters mask that match the input string.
           returns:     
     *   firstMatch:The “formattedName” of the first matched contact
     */
    virtual void getNextValidCharacters(const std::string &_inAddress, const ::v1::com::harman::btpres::BTPresTypes::eDatabaseType &_databaseType, const std::string &_inputName, const std::string &_sortOrder, const std::string &_condition, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, uint16_t &_contactsCount, uint16_t &_index, std::string &_charactersMask, std::string &_firstMatch, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> getNextValidCharactersAsync(const std::string &_inAddress, const ::v1::com::harman::btpres::BTPresTypes::eDatabaseType &_databaseType, const std::string &_inputName, const std::string &_sortOrder, const std::string &_condition, GetNextValidCharactersAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: This API is used to send the SMS to the destined number.
     * param: inAddress: BD Address of Device
     * param: destinationNumber: This indicates destination number of the SMS
     * param: smsBody: Describes the body of SMS to be sent
    	 		     
           returns:	This
     *   methods return success or failure
           returns: contactName: Contact Name to
     *   which SMS is sent
     */
    virtual void sendSMSByTemplateID(const std::string &_inAddress, const std::string &_destinationNumber, const uint8_t &_TemplateID, const std::string &_smsBody, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, std::string &_contactName, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> sendSMSByTemplateIDAsync(const std::string &_inAddress, const std::string &_destinationNumber, const uint8_t &_TemplateID, const std::string &_smsBody, SendSMSByTemplateIDAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: This API is used to set the status of a sms (as READ/UNREAD).
     * param: inAddress: BD Address of Device
     * param: smsId: Unique sms identifier
     * param: read_status: The status value that needs to be set. The valid values are “READ”
     *   or “UNREAD”
    	 		     
           returns: This method returns errorcode
     */
    virtual void setSMSReadStatus(const std::string &_inAddress, const int64_t &_smsId, const bool &_sms_read_status, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> setSMSReadStatusAsync(const std::string &_inAddress, const int64_t &_smsId, const bool &_sms_read_status, SetSMSReadStatusAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: This method is used to set the sorted name order.
     * param: inAddress: BD Address of Device (Considered only if project support device
     *   specific sorting order)
     * param: contact Name order
     */
    virtual void setFormattedNameOrder(const std::string &_inAddress, const ::v1::com::harman::btpres::BTPresTypes::eContactNameOredr &_contactNameOrder, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> setFormattedNameOrderAsync(const std::string &_inAddress, const ::v1::com::harman::btpres::BTPresTypes::eContactNameOredr &_contactNameOrder, SetFormattedNameOrderAsyncCallback _callback, const CommonAPI::CallInfo *_info);


    virtual void getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const;

private:
   
    class DBuscontactNameOrder_Attribute : public CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusReadonlyAttribute<ContactNameOrderAttribute>> {
    public:
    template <typename... _A>
    	DBuscontactNameOrder_Attribute(DBusProxy &_proxy,
    		_A ... arguments)
    		: CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusReadonlyAttribute<ContactNameOrderAttribute>>(
    			_proxy, arguments...) {}
    };
    DBuscontactNameOrder_Attribute contactNameOrder_;
    CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusReadonlyAttribute<DeviceListAttribute, ::v1::com::harman::btpres::BTPresTypes_::pimPropertiesListDeployment_t>> deviceList_;

    CommonAPI::DBus::DBusSelectiveEvent<SessionQueryUpdateSelectiveEvent, CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment>, CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment>, CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment>, CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment>, CommonAPI::Deployable<::v1::com::harman::btpres::BTPresTypes::alphaJumpList, ::v1::com::harman::btpres::BTPresTypes_::alphaJumpListDeployment_t>> sessionQueryUpdateSelective_;
    CommonAPI::DBus::DBusSelectiveEvent<SessionQueryWindowUpdateSelectiveEvent, CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment>, CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment>, CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment>, CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment>, CommonAPI::Deployable<::v1::com::harman::btpres::BTPresTypes::phonebook, ::v1::com::harman::btpres::BTPresTypes_::phonebookDeployment_t>> sessionQueryWindowUpdateSelective_;
    CommonAPI::DBus::DBusSelectiveEvent<SessionClosedSelectiveEvent, CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment>, CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment>, CommonAPI::Deployable<::v1::com::harman::btpres::BTPresTypes::eErrorType, CommonAPI::EmptyDeployment>> sessionClosedSelective_;
    CommonAPI::DBus::DBusEvent<UnreadMissedCallEvent, CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment>, CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment>, CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment>, CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment>> unreadMissedCall_;
    CommonAPI::DBus::DBusEvent<NewCallListEvent, CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment>, CommonAPI::Deployable<::v1::com::harman::btpres::BTPresTypes::callstackEntry, ::v1::com::harman::btpres::BTPresTypes_::callstackEntryDeployment_t>> newCallList_;
    CommonAPI::DBus::DBusEvent<SMSNotificationEvent, CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment>, CommonAPI::Deployable<int64_t, CommonAPI::EmptyDeployment>, CommonAPI::Deployable<::v1::com::harman::btpres::BTPresTypes::eMsgNotification, CommonAPI::EmptyDeployment>> sMSNotification_;

};

} // namespace btpres
} // namespace harman
} // namespace com
} // namespace v1

#endif // V1_COM_HARMAN_BTPRES_Pim_Db_Handler_DBUS_PROXY_HPP_

