/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Wed Oct 26 18:16:09 IST 2016
*/
#include <v1/com/harman/mmpres/MediaBrowser.hpp>
#include <v1/com/harman/mmpres/MediaBrowserDBusStubAdapter.hpp>

namespace v1 {
namespace com {
namespace harman {
namespace mmpres {

std::shared_ptr<CommonAPI::DBus::DBusStubAdapter> createMediaBrowserDBusStubAdapter(
                   const CommonAPI::DBus::DBusAddress &_address,
                   const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection,
                   const std::shared_ptr<CommonAPI::StubBase> &_stub) {
    return std::make_shared<MediaBrowserDBusStubAdapter>(_address, _connection, _stub);
}

INITIALIZER(registerMediaBrowserDBusStubAdapter) {
    CommonAPI::DBus::Factory::get()->registerStubAdapterCreateMethod(
    	MediaBrowser::getInterface(), &createMediaBrowserDBusStubAdapter);
}

MediaBrowserDBusStubAdapterInternal::~MediaBrowserDBusStubAdapterInternal() {
    deactivateManagedInstances();
    MediaBrowserDBusStubAdapterHelper::deinit();
}

void MediaBrowserDBusStubAdapterInternal::deactivateManagedInstances() {

}

const char* MediaBrowserDBusStubAdapterInternal::getMethodsDBusIntrospectionXmlData() const {
    static const std::string introspectionData =
        "<method name=\"getInterfaceVersion\">\n"
            "<arg name=\"value\" type=\"uu\" direction=\"out\" />"
        "</method>\n"
        /**
         * description: Will only be posted to the respective listeners if the session query parameters
         *   have changed. 
        					  For example, for externally played back devices, the
         *   number of items in the currently playing list might change.  Will be published
         *   
        					  only if auto update was enabled when setting the query. 
        	      
             
         *      returns  sessionID:      The Session ID alloted.
                 returns 
         *   sessionQueryID: The sessionQueryID allotted.This uniquely identifies a
         *   particular session query/filter for retrieving data in a session and it has to
         *   be passed 
                                              for furthur setting the
         *   sessionQuery window and retrieving the contents of that window.
                 
            
         *       returns  numItems:		   The updated number of items for the
         *   sessionID/sessionQueryID.
         */
        "<signal name=\"sessionQueryUpdate\">\n"
            "<arg name=\"sessionID\" type=\"u\" />\n"
            "<arg name=\"sessionQueryID\" type=\"u\" />\n"
            "<arg name=\"numResults\" type=\"t\" />\n"
        "</signal>\n"
        /**
         * description: Publishes the query status to all clients. The client can get the data once the
         *   query is "finished"
        	
        	     returns  sessionID: 	   The Session ID alloted.
          
         *         returns  sessionQueryID:  The sessionQueryID allotted.This uniquely
         *   identifies a particular session query/filter for retrieving data in a session
         *   and it has to be passed 
                                              for furthur
         *   setting the sessionQuery window and retrieving the contents of that window.
          
         *       
                 returns  eQueryStatus:    query status of the window update.
           
         *        returns  startIndex:	   The index to start fetching.  
                 returns 
         *   numItems:		   The number of items to fetch.
                 returns  itemList:       
         *    List of tMetadataItems.
                 
                 returns
         *   windowContainsCurrentlyPlayingTrack: This will be true if one of the
         *   tMetadataItems is the currently playing track.
                
                 returns
         *   itemIndexTobeHighlighted: // index of the item to be highlighted in the
         *   returned nowPlaying list. If the 
                                                    
         *    currently playing item is not part of the returned window, then this will be
         *   assigned 0.
         */
        "<signal name=\"sessionQueryWindowUpdate\">\n"
            "<arg name=\"sessionID\" type=\"u\" />\n"
            "<arg name=\"sessionQueryID\" type=\"u\" />\n"
            "<arg name=\"status\" type=\"i\" />\n"
            "<arg name=\"startIndex\" type=\"t\" />\n"
            "<arg name=\"numItems\" type=\"t\" />\n"
            "<arg name=\"itemList\" type=\"a(tsbbiia{it}a{is}i)\" />\n"
            "<arg name=\"windowContainsCurrentlyPlayingTrack\" type=\"b\" />\n"
            "<arg name=\"itemIndexTobeHighlighted\" type=\"t\" />\n"
        "</signal>\n"
        /**
         * description: Opens a session for the client communication. This session will be used
         *   internally to uniquely identify a client, and to maintain client specific
         *   caches.
        					  The client need not create a new session for every request,
         *   this is rather used to identify different instances of clients.   
                 
         
         *          returns:     sessionID: Session identifier allocated to the client.
         */
        "<method name=\"openSession\">\n"
            "<arg name=\"_sessionID\" type=\"u\" direction=\"out\" />\n"
            "<arg name=\"_result\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: Close a client session and release all associated resources. Once HMI calls
         *   closeSession,they cannot use the same sessionId
        	for furthur browsing. For
         *   this, they have to again invoke a openSession to get a new sessionId for
         *   furthur browsing.
         * param: sessionID: The Session ID to close.
         */
        "<method name=\"closeSession\">\n"
            "<arg name=\"_sessionID\" type=\"u\" direction=\"in\" />\n"
            "<arg name=\"_result\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: Essentially Stops all background tasks in the specified session. But unlike
         *   closeSession, the sessionID
        	 is valid and can be used for furthur browsing.
         * param: sessionID: The Session ID alloted.
         */
        "<method name=\"cancelSession\">\n"
            "<arg name=\"_sessionID\" type=\"u\" direction=\"in\" />\n"
            "<arg name=\"_result\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: Sets a session query. This api handles all requests to fetch metadata browse
         *   results, database searches, file system browse etc. 
        	 	 
        	 	 Note: iF HMI
         *   wants to show the categories like ARTISTS,ALBUMS,FOLDERS,GENRES etc on
         *   clicking browse icon,they need not
        	 	 use the setSessionQuery. They can
         *   instead use the tSlotUpdate broadcast which contains the tDevice structure.In
         *   
        	 	 this, browse capabilities will be provided as a bitmask of different
         *   eMetadataTypes.If HMI is interested in
        	 	 the count of these categories,then
         *   HMI can use the MetadataCountMap which is a map of different
         *   eMetadataCountType.
        	 	 
        	 	 
        	 	 1st Example: 
        	 	 
        	 	 Get a list of all
         *   available artists. The filterID's' and filter's' will be empty, and the result
         *   type would be set to artist id. 
        	 	 Presentation control would return a list
         *   of all available artists / artist id for the medium.
        	 	 sessionQueryType will
         *   be METADATA_BROWSE 
        	 	 
        	 	 2nd Example:
        	 	 
        	 	 Get a list of all available
         *   artists. Also for each artist,get the count of songs.For this, input
         *   parameters will be same as first example
        	 	 but now HMI should pass
         *   metadataCountTypes=eMetadataType::METADATATYPE_SONG.
        	 	 
        	 	 If HMI wants
         *   album count also along with songs count, then metadataCountTypes= bitmask
         *   combination of 
        	 	 eMetadataType::METADATATYPE_SONG +
         *   eMetadataType::METADATATYPE_ALBUM.
        	 	 
        	 	 sessionQueryType will be
         *   METADATA_BROWSE 
        	 	 
        	 	 3rd Example : 
        	 	 
        	 	 Get a list of all available
         *   albums by the artist "Pink Floyd". HMI would know the artist id for "Pink
         *   Floyd" because of the previous returned result. 
        	 	 
        	 	 In the session
         *   query, HMI sets the filterIDMap as:
        	 	 
        	 	
         *   key=eMetadataType::METADATATYPE_ARTIST,value="artist id" for Pink Floyd 
        	 	
         *   
        	 	 resultType=eMetadataType::METADATATYPE_ALBUM. 
        	 	 
        	 	 Presentation
         *   Controller understands what needs to be done here. This can be further
         *   extended by setting
        	 	 artist id and album id returned in the previous steps,
         *   and a query for songs can be done. 
        	 	 
        	 	 sessionQueryType will be
         *   METADATA_BROWSE.
        	 	 
        	 	 Suppose we need the list of songs inside the artist
         *   "Pink Floyd" but for eah song song, we also need to pass the artist,album 
        	 	
         *   and genre values. Then this can be done by providing the "metadataAttributes"
         *   input parameter as a bit mask combination of
         *   eMetadataType::METADATATYPE_ARTIST +
        	 	 eMetadataType::METADATATYPE_ALBUM &
         *   eMetadataType::METADATATYPE_GENRE.
        	 	 
        	 	 Note that metadataAttributes will
         *   be considered only if the resultType="song".
        	 	 
        	 	 4th Example : 
        	 	 
        	 	
         *   Get a list of all available albums by "Pink Floyd", which begin with the
         *   letters "The". 
        	 	 This is same as the 3rd example, but in addition, the
         *   filter "album" must be set to "The"
        	 	 
        	 	 sessionQueryType will be
         *   METADATA_BROWSE 
        	 	 
        	 	 5th example:
        	 	 
        	 	 usage of resetPrevious
         *   parameter.
        	 	 
        	 	 Assume resetPrevious=false:
        	 	 
        	 	 In the first
         *   example,HMI obtained the list of albums for artist "Pink Floyed". Now if HMI
         *   wants list of songs for
        	 	 artist "Pink Floyed", then in the filters,HMi need
         *   not mention anything again. 
        	 	 They can just set
         *   resultype=eMetadataType::METADATATYPE_SONG .
        	 	 
        	 	 Now pres will remember
         *   that artist "Pink Floyd" was already selected. So pres will supply the song
         *   list for artist pink floyd.
        	 	 
        	 	 If resetPrevious=true,pres would not
         *   remeber that Artist Pink Floyd was already selected. In that case,
        	 	 HMI has
         *   to set the filterIDMap again by providing the artist id for pink Floyd.
        	 	 
        	
         *   	 Now in the use cases, where the resultType is
         *   "eMetadataType::METADATATYPE_SONG", if the requirement is to show only AUDIO
        	
         *   	 or VIDEO or both AUDIO + VIDEO, this can be done by setting "ContentMask"
         *   param as a bit mask of "eTitleContentType".
        	 	 
        	 	
         *   eTitleContentType::TITLETYPE_IMAGE will be applicable for filesystem browse.
         *   
        	 	 
        	 	 6th Example:
        	 	 
        	 	 Do a fileSystem or FOLDER browse.This is
         *   applicable for mass storage devices like USB.At any level, we are 
        	 	 allowed
         *   to show both folders, files or playlists depending on project requirements.
        	
         *   	 
        	 	 sessionQueryType will be SESSION_QUERY_FS_BROWSE.
        	 	 
        	 	 First go to
         *   root level and show only folders and files but not playlists. For this, the
         *   filterID's and filters are empty, but the resultType will be 
        	 	 combination
         *   of eMetadataType::METADATATYPE_FOLDER + eMetadataType::METADATATYPE_FILE.With
         *   this query,HMI can get
        	 	 the folders and file at a given level in
         *   filesystem. When HMI gets the individual items, they can check the
         *   eMetadataType
        	 	 of that item to see if it is a file or folder.
        	 	 
        	 	 Now
         *   HMI wants to go inside one more level by selecting a folder obtained in the
         *   previous step.For this,HMI can set the filterID as 
        	 	
         *   key=METADATAID_FOLDER_ID and value=(folder id or item id) of folder
         *   communicated in previous step.
        	 	 
        	 	 If at every level, there is a
         *   requirement to list folders first and only then followed by audio files,image
         *   files etc, then
        	 	 these will be maintained by pres as project specific
         *   config parameters. 
        	 	 
        	 	 Now HMI wants to go inside one of the folders
         *   named "Folder1" listed at the root level.For this,HMI can set the FilterIDMap
         *   as:
        	 	 
        	 	 key: "eMetadataType::METADATATYPE_FOLDER" and value: folder id of
         *   "folder 1" from the result of the first query to 
        	 	       show the root
         *   level contents.
        	 	 
        	 	 Also if HMI wants the level ID (depth of folder) in
         *   file system browse, such as 4th folder depth or fifth folder depth etc,
        	 	
         *   then they can use the sessionQueryID as an indicator of level ID. Each
         *   sessionQueryID will correspond to a
        	 	 particular folder depth in file system
         *   browse.
        	 	 
        	 	 7th example:
        	 	 
        	 	 If HMI wants the list of songs from the
         *   recently played list.
        	 	 
        	 	 The can set the sessionQueryType will be
         *   SESSION_QUERY_RECENTLYPLAYED and resultype=eMetadataType::METADATATYPE_SONG
        	 
         *      other parameters can be empty.
         * param: filterIDs: The previously communicated numeric identifiers of the different
         *   filter categories.
         * param: filters:	 The string filters which should be applied to the result.
         * param: resultType: The data which is expected from the query.
         * param: sessionID: The Session ID alloted.
         * param: mediumID:	 The identifier for the mediastore to query.
         * param: type:		 The type of session query.
         * param: metadataAttributes: [TODO]:Pres ctrl can return the required attributes for
         *   each metadata item based on the 
                                                 
         *   client requirements.This is a bitmask combination of eMetadataType values.
         *   This will be 
                                                  supported only for the
         *   song category.
         * param: metadataCountTypes: Pres Ctrl can count the number of items present in a
         *   subcategory. For example, while retreving a list of all artists, 
                
         *   								  Pres Ctrl can also count how many albums/songs are available for
         *   each artist. (Might be a costly operation depending on Media Type. 
                
         *   								  	Select this option only if really required )
         * param: resetPrevious: Whether to use old history or not. Pres Ctrl has internal
         *   history mechanism. For example
                 							 if in the first session query,
         *   the list of all available artists was obtained.In the 2nd browse level, HMI
         *   requested for
                 							 all albums by a specific artist. If now HMI
         *   wants a list of all songs by the artist, it need not tell the selected artist
         *   
                 							 again. However if this flag is reset, it will override this
         *   behavior.
         * param: AutoUpdateEnabled: 	This is applicable for result sets which might update
         *   dynamically, for example the current playing list for external
                
         *   								devices might update on its own.
         * param: ContentMask      //Bitmask combination of eTitleContentType. Bitmask
         *   combination for what content is expected - Audio/Video/Image.
                
               
         *    returns:	  numResults: The number of records matching the search criteria.
         *   (The number of results might not be accurate for ipod iAP1 like devices)
             
         *      
                 returns      sessionQueryID:The sessionQueryID allotted.This
         *   uniquely identifies a particular session query/filter for retrieving data in a
         *   session and it has to be passed 
                                              for
         *   furthur setting the sessionQuery window and retrieving the contents of that
         *   window.
         */
        "<method name=\"setSessionQuery\">\n"
            "<arg name=\"_sessionID\" type=\"u\" direction=\"in\" />\n"
            "<arg name=\"_mediumID\" type=\"t\" direction=\"in\" />\n"
            "<arg name=\"_filterIDs\" type=\"a{it}\" direction=\"in\" />\n"
            "<arg name=\"_filters\" type=\"a{is}\" direction=\"in\" />\n"
            "<arg name=\"_resultType\" type=\"i\" direction=\"in\" />\n"
            "<arg name=\"_metadataAttributes\" type=\"u\" direction=\"in\" />\n"
            "<arg name=\"_metadataCountTypes\" type=\"u\" direction=\"in\" />\n"
            "<arg name=\"_type\" type=\"i\" direction=\"in\" />\n"
            "<arg name=\"_resetPrevious\" type=\"b\" direction=\"in\" />\n"
            "<arg name=\"_AutoUpdateEnabled\" type=\"b\" direction=\"in\" />\n"
            "<arg name=\"_ContentMask\" type=\"u\" direction=\"in\" />\n"
            "<arg name=\"_result\" type=\"i\" direction=\"out\" />\n"
            "<arg name=\"_numResults\" type=\"t\" direction=\"out\" />\n"
            "<arg name=\"_sessionQueryID\" type=\"u\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: Ask presentation control to fetch the desired set of entries for a particular
         *   session query. This call does not block for the result to complete, and will
         *   override
        					  the last request given to Pres Ctrl.
         * param: sessionID: 	The Session ID alloted.
         * param: sessionQueryID: The sessionQueryID allotted.This uniquely identifies a
         *   particular session query/filter for retrieving data in a session and it has to
         *   be passed 
                                              for furthur setting the
         *   sessionQuery window and retrieving the contents of that window.
         * param: startIndex:	The index to start fetching.
         * param: numItems:		The number of items to fetch.
         */
        "<method name=\"setSessionQueryWindow\">\n"
            "<arg name=\"_sessionID\" type=\"u\" direction=\"in\" />\n"
            "<arg name=\"_sessionQueryID\" type=\"u\" direction=\"in\" />\n"
            "<arg name=\"_startIndex\" type=\"t\" direction=\"in\" />\n"
            "<arg name=\"_numItems\" type=\"t\" direction=\"in\" />\n"
            "<arg name=\"_result\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: Reselects the previous selected session query criteria. The previously shared
         *   sessionQueryID  will be returned.
         */
        "<method name=\"gotoPreviousSessionQuery\">\n"
            "<arg name=\"_sessionID\" type=\"u\" direction=\"in\" />\n"
            "<arg name=\"_result\" type=\"i\" direction=\"out\" />\n"
            "<arg name=\"_numResults\" type=\"t\" direction=\"out\" />\n"
            "<arg name=\"_sessionQueryID\" type=\"u\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: HMI Can use this to do a direct jump to any previous query ids
         */
        "<method name=\"jumpToSessionQuery\">\n"
            "<arg name=\"_sessionID\" type=\"u\" direction=\"in\" />\n"
            "<arg name=\"_sessionQueryID\" type=\"u\" direction=\"in\" />\n"
            "<arg name=\"_result\" type=\"i\" direction=\"out\" />\n"
            "<arg name=\"_numResults\" type=\"t\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: Play session category. This api handles all requests to play metadata browse
         *   results, database searches, etc . 
                       
                       
                   
         *      For this API, HMI should have initially done a openSession used the
         *   setSessionQuery to browse something. Then playSession
                       will play
         *   the currently selected browse context.
                       
                       1st
         *   Example:
                      
                       If the HMI wanted to play a list of all
         *   available songs.
                       
                       Initially HMI would have got
         *   the list of songs using setSessionQuery.
                       
                       Now
         *   playSession will just play the songs of that session.         
           
                   
         *      If HMI wants to play a particular song from the list of songs, then HMI can
         *   set the filterID map by:
                       
                       passing the id of the
         *   praticular song.
                       
                       But if there is a rquirement
         *   that on selecting the partiuclar song, the entire collection has to be played
         *   with the 
                       selected song maintaining its position/offset, then
         *   this type of playback will be maintained in pres ctrl project
                      
         *   configuration.           
                     
                       2nd Example : 
                
         *        
                       We are in the root level of file system and HMI screen
         *   has the list of folders and files.Now HMI selects a file.
                      We
         *   want to play only that file.
                      
                       Then HMI can pass
         *   the fileID in filterIDMap.
                      
                       But if the project
         *   requirement is to play that file + other files in the same level together, or
         *   even incude the files from subfolders,then this will
                      be
         *   maintained as a config parameter in pres.
                      
                       or if
         *   there is a button in HMI called "playAll" at each level of file system browse
         *   and on clicking that, we
                      need to play all the files in that
         *   level. Now for these cases, HMI can just pass the sessionID as an input
              
         *          based on project requirements,we can play all the files in the current
         *   folder browse level or include the 
                       subfolders.
         * param: sessionID: The Session ID alloted.
         * param: filterIDs: The previously communicated numeric identifiers of the different
         *   filter categories.
         */
        "<method name=\"playSession\">\n"
            "<arg name=\"_sessionID\" type=\"u\" direction=\"in\" />\n"
            "<arg name=\"_filterIDs\" type=\"a{it}\" direction=\"in\" />\n"
            "<arg name=\"_result\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: This requests the pres to directly jump to the file system level or metadata
         *   browse path level which
                            contains the currently playing
         *   track and returns the number of items in that level matching the filter 
             
         *                 criteria. 
        	
                            For example, after connecting
         *   the USB and selecting it for playback and it starts playing some file 
               
         *               (which is at the 4th nested level from root). 
        	
                         
         *     Now clicking on browse icon, based on project requirement , we can directly
         *   jump to the 4th nested level
                            (assuming it is the
         *   nowplaying level) by calling this API.
        
                           [TODO]:The
         *   interface input & output parameters are yet to be finalized. To check if the
         *   interface can be 
                           combined with setSessionQuery.
         */
        "<method name=\"gotoNowplayingLevel\">\n"
            "<arg name=\"_sessionID\" type=\"u\" direction=\"in\" />\n"
            "<arg name=\"_mediumID\" type=\"t\" direction=\"in\" />\n"
            "<arg name=\"_result\" type=\"i\" direction=\"out\" />\n"
            "<arg name=\"_numItems\" type=\"t\" direction=\"out\" />\n"
            "<arg name=\"_sessionQueryID\" type=\"u\" direction=\"out\" />\n"
        "</method>\n"

    ;
    return introspectionData.c_str();
}

CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        ::v1::com::harman::mmpres::MediaBrowserStub,
        CommonAPI::Version
        > MediaBrowserDBusStubAdapterInternal::getMediaBrowserInterfaceVersionStubDispatcher(&MediaBrowserStub::getInterfaceVersion, "uu");




/**
 * description: Opens a session for the client communication. This session will be used
 *   internally to uniquely identify a client, and to maintain client specific
 *   caches.
					  The client need not create a new session for every request,
 *   this is rather used to identify different instances of clients.   
         
 
 *          returns:     sessionID: Session identifier allocated to the client.
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v1::com::harman::mmpres::MediaBrowserStub,
    std::tuple<>,
    std::tuple<uint32_t, ::v1::com::harman::mmpres::MMPresTypes::eCallResult>,
    std::tuple<>,
    std::tuple<CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment>
    
    > MediaBrowserDBusStubAdapterInternal::openSessionStubDispatcher(
    &MediaBrowserStub::openSession, "ui",
					std::make_tuple(),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr)));

/**
 * description: Close a client session and release all associated resources. Once HMI calls
 *   closeSession,they cannot use the same sessionId
	for furthur browsing. For
 *   this, they have to again invoke a openSession to get a new sessionId for
 *   furthur browsing.
 * param: sessionID: The Session ID to close.
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v1::com::harman::mmpres::MediaBrowserStub,
    std::tuple<uint32_t>,
    std::tuple<::v1::com::harman::mmpres::MMPresTypes::eCallResult>,
    std::tuple<CommonAPI::EmptyDeployment>,
    std::tuple<CommonAPI::EmptyDeployment>
    
    > MediaBrowserDBusStubAdapterInternal::closeSessionStubDispatcher(
    &MediaBrowserStub::closeSession, "i",
					std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)));

/**
 * description: Essentially Stops all background tasks in the specified session. But unlike
 *   closeSession, the sessionID
	 is valid and can be used for furthur browsing.
 * param: sessionID: The Session ID alloted.
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v1::com::harman::mmpres::MediaBrowserStub,
    std::tuple<uint32_t>,
    std::tuple<::v1::com::harman::mmpres::MMPresTypes::eCallResult>,
    std::tuple<CommonAPI::EmptyDeployment>,
    std::tuple<CommonAPI::EmptyDeployment>
    
    > MediaBrowserDBusStubAdapterInternal::cancelSessionStubDispatcher(
    &MediaBrowserStub::cancelSession, "i",
					std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)));

/**
 * description: Sets a session query. This api handles all requests to fetch metadata browse
 *   results, database searches, file system browse etc. 
	 	 
	 	 Note: iF HMI
 *   wants to show the categories like ARTISTS,ALBUMS,FOLDERS,GENRES etc on
 *   clicking browse icon,they need not
	 	 use the setSessionQuery. They can
 *   instead use the tSlotUpdate broadcast which contains the tDevice structure.In
 *   
	 	 this, browse capabilities will be provided as a bitmask of different
 *   eMetadataTypes.If HMI is interested in
	 	 the count of these categories,then
 *   HMI can use the MetadataCountMap which is a map of different
 *   eMetadataCountType.
	 	 
	 	 
	 	 1st Example: 
	 	 
	 	 Get a list of all
 *   available artists. The filterID's' and filter's' will be empty, and the result
 *   type would be set to artist id. 
	 	 Presentation control would return a list
 *   of all available artists / artist id for the medium.
	 	 sessionQueryType will
 *   be METADATA_BROWSE 
	 	 
	 	 2nd Example:
	 	 
	 	 Get a list of all available
 *   artists. Also for each artist,get the count of songs.For this, input
 *   parameters will be same as first example
	 	 but now HMI should pass
 *   metadataCountTypes=eMetadataType::METADATATYPE_SONG.
	 	 
	 	 If HMI wants
 *   album count also along with songs count, then metadataCountTypes= bitmask
 *   combination of 
	 	 eMetadataType::METADATATYPE_SONG +
 *   eMetadataType::METADATATYPE_ALBUM.
	 	 
	 	 sessionQueryType will be
 *   METADATA_BROWSE 
	 	 
	 	 3rd Example : 
	 	 
	 	 Get a list of all available
 *   albums by the artist "Pink Floyd". HMI would know the artist id for "Pink
 *   Floyd" because of the previous returned result. 
	 	 
	 	 In the session
 *   query, HMI sets the filterIDMap as:
	 	 
	 	
 *   key=eMetadataType::METADATATYPE_ARTIST,value="artist id" for Pink Floyd 
	 	
 *   
	 	 resultType=eMetadataType::METADATATYPE_ALBUM. 
	 	 
	 	 Presentation
 *   Controller understands what needs to be done here. This can be further
 *   extended by setting
	 	 artist id and album id returned in the previous steps,
 *   and a query for songs can be done. 
	 	 
	 	 sessionQueryType will be
 *   METADATA_BROWSE.
	 	 
	 	 Suppose we need the list of songs inside the artist
 *   "Pink Floyd" but for eah song song, we also need to pass the artist,album 
	 	
 *   and genre values. Then this can be done by providing the "metadataAttributes"
 *   input parameter as a bit mask combination of
 *   eMetadataType::METADATATYPE_ARTIST +
	 	 eMetadataType::METADATATYPE_ALBUM &
 *   eMetadataType::METADATATYPE_GENRE.
	 	 
	 	 Note that metadataAttributes will
 *   be considered only if the resultType="song".
	 	 
	 	 4th Example : 
	 	 
	 	
 *   Get a list of all available albums by "Pink Floyd", which begin with the
 *   letters "The". 
	 	 This is same as the 3rd example, but in addition, the
 *   filter "album" must be set to "The"
	 	 
	 	 sessionQueryType will be
 *   METADATA_BROWSE 
	 	 
	 	 5th example:
	 	 
	 	 usage of resetPrevious
 *   parameter.
	 	 
	 	 Assume resetPrevious=false:
	 	 
	 	 In the first
 *   example,HMI obtained the list of albums for artist "Pink Floyed". Now if HMI
 *   wants list of songs for
	 	 artist "Pink Floyed", then in the filters,HMi need
 *   not mention anything again. 
	 	 They can just set
 *   resultype=eMetadataType::METADATATYPE_SONG .
	 	 
	 	 Now pres will remember
 *   that artist "Pink Floyd" was already selected. So pres will supply the song
 *   list for artist pink floyd.
	 	 
	 	 If resetPrevious=true,pres would not
 *   remeber that Artist Pink Floyd was already selected. In that case,
	 	 HMI has
 *   to set the filterIDMap again by providing the artist id for pink Floyd.
	 	 
	
 *   	 Now in the use cases, where the resultType is
 *   "eMetadataType::METADATATYPE_SONG", if the requirement is to show only AUDIO
	
 *   	 or VIDEO or both AUDIO + VIDEO, this can be done by setting "ContentMask"
 *   param as a bit mask of "eTitleContentType".
	 	 
	 	
 *   eTitleContentType::TITLETYPE_IMAGE will be applicable for filesystem browse.
 *   
	 	 
	 	 6th Example:
	 	 
	 	 Do a fileSystem or FOLDER browse.This is
 *   applicable for mass storage devices like USB.At any level, we are 
	 	 allowed
 *   to show both folders, files or playlists depending on project requirements.
	
 *   	 
	 	 sessionQueryType will be SESSION_QUERY_FS_BROWSE.
	 	 
	 	 First go to
 *   root level and show only folders and files but not playlists. For this, the
 *   filterID's and filters are empty, but the resultType will be 
	 	 combination
 *   of eMetadataType::METADATATYPE_FOLDER + eMetadataType::METADATATYPE_FILE.With
 *   this query,HMI can get
	 	 the folders and file at a given level in
 *   filesystem. When HMI gets the individual items, they can check the
 *   eMetadataType
	 	 of that item to see if it is a file or folder.
	 	 
	 	 Now
 *   HMI wants to go inside one more level by selecting a folder obtained in the
 *   previous step.For this,HMI can set the filterID as 
	 	
 *   key=METADATAID_FOLDER_ID and value=(folder id or item id) of folder
 *   communicated in previous step.
	 	 
	 	 If at every level, there is a
 *   requirement to list folders first and only then followed by audio files,image
 *   files etc, then
	 	 these will be maintained by pres as project specific
 *   config parameters. 
	 	 
	 	 Now HMI wants to go inside one of the folders
 *   named "Folder1" listed at the root level.For this,HMI can set the FilterIDMap
 *   as:
	 	 
	 	 key: "eMetadataType::METADATATYPE_FOLDER" and value: folder id of
 *   "folder 1" from the result of the first query to 
	 	       show the root
 *   level contents.
	 	 
	 	 Also if HMI wants the level ID (depth of folder) in
 *   file system browse, such as 4th folder depth or fifth folder depth etc,
	 	
 *   then they can use the sessionQueryID as an indicator of level ID. Each
 *   sessionQueryID will correspond to a
	 	 particular folder depth in file system
 *   browse.
	 	 
	 	 7th example:
	 	 
	 	 If HMI wants the list of songs from the
 *   recently played list.
	 	 
	 	 The can set the sessionQueryType will be
 *   SESSION_QUERY_RECENTLYPLAYED and resultype=eMetadataType::METADATATYPE_SONG
	 
 *      other parameters can be empty.
 * param: filterIDs: The previously communicated numeric identifiers of the different
 *   filter categories.
 * param: filters:	 The string filters which should be applied to the result.
 * param: resultType: The data which is expected from the query.
 * param: sessionID: The Session ID alloted.
 * param: mediumID:	 The identifier for the mediastore to query.
 * param: type:		 The type of session query.
 * param: metadataAttributes: [TODO]:Pres ctrl can return the required attributes for
 *   each metadata item based on the 
                                         
 *   client requirements.This is a bitmask combination of eMetadataType values.
 *   This will be 
                                          supported only for the
 *   song category.
 * param: metadataCountTypes: Pres Ctrl can count the number of items present in a
 *   subcategory. For example, while retreving a list of all artists, 
        
 *   								  Pres Ctrl can also count how many albums/songs are available for
 *   each artist. (Might be a costly operation depending on Media Type. 
        
 *   								  	Select this option only if really required )
 * param: resetPrevious: Whether to use old history or not. Pres Ctrl has internal
 *   history mechanism. For example
         							 if in the first session query,
 *   the list of all available artists was obtained.In the 2nd browse level, HMI
 *   requested for
         							 all albums by a specific artist. If now HMI
 *   wants a list of all songs by the artist, it need not tell the selected artist
 *   
         							 again. However if this flag is reset, it will override this
 *   behavior.
 * param: AutoUpdateEnabled: 	This is applicable for result sets which might update
 *   dynamically, for example the current playing list for external
        
 *   								devices might update on its own.
 * param: ContentMask      //Bitmask combination of eTitleContentType. Bitmask
 *   combination for what content is expected - Audio/Video/Image.
        
       
 *    returns:	  numResults: The number of records matching the search criteria.
 *   (The number of results might not be accurate for ipod iAP1 like devices)
     
 *      
         returns      sessionQueryID:The sessionQueryID allotted.This
 *   uniquely identifies a particular session query/filter for retrieving data in a
 *   session and it has to be passed 
                                      for
 *   furthur setting the sessionQuery window and retrieving the contents of that
 *   window.
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v1::com::harman::mmpres::MediaBrowserStub,
    std::tuple<uint32_t, uint64_t, ::v1::com::harman::mmpres::MMPresTypes::FilterIDMap, ::v1::com::harman::mmpres::MMPresTypes::FilterMap, ::v1::com::harman::mmpres::MMPresTypes::eMetadataType, uint32_t, uint32_t, ::v1::com::harman::mmpres::MMPresTypes::eSessionQueryTypes, bool, bool, uint32_t>,
    std::tuple<::v1::com::harman::mmpres::MMPresTypes::eCallResult, uint64_t, uint32_t>,
    std::tuple<CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment, ::v1::com::harman::mmpres::MMPresTypes_::FilterIDMapDeployment_t, ::v1::com::harman::mmpres::MMPresTypes_::FilterMapDeployment_t, CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment>,
    std::tuple<CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment>
    
    > MediaBrowserDBusStubAdapterInternal::setSessionQueryStubDispatcher(
    &MediaBrowserStub::setSessionQuery, "itu",
					std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<::v1::com::harman::mmpres::MMPresTypes_::FilterIDMapDeployment_t*>(nullptr), static_cast<::v1::com::harman::mmpres::MMPresTypes_::FilterMapDeployment_t*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr)));

/**
 * description: Ask presentation control to fetch the desired set of entries for a particular
 *   session query. This call does not block for the result to complete, and will
 *   override
					  the last request given to Pres Ctrl.
 * param: sessionID: 	The Session ID alloted.
 * param: sessionQueryID: The sessionQueryID allotted.This uniquely identifies a
 *   particular session query/filter for retrieving data in a session and it has to
 *   be passed 
                                      for furthur setting the
 *   sessionQuery window and retrieving the contents of that window.
 * param: startIndex:	The index to start fetching.
 * param: numItems:		The number of items to fetch.
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v1::com::harman::mmpres::MediaBrowserStub,
    std::tuple<uint32_t, uint32_t, uint64_t, uint64_t>,
    std::tuple<::v1::com::harman::mmpres::MMPresTypes::eCallResult>,
    std::tuple<CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment>,
    std::tuple<CommonAPI::EmptyDeployment>
    
    > MediaBrowserDBusStubAdapterInternal::setSessionQueryWindowStubDispatcher(
    &MediaBrowserStub::setSessionQueryWindow, "i",
					std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)));

/**
 * description: Reselects the previous selected session query criteria. The previously shared
 *   sessionQueryID  will be returned.
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v1::com::harman::mmpres::MediaBrowserStub,
    std::tuple<uint32_t>,
    std::tuple<::v1::com::harman::mmpres::MMPresTypes::eCallResult, uint64_t, uint32_t>,
    std::tuple<CommonAPI::EmptyDeployment>,
    std::tuple<CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment>
    
    > MediaBrowserDBusStubAdapterInternal::gotoPreviousSessionQueryStubDispatcher(
    &MediaBrowserStub::gotoPreviousSessionQuery, "itu",
					std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr)));

/**
 * description: HMI Can use this to do a direct jump to any previous query ids
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v1::com::harman::mmpres::MediaBrowserStub,
    std::tuple<uint32_t, uint32_t>,
    std::tuple<::v1::com::harman::mmpres::MMPresTypes::eCallResult, uint64_t>,
    std::tuple<CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment>,
    std::tuple<CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment>
    
    > MediaBrowserDBusStubAdapterInternal::jumpToSessionQueryStubDispatcher(
    &MediaBrowserStub::jumpToSessionQuery, "it",
					std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr)));

/**
 * description: Play session category. This api handles all requests to play metadata browse
 *   results, database searches, etc . 
               
               
           
 *      For this API, HMI should have initially done a openSession used the
 *   setSessionQuery to browse something. Then playSession
               will play
 *   the currently selected browse context.
               
               1st
 *   Example:
              
               If the HMI wanted to play a list of all
 *   available songs.
               
               Initially HMI would have got
 *   the list of songs using setSessionQuery.
               
               Now
 *   playSession will just play the songs of that session.         
   
           
 *      If HMI wants to play a particular song from the list of songs, then HMI can
 *   set the filterID map by:
               
               passing the id of the
 *   praticular song.
               
               But if there is a rquirement
 *   that on selecting the partiuclar song, the entire collection has to be played
 *   with the 
               selected song maintaining its position/offset, then
 *   this type of playback will be maintained in pres ctrl project
              
 *   configuration.           
             
               2nd Example : 
        
 *        
               We are in the root level of file system and HMI screen
 *   has the list of folders and files.Now HMI selects a file.
              We
 *   want to play only that file.
              
               Then HMI can pass
 *   the fileID in filterIDMap.
              
               But if the project
 *   requirement is to play that file + other files in the same level together, or
 *   even incude the files from subfolders,then this will
              be
 *   maintained as a config parameter in pres.
              
               or if
 *   there is a button in HMI called "playAll" at each level of file system browse
 *   and on clicking that, we
              need to play all the files in that
 *   level. Now for these cases, HMI can just pass the sessionID as an input
      
 *          based on project requirements,we can play all the files in the current
 *   folder browse level or include the 
               subfolders.
 * param: sessionID: The Session ID alloted.
 * param: filterIDs: The previously communicated numeric identifiers of the different
 *   filter categories.
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v1::com::harman::mmpres::MediaBrowserStub,
    std::tuple<uint32_t, ::v1::com::harman::mmpres::MMPresTypes::FilterIDMap>,
    std::tuple<::v1::com::harman::mmpres::MMPresTypes::eCallResult>,
    std::tuple<CommonAPI::EmptyDeployment, ::v1::com::harman::mmpres::MMPresTypes_::FilterIDMapDeployment_t>,
    std::tuple<CommonAPI::EmptyDeployment>
    
    > MediaBrowserDBusStubAdapterInternal::playSessionStubDispatcher(
    &MediaBrowserStub::playSession, "i",
					std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<::v1::com::harman::mmpres::MMPresTypes_::FilterIDMapDeployment_t*>(nullptr)),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)));

/**
 * description: This requests the pres to directly jump to the file system level or metadata
 *   browse path level which
                    contains the currently playing
 *   track and returns the number of items in that level matching the filter 
     
 *                 criteria. 
	
                    For example, after connecting
 *   the USB and selecting it for playback and it starts playing some file 
       
 *               (which is at the 4th nested level from root). 
	
                 
 *     Now clicking on browse icon, based on project requirement , we can directly
 *   jump to the 4th nested level
                    (assuming it is the
 *   nowplaying level) by calling this API.

                   [TODO]:The
 *   interface input & output parameters are yet to be finalized. To check if the
 *   interface can be 
                   combined with setSessionQuery.
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v1::com::harman::mmpres::MediaBrowserStub,
    std::tuple<uint32_t, uint64_t>,
    std::tuple<::v1::com::harman::mmpres::MMPresTypes::eCallResult, uint64_t, uint32_t>,
    std::tuple<CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment>,
    std::tuple<CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment>
    
    > MediaBrowserDBusStubAdapterInternal::gotoNowplayingLevelStubDispatcher(
    &MediaBrowserStub::gotoNowplayingLevel, "itu",
					std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr)));



/**
 * description: Will only be posted to the respective listeners if the session query parameters
 *   have changed. 
					  For example, for externally played back devices, the
 *   number of items in the currently playing list might change.  Will be published
 *   
					  only if auto update was enabled when setting the query. 
	      
     
 *      returns  sessionID:      The Session ID alloted.
         returns 
 *   sessionQueryID: The sessionQueryID allotted.This uniquely identifies a
 *   particular session query/filter for retrieving data in a session and it has to
 *   be passed 
                                      for furthur setting the
 *   sessionQuery window and retrieving the contents of that window.
         
    
 *       returns  numItems:		   The updated number of items for the
 *   sessionID/sessionQueryID.
 */
CommonAPI::DBus::DBusMethodWithReplyAdapterDispatcher<
    ::v1::com::harman::mmpres::MediaBrowserStub,
    MediaBrowserStubAdapter,
    std::tuple<>,
    std::tuple<bool>
    > MediaBrowserDBusStubAdapterInternal::subscribeSessionQueryUpdateSelectiveStubDispatcher(&MediaBrowserStubAdapter::subscribeForsessionQueryUpdateSelective, "b");

CommonAPI::DBus::DBusMethodWithReplyAdapterDispatcher<
    ::v1::com::harman::mmpres::MediaBrowserStub,
    MediaBrowserStubAdapter,
    std::tuple<>,
    std::tuple<>
    > MediaBrowserDBusStubAdapterInternal::unsubscribeSessionQueryUpdateSelectiveStubDispatcher(&MediaBrowserStubAdapter::unsubscribeFromsessionQueryUpdateSelective, "");

void MediaBrowserDBusStubAdapterInternal::fireSessionQueryUpdateSelective(const std::shared_ptr<CommonAPI::ClientId> _client, const uint32_t &_sessionID, const uint32_t &_sessionQueryID, const uint64_t &_numResults) {
    std::shared_ptr<CommonAPI::DBus::DBusClientId> dbusClient = std::dynamic_pointer_cast<CommonAPI::DBus::DBusClientId, CommonAPI::ClientId>(_client);

    if(dbusClient)
    {
        CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<
        uint32_t,
        uint32_t,
        uint64_t
        >>::sendSignal(
                dbusClient->getDBusId(),
                *this,
                "sessionQueryUpdate",
                "uut",
        _sessionID,
        _sessionQueryID,
        _numResults
        );
    }
}

void MediaBrowserDBusStubAdapterInternal::sendSessionQueryUpdateSelective(const uint32_t &_sessionID, const uint32_t &_sessionQueryID, const uint64_t &_numResults, const std::shared_ptr<CommonAPI::ClientIdList> _receivers) {
    std::shared_ptr<CommonAPI::ClientIdList> actualReceiverList = _receivers;

    if (!_receivers)
        actualReceiverList = subscribersForSessionQueryUpdateSelective_;

    for (auto clientIdIterator = actualReceiverList->cbegin(); clientIdIterator != actualReceiverList->cend(); clientIdIterator++) {
        if (!_receivers || subscribersForSessionQueryUpdateSelective_->find(*clientIdIterator) != subscribersForSessionQueryUpdateSelective_->end()) {
            fireSessionQueryUpdateSelective(*clientIdIterator, _sessionID, _sessionQueryID, _numResults);
        }
    }
}

void MediaBrowserDBusStubAdapterInternal::subscribeForsessionQueryUpdateSelective(const std::shared_ptr<CommonAPI::ClientId> clientId, bool& success) {
    bool ok = MediaBrowserDBusStubAdapterHelper::stub_->onSessionQueryUpdateSelectiveSubscriptionRequested(clientId);
    if (ok) {
        subscribersForSessionQueryUpdateSelective_->insert(clientId);
        MediaBrowserDBusStubAdapterHelper::stub_->onSessionQueryUpdateSelectiveSubscriptionChanged(clientId, CommonAPI::SelectiveBroadcastSubscriptionEvent::SUBSCRIBED);
        success = true;
    } else {
        success = false;
    }
}

void MediaBrowserDBusStubAdapterInternal::unsubscribeFromsessionQueryUpdateSelective(const std::shared_ptr<CommonAPI::ClientId> clientId) {
    subscribersForSessionQueryUpdateSelective_->erase(clientId);
    MediaBrowserDBusStubAdapterHelper::stub_->onSessionQueryUpdateSelectiveSubscriptionChanged(clientId, CommonAPI::SelectiveBroadcastSubscriptionEvent::UNSUBSCRIBED);
}

std::shared_ptr<CommonAPI::ClientIdList> const MediaBrowserDBusStubAdapterInternal::getSubscribersForSessionQueryUpdateSelective() {
    return subscribersForSessionQueryUpdateSelective_;
}
/**
 * description: Publishes the query status to all clients. The client can get the data once the
 *   query is "finished"
	
	     returns  sessionID: 	   The Session ID alloted.
  
 *         returns  sessionQueryID:  The sessionQueryID allotted.This uniquely
 *   identifies a particular session query/filter for retrieving data in a session
 *   and it has to be passed 
                                      for furthur
 *   setting the sessionQuery window and retrieving the contents of that window.
  
 *       
         returns  eQueryStatus:    query status of the window update.
   
 *        returns  startIndex:	   The index to start fetching.  
         returns 
 *   numItems:		   The number of items to fetch.
         returns  itemList:       
 *    List of tMetadataItems.
         
         returns
 *   windowContainsCurrentlyPlayingTrack: This will be true if one of the
 *   tMetadataItems is the currently playing track.
        
         returns
 *   itemIndexTobeHighlighted: // index of the item to be highlighted in the
 *   returned nowPlaying list. If the 
                                            
 *    currently playing item is not part of the returned window, then this will be
 *   assigned 0.
 */
CommonAPI::DBus::DBusMethodWithReplyAdapterDispatcher<
    ::v1::com::harman::mmpres::MediaBrowserStub,
    MediaBrowserStubAdapter,
    std::tuple<>,
    std::tuple<bool>
    > MediaBrowserDBusStubAdapterInternal::subscribeSessionQueryWindowUpdateSelectiveStubDispatcher(&MediaBrowserStubAdapter::subscribeForsessionQueryWindowUpdateSelective, "b");

CommonAPI::DBus::DBusMethodWithReplyAdapterDispatcher<
    ::v1::com::harman::mmpres::MediaBrowserStub,
    MediaBrowserStubAdapter,
    std::tuple<>,
    std::tuple<>
    > MediaBrowserDBusStubAdapterInternal::unsubscribeSessionQueryWindowUpdateSelectiveStubDispatcher(&MediaBrowserStubAdapter::unsubscribeFromsessionQueryWindowUpdateSelective, "");

void MediaBrowserDBusStubAdapterInternal::fireSessionQueryWindowUpdateSelective(const std::shared_ptr<CommonAPI::ClientId> _client, const uint32_t &_sessionID, const uint32_t &_sessionQueryID, const ::v1::com::harman::mmpres::MMPresTypes::eQueryStatus &_status, const uint64_t &_startIndex, const uint64_t &_numItems, const ::v1::com::harman::mmpres::MMPresTypes::MetadataItemList &_itemList, const bool &_windowContainsCurrentlyPlayingTrack, const uint64_t &_itemIndexTobeHighlighted) {
    std::shared_ptr<CommonAPI::DBus::DBusClientId> dbusClient = std::dynamic_pointer_cast<CommonAPI::DBus::DBusClientId, CommonAPI::ClientId>(_client);

    if(dbusClient)
    {
        CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<
        uint32_t,
        uint32_t,
        ::v1::com::harman::mmpres::MMPresTypes::eQueryStatus,
        uint64_t,
        uint64_t,
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::MetadataItemList, ::v1::com::harman::mmpres::MMPresTypes_::MetadataItemListDeployment_t>,
        bool,
        uint64_t
        >>::sendSignal(
                dbusClient->getDBusId(),
                *this,
                "sessionQueryWindowUpdate",
                "uuitta(tsbbiia{it}a{is}i)bt",
        _sessionID,
        _sessionQueryID,
        _status,
        _startIndex,
        _numItems,
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::MetadataItemList, ::v1::com::harman::mmpres::MMPresTypes_::MetadataItemListDeployment_t>(_itemList, static_cast<::v1::com::harman::mmpres::MMPresTypes_::MetadataItemListDeployment_t*>(nullptr)),
        _windowContainsCurrentlyPlayingTrack,
        _itemIndexTobeHighlighted
        );
    }
}

void MediaBrowserDBusStubAdapterInternal::sendSessionQueryWindowUpdateSelective(const uint32_t &_sessionID, const uint32_t &_sessionQueryID, const ::v1::com::harman::mmpres::MMPresTypes::eQueryStatus &_status, const uint64_t &_startIndex, const uint64_t &_numItems, const ::v1::com::harman::mmpres::MMPresTypes::MetadataItemList &_itemList, const bool &_windowContainsCurrentlyPlayingTrack, const uint64_t &_itemIndexTobeHighlighted, const std::shared_ptr<CommonAPI::ClientIdList> _receivers) {
    std::shared_ptr<CommonAPI::ClientIdList> actualReceiverList = _receivers;

    if (!_receivers)
        actualReceiverList = subscribersForSessionQueryWindowUpdateSelective_;

    for (auto clientIdIterator = actualReceiverList->cbegin(); clientIdIterator != actualReceiverList->cend(); clientIdIterator++) {
        if (!_receivers || subscribersForSessionQueryWindowUpdateSelective_->find(*clientIdIterator) != subscribersForSessionQueryWindowUpdateSelective_->end()) {
            fireSessionQueryWindowUpdateSelective(*clientIdIterator, _sessionID, _sessionQueryID, _status, _startIndex, _numItems, _itemList, _windowContainsCurrentlyPlayingTrack, _itemIndexTobeHighlighted);
        }
    }
}

void MediaBrowserDBusStubAdapterInternal::subscribeForsessionQueryWindowUpdateSelective(const std::shared_ptr<CommonAPI::ClientId> clientId, bool& success) {
    bool ok = MediaBrowserDBusStubAdapterHelper::stub_->onSessionQueryWindowUpdateSelectiveSubscriptionRequested(clientId);
    if (ok) {
        subscribersForSessionQueryWindowUpdateSelective_->insert(clientId);
        MediaBrowserDBusStubAdapterHelper::stub_->onSessionQueryWindowUpdateSelectiveSubscriptionChanged(clientId, CommonAPI::SelectiveBroadcastSubscriptionEvent::SUBSCRIBED);
        success = true;
    } else {
        success = false;
    }
}

void MediaBrowserDBusStubAdapterInternal::unsubscribeFromsessionQueryWindowUpdateSelective(const std::shared_ptr<CommonAPI::ClientId> clientId) {
    subscribersForSessionQueryWindowUpdateSelective_->erase(clientId);
    MediaBrowserDBusStubAdapterHelper::stub_->onSessionQueryWindowUpdateSelectiveSubscriptionChanged(clientId, CommonAPI::SelectiveBroadcastSubscriptionEvent::UNSUBSCRIBED);
}

std::shared_ptr<CommonAPI::ClientIdList> const MediaBrowserDBusStubAdapterInternal::getSubscribersForSessionQueryWindowUpdateSelective() {
    return subscribersForSessionQueryWindowUpdateSelective_;
}


const MediaBrowserDBusStubAdapterHelper::StubDispatcherTable& MediaBrowserDBusStubAdapterInternal::getStubDispatcherTable() {
    return stubDispatcherTable_;
}

const CommonAPI::DBus::StubAttributeTable& MediaBrowserDBusStubAdapterInternal::getStubAttributeTable() {
    return stubAttributeTable_;
}

MediaBrowserDBusStubAdapterInternal::MediaBrowserDBusStubAdapterInternal(
        const CommonAPI::DBus::DBusAddress &_address,
        const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection,
        const std::shared_ptr<CommonAPI::StubBase> &_stub)
	: CommonAPI::DBus::DBusStubAdapter(_address, _connection,false),
      MediaBrowserDBusStubAdapterHelper(_address, _connection, std::dynamic_pointer_cast<MediaBrowserStub>(_stub), false),
      stubDispatcherTable_({
            /**
             * description: Opens a session for the client communication. This session will be used
             *   internally to uniquely identify a client, and to maintain client specific
             *   caches.
            					  The client need not create a new session for every request,
             *   this is rather used to identify different instances of clients.   
                     
             
             *          returns:     sessionID: Session identifier allocated to the client.
             */
            { { "openSession", "" }, &com::harman::mmpres::MediaBrowserDBusStubAdapterInternal::openSessionStubDispatcher },
            /**
             * description: Close a client session and release all associated resources. Once HMI calls
             *   closeSession,they cannot use the same sessionId
            	for furthur browsing. For
             *   this, they have to again invoke a openSession to get a new sessionId for
             *   furthur browsing.
             * param: sessionID: The Session ID to close.
             */
            { { "closeSession", "u" }, &com::harman::mmpres::MediaBrowserDBusStubAdapterInternal::closeSessionStubDispatcher },
            /**
             * description: Essentially Stops all background tasks in the specified session. But unlike
             *   closeSession, the sessionID
            	 is valid and can be used for furthur browsing.
             * param: sessionID: The Session ID alloted.
             */
            { { "cancelSession", "u" }, &com::harman::mmpres::MediaBrowserDBusStubAdapterInternal::cancelSessionStubDispatcher },
            /**
             * description: Sets a session query. This api handles all requests to fetch metadata browse
             *   results, database searches, file system browse etc. 
            	 	 
            	 	 Note: iF HMI
             *   wants to show the categories like ARTISTS,ALBUMS,FOLDERS,GENRES etc on
             *   clicking browse icon,they need not
            	 	 use the setSessionQuery. They can
             *   instead use the tSlotUpdate broadcast which contains the tDevice structure.In
             *   
            	 	 this, browse capabilities will be provided as a bitmask of different
             *   eMetadataTypes.If HMI is interested in
            	 	 the count of these categories,then
             *   HMI can use the MetadataCountMap which is a map of different
             *   eMetadataCountType.
            	 	 
            	 	 
            	 	 1st Example: 
            	 	 
            	 	 Get a list of all
             *   available artists. The filterID's' and filter's' will be empty, and the result
             *   type would be set to artist id. 
            	 	 Presentation control would return a list
             *   of all available artists / artist id for the medium.
            	 	 sessionQueryType will
             *   be METADATA_BROWSE 
            	 	 
            	 	 2nd Example:
            	 	 
            	 	 Get a list of all available
             *   artists. Also for each artist,get the count of songs.For this, input
             *   parameters will be same as first example
            	 	 but now HMI should pass
             *   metadataCountTypes=eMetadataType::METADATATYPE_SONG.
            	 	 
            	 	 If HMI wants
             *   album count also along with songs count, then metadataCountTypes= bitmask
             *   combination of 
            	 	 eMetadataType::METADATATYPE_SONG +
             *   eMetadataType::METADATATYPE_ALBUM.
            	 	 
            	 	 sessionQueryType will be
             *   METADATA_BROWSE 
            	 	 
            	 	 3rd Example : 
            	 	 
            	 	 Get a list of all available
             *   albums by the artist "Pink Floyd". HMI would know the artist id for "Pink
             *   Floyd" because of the previous returned result. 
            	 	 
            	 	 In the session
             *   query, HMI sets the filterIDMap as:
            	 	 
            	 	
             *   key=eMetadataType::METADATATYPE_ARTIST,value="artist id" for Pink Floyd 
            	 	
             *   
            	 	 resultType=eMetadataType::METADATATYPE_ALBUM. 
            	 	 
            	 	 Presentation
             *   Controller understands what needs to be done here. This can be further
             *   extended by setting
            	 	 artist id and album id returned in the previous steps,
             *   and a query for songs can be done. 
            	 	 
            	 	 sessionQueryType will be
             *   METADATA_BROWSE.
            	 	 
            	 	 Suppose we need the list of songs inside the artist
             *   "Pink Floyd" but for eah song song, we also need to pass the artist,album 
            	 	
             *   and genre values. Then this can be done by providing the "metadataAttributes"
             *   input parameter as a bit mask combination of
             *   eMetadataType::METADATATYPE_ARTIST +
            	 	 eMetadataType::METADATATYPE_ALBUM &
             *   eMetadataType::METADATATYPE_GENRE.
            	 	 
            	 	 Note that metadataAttributes will
             *   be considered only if the resultType="song".
            	 	 
            	 	 4th Example : 
            	 	 
            	 	
             *   Get a list of all available albums by "Pink Floyd", which begin with the
             *   letters "The". 
            	 	 This is same as the 3rd example, but in addition, the
             *   filter "album" must be set to "The"
            	 	 
            	 	 sessionQueryType will be
             *   METADATA_BROWSE 
            	 	 
            	 	 5th example:
            	 	 
            	 	 usage of resetPrevious
             *   parameter.
            	 	 
            	 	 Assume resetPrevious=false:
            	 	 
            	 	 In the first
             *   example,HMI obtained the list of albums for artist "Pink Floyed". Now if HMI
             *   wants list of songs for
            	 	 artist "Pink Floyed", then in the filters,HMi need
             *   not mention anything again. 
            	 	 They can just set
             *   resultype=eMetadataType::METADATATYPE_SONG .
            	 	 
            	 	 Now pres will remember
             *   that artist "Pink Floyd" was already selected. So pres will supply the song
             *   list for artist pink floyd.
            	 	 
            	 	 If resetPrevious=true,pres would not
             *   remeber that Artist Pink Floyd was already selected. In that case,
            	 	 HMI has
             *   to set the filterIDMap again by providing the artist id for pink Floyd.
            	 	 
            	
             *   	 Now in the use cases, where the resultType is
             *   "eMetadataType::METADATATYPE_SONG", if the requirement is to show only AUDIO
            	
             *   	 or VIDEO or both AUDIO + VIDEO, this can be done by setting "ContentMask"
             *   param as a bit mask of "eTitleContentType".
            	 	 
            	 	
             *   eTitleContentType::TITLETYPE_IMAGE will be applicable for filesystem browse.
             *   
            	 	 
            	 	 6th Example:
            	 	 
            	 	 Do a fileSystem or FOLDER browse.This is
             *   applicable for mass storage devices like USB.At any level, we are 
            	 	 allowed
             *   to show both folders, files or playlists depending on project requirements.
            	
             *   	 
            	 	 sessionQueryType will be SESSION_QUERY_FS_BROWSE.
            	 	 
            	 	 First go to
             *   root level and show only folders and files but not playlists. For this, the
             *   filterID's and filters are empty, but the resultType will be 
            	 	 combination
             *   of eMetadataType::METADATATYPE_FOLDER + eMetadataType::METADATATYPE_FILE.With
             *   this query,HMI can get
            	 	 the folders and file at a given level in
             *   filesystem. When HMI gets the individual items, they can check the
             *   eMetadataType
            	 	 of that item to see if it is a file or folder.
            	 	 
            	 	 Now
             *   HMI wants to go inside one more level by selecting a folder obtained in the
             *   previous step.For this,HMI can set the filterID as 
            	 	
             *   key=METADATAID_FOLDER_ID and value=(folder id or item id) of folder
             *   communicated in previous step.
            	 	 
            	 	 If at every level, there is a
             *   requirement to list folders first and only then followed by audio files,image
             *   files etc, then
            	 	 these will be maintained by pres as project specific
             *   config parameters. 
            	 	 
            	 	 Now HMI wants to go inside one of the folders
             *   named "Folder1" listed at the root level.For this,HMI can set the FilterIDMap
             *   as:
            	 	 
            	 	 key: "eMetadataType::METADATATYPE_FOLDER" and value: folder id of
             *   "folder 1" from the result of the first query to 
            	 	       show the root
             *   level contents.
            	 	 
            	 	 Also if HMI wants the level ID (depth of folder) in
             *   file system browse, such as 4th folder depth or fifth folder depth etc,
            	 	
             *   then they can use the sessionQueryID as an indicator of level ID. Each
             *   sessionQueryID will correspond to a
            	 	 particular folder depth in file system
             *   browse.
            	 	 
            	 	 7th example:
            	 	 
            	 	 If HMI wants the list of songs from the
             *   recently played list.
            	 	 
            	 	 The can set the sessionQueryType will be
             *   SESSION_QUERY_RECENTLYPLAYED and resultype=eMetadataType::METADATATYPE_SONG
            	 
             *      other parameters can be empty.
             * param: filterIDs: The previously communicated numeric identifiers of the different
             *   filter categories.
             * param: filters:	 The string filters which should be applied to the result.
             * param: resultType: The data which is expected from the query.
             * param: sessionID: The Session ID alloted.
             * param: mediumID:	 The identifier for the mediastore to query.
             * param: type:		 The type of session query.
             * param: metadataAttributes: [TODO]:Pres ctrl can return the required attributes for
             *   each metadata item based on the 
                                                     
             *   client requirements.This is a bitmask combination of eMetadataType values.
             *   This will be 
                                                      supported only for the
             *   song category.
             * param: metadataCountTypes: Pres Ctrl can count the number of items present in a
             *   subcategory. For example, while retreving a list of all artists, 
                    
             *   								  Pres Ctrl can also count how many albums/songs are available for
             *   each artist. (Might be a costly operation depending on Media Type. 
                    
             *   								  	Select this option only if really required )
             * param: resetPrevious: Whether to use old history or not. Pres Ctrl has internal
             *   history mechanism. For example
                     							 if in the first session query,
             *   the list of all available artists was obtained.In the 2nd browse level, HMI
             *   requested for
                     							 all albums by a specific artist. If now HMI
             *   wants a list of all songs by the artist, it need not tell the selected artist
             *   
                     							 again. However if this flag is reset, it will override this
             *   behavior.
             * param: AutoUpdateEnabled: 	This is applicable for result sets which might update
             *   dynamically, for example the current playing list for external
                    
             *   								devices might update on its own.
             * param: ContentMask      //Bitmask combination of eTitleContentType. Bitmask
             *   combination for what content is expected - Audio/Video/Image.
                    
                   
             *    returns:	  numResults: The number of records matching the search criteria.
             *   (The number of results might not be accurate for ipod iAP1 like devices)
                 
             *      
                     returns      sessionQueryID:The sessionQueryID allotted.This
             *   uniquely identifies a particular session query/filter for retrieving data in a
             *   session and it has to be passed 
                                                  for
             *   furthur setting the sessionQuery window and retrieving the contents of that
             *   window.
             */
            { { "setSessionQuery", "uta{it}a{is}iuuibbu" }, &com::harman::mmpres::MediaBrowserDBusStubAdapterInternal::setSessionQueryStubDispatcher },
            /**
             * description: Ask presentation control to fetch the desired set of entries for a particular
             *   session query. This call does not block for the result to complete, and will
             *   override
            					  the last request given to Pres Ctrl.
             * param: sessionID: 	The Session ID alloted.
             * param: sessionQueryID: The sessionQueryID allotted.This uniquely identifies a
             *   particular session query/filter for retrieving data in a session and it has to
             *   be passed 
                                                  for furthur setting the
             *   sessionQuery window and retrieving the contents of that window.
             * param: startIndex:	The index to start fetching.
             * param: numItems:		The number of items to fetch.
             */
            { { "setSessionQueryWindow", "uutt" }, &com::harman::mmpres::MediaBrowserDBusStubAdapterInternal::setSessionQueryWindowStubDispatcher },
            /**
             * description: Reselects the previous selected session query criteria. The previously shared
             *   sessionQueryID  will be returned.
             */
            { { "gotoPreviousSessionQuery", "u" }, &com::harman::mmpres::MediaBrowserDBusStubAdapterInternal::gotoPreviousSessionQueryStubDispatcher },
            /**
             * description: HMI Can use this to do a direct jump to any previous query ids
             */
            { { "jumpToSessionQuery", "uu" }, &com::harman::mmpres::MediaBrowserDBusStubAdapterInternal::jumpToSessionQueryStubDispatcher },
            /**
             * description: Play session category. This api handles all requests to play metadata browse
             *   results, database searches, etc . 
                           
                           
                       
             *      For this API, HMI should have initially done a openSession used the
             *   setSessionQuery to browse something. Then playSession
                           will play
             *   the currently selected browse context.
                           
                           1st
             *   Example:
                          
                           If the HMI wanted to play a list of all
             *   available songs.
                           
                           Initially HMI would have got
             *   the list of songs using setSessionQuery.
                           
                           Now
             *   playSession will just play the songs of that session.         
               
                       
             *      If HMI wants to play a particular song from the list of songs, then HMI can
             *   set the filterID map by:
                           
                           passing the id of the
             *   praticular song.
                           
                           But if there is a rquirement
             *   that on selecting the partiuclar song, the entire collection has to be played
             *   with the 
                           selected song maintaining its position/offset, then
             *   this type of playback will be maintained in pres ctrl project
                          
             *   configuration.           
                         
                           2nd Example : 
                    
             *        
                           We are in the root level of file system and HMI screen
             *   has the list of folders and files.Now HMI selects a file.
                          We
             *   want to play only that file.
                          
                           Then HMI can pass
             *   the fileID in filterIDMap.
                          
                           But if the project
             *   requirement is to play that file + other files in the same level together, or
             *   even incude the files from subfolders,then this will
                          be
             *   maintained as a config parameter in pres.
                          
                           or if
             *   there is a button in HMI called "playAll" at each level of file system browse
             *   and on clicking that, we
                          need to play all the files in that
             *   level. Now for these cases, HMI can just pass the sessionID as an input
                  
             *          based on project requirements,we can play all the files in the current
             *   folder browse level or include the 
                           subfolders.
             * param: sessionID: The Session ID alloted.
             * param: filterIDs: The previously communicated numeric identifiers of the different
             *   filter categories.
             */
            { { "playSession", "ua{it}" }, &com::harman::mmpres::MediaBrowserDBusStubAdapterInternal::playSessionStubDispatcher },
            /**
             * description: This requests the pres to directly jump to the file system level or metadata
             *   browse path level which
                                contains the currently playing
             *   track and returns the number of items in that level matching the filter 
                 
             *                 criteria. 
            	
                                For example, after connecting
             *   the USB and selecting it for playback and it starts playing some file 
                   
             *               (which is at the 4th nested level from root). 
            	
                             
             *     Now clicking on browse icon, based on project requirement , we can directly
             *   jump to the 4th nested level
                                (assuming it is the
             *   nowplaying level) by calling this API.
            
                               [TODO]:The
             *   interface input & output parameters are yet to be finalized. To check if the
             *   interface can be 
                               combined with setSessionQuery.
             */
            { { "gotoNowplayingLevel", "ut" }, &com::harman::mmpres::MediaBrowserDBusStubAdapterInternal::gotoNowplayingLevelStubDispatcher }
            ,
            { { "subscribeForsessionQueryUpdateSelective", "" }, &com::harman::mmpres::MediaBrowserDBusStubAdapterInternal::subscribeSessionQueryUpdateSelectiveStubDispatcher }
            ,
            { { "unsubscribeFromsessionQueryUpdateSelective", "" }, &com::harman::mmpres::MediaBrowserDBusStubAdapterInternal::unsubscribeSessionQueryUpdateSelectiveStubDispatcher },
            { { "subscribeForsessionQueryWindowUpdateSelective", "" }, &com::harman::mmpres::MediaBrowserDBusStubAdapterInternal::subscribeSessionQueryWindowUpdateSelectiveStubDispatcher }
            ,
            { { "unsubscribeFromsessionQueryWindowUpdateSelective", "" }, &com::harman::mmpres::MediaBrowserDBusStubAdapterInternal::unsubscribeSessionQueryWindowUpdateSelectiveStubDispatcher }
            }),
        stubAttributeTable_() {
    subscribersForSessionQueryUpdateSelective_ = std::make_shared<CommonAPI::ClientIdList>();
    subscribersForSessionQueryWindowUpdateSelective_ = std::make_shared<CommonAPI::ClientIdList>();

    stubDispatcherTable_.insert({ { "getInterfaceVersion", "" }, &com::harman::mmpres::MediaBrowserDBusStubAdapterInternal::getMediaBrowserInterfaceVersionStubDispatcher });
}

bool MediaBrowserDBusStubAdapterInternal::hasFreedesktopProperties() {
    return false;
}

} // namespace mmpres
} // namespace harman
} // namespace com
} // namespace v1
