/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Thu Sep 22 00:23:23 IST 2016
*/
#include <v1/com/harman/btpres/PimDbHandler.hpp>
#include <v1/com/harman/btpres/PimDbHandlerDBusStubAdapter.hpp>

namespace v1 {
namespace com {
namespace harman {
namespace btpres {

std::shared_ptr<CommonAPI::DBus::DBusStubAdapter> createPimDbHandlerDBusStubAdapter(
                   const CommonAPI::DBus::DBusAddress &_address,
                   const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection,
                   const std::shared_ptr<CommonAPI::StubBase> &_stub) {
    return std::make_shared<PimDbHandlerDBusStubAdapter>(_address, _connection, _stub);
}

INITIALIZER(registerPimDbHandlerDBusStubAdapter) {
    CommonAPI::DBus::Factory::get()->registerStubAdapterCreateMethod(
    	PimDbHandler::getInterface(), &createPimDbHandlerDBusStubAdapter);
}

PimDbHandlerDBusStubAdapterInternal::~PimDbHandlerDBusStubAdapterInternal() {
    deactivateManagedInstances();
    PimDbHandlerDBusStubAdapterHelper::deinit();
}

void PimDbHandlerDBusStubAdapterInternal::deactivateManagedInstances() {

}

const char* PimDbHandlerDBusStubAdapterInternal::getMethodsDBusIntrospectionXmlData() const {
    static const std::string introspectionData =
        "<method name=\"getInterfaceVersion\">\n"
            "<arg name=\"value\" type=\"uu\" direction=\"out\" />"
        "</method>\n"
        "<method name=\"getContactNameOrderAttribute\">\n"
            "<arg name=\"value\" type=\"i\" direction=\"out\" />"
        "</method>\n"
        "<signal name=\"onContactNameOrderAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"i\" />\n"
        "</signal>\n"
        "<method name=\"getDeviceListAttribute\">\n"
            "<arg name=\"value\" type=\"a(sa{ii})\" direction=\"out\" />"
        "</method>\n"
        "<signal name=\"onDeviceListAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"a(sa{ii})\" />\n"
        "</signal>\n"
        /**
         * description: Will only be posted to the respective listeners if the session query parameters
         *   have changed. 
                             For example, for  Calllist and SMS can be
         *   changed dynamically based on new SMS or new Call Stack.  Will be published 
          
         *                     only if auto update was enabled when setting the query.
         * param: sessionID: The Session ID alloted.
         * param: sessionQueryID: Allocated session queruy ID
         * param: numResults: Total number of result
         * param: unreadCount: This will be sent updated for unread SMS count and unread missed
         *   call count
         */
        "<signal name=\"sessionQueryUpdate\">\n"
            "<arg name=\"sessionID\" type=\"y\" />\n"
            "<arg name=\"sessionQueryID\" type=\"y\" />\n"
            "<arg name=\"numResults\" type=\"q\" />\n"
            "<arg name=\"unreadCount\" type=\"y\" />\n"
            "<arg name=\"alphaList\" type=\"a(sq)\" />\n"
        "</signal>\n"
        /**
         * description: Publishes the query status to all clients. The client can get the data once the
         *   query is "finished"
         */
        "<signal name=\"sessionQueryWindowUpdate\">\n"
            "<arg name=\"sessionID\" type=\"y\" />\n"
            "<arg name=\"sessionQueryID\" type=\"y\" />\n"
            "<arg name=\"startIndex\" type=\"q\" />\n"
            "<arg name=\"numItems\" type=\"y\" />\n"
            "<arg name=\"phonebookList\" type=\"a(qqxia{is}a{ias}a{i(ssssssss)}a{ias}a{is})\" />\n"
        "</signal>\n"
        /**
         * description: Publishes only when session is closed due to device disconnect or client request
         */
        "<signal name=\"sessionClosed\">\n"
            "<arg name=\"sessionID\" type=\"y\" />\n"
            "<arg name=\"sessionQueryID\" type=\"y\" />\n"
            "<arg name=\"errorCode\" type=\"i\" />\n"
        "</signal>\n"
        /**
         * description: This signal will be sent when a new missed call notification is received (after
         *   the phone is connected to Head Unit).
         * param: inAddress: BD Address of Device
         * param: number: Missed call number of latest missed call
         * param: name: formatted Name of the contact
         * param: unreadCount: This is the current count of unread-missed call.
         */
        "<signal name=\"unreadMissedCall\">\n"
            "<arg name=\"inAddress\" type=\"s\" />\n"
            "<arg name=\"number\" type=\"s\" />\n"
            "<arg name=\"name\" type=\"s\" />\n"
            "<arg name=\"unreadCount\" type=\"y\" />\n"
        "</signal>\n"
        /**
         * description: This signal will be sent when a newCallList is available, after a call.
         * param: inAddress: BD Address of Device
         * param: newCallStackEntry : New call stack entry
         */
        "<signal name=\"newCallList\">\n"
            "<arg name=\"inAddress\" type=\"s\" />\n"
            "<arg name=\"newCallStackEntry\" type=\"(a{is}isssiu)\" />\n"
        "</signal>\n"
        /**
         * description: This signal will be emitted , when send sms is invoked : sent & delivered
         *   (success or failure)
         * param: inAddress: BD Address of Device
         * param: smsId: smsID of the sent SMS
         * param: notification: Status of the sent SMS
         */
        "<signal name=\"SMSNotification\">\n"
            "<arg name=\"inAddress\" type=\"s\" />\n"
            "<arg name=\"smsId\" type=\"x\" />\n"
            "<arg name=\"notification\" type=\"i\" />\n"
        "</signal>\n"
        /**
         * description: Opens a session for the client communication. This session will be used
         *   internally to uniquely identify a client, and to maintain client specific
         *   caches.
                             The client need not create a new session for
         *   every request, this is rather used to identify different instances of clients.
         *     
                             
               returns: sessionID: Session identifier
         *   allocated to the client.
         */
        "<method name=\"openSession\">\n"
            "<arg name=\"_inAddress\" type=\"s\" direction=\"in\" />\n"
            "<arg name=\"_sessionID\" type=\"y\" direction=\"out\" />\n"
            "<arg name=\"_ErrorCode\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: Close a client session and release all associated resources.
         * param: sessionID: The Session ID to close.
         */
        "<method name=\"closeSession\">\n"
            "<arg name=\"_sessionID\" type=\"y\" direction=\"in\" />\n"
            "<arg name=\"_ErrorCode\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: Sets a session query. This api handles all requests to fetch Phonebook results,
         *   database searches, etc. 
                             As an example. If the HMI wanted
         *   to fetch a list of all contacts. The filterID's' and filter's' will be empty,
         *   and the result type would be set to Required field list.
         * param: filterIDs: The previously communicated numeric identifiers of the different
         *   filter categories.
         * param: filters: The string filters which should be applied to the result.
         * param: resultType: The data which is expected from the query.
         * param: sessionID: Session ID obtained from OpenSession.
         * param: databaseType: Related database for this sessionquery.
         * param: RequiredField: List of required field , if default is set browsing item will be
         *   sent with default avlues based on config
         * param: resetPrevious: Whether to use old history or not.If true treat this as a new
         *   session query, do not use any old selection history.
         * param: AutoUpdateEnabled: This is applicable for result sets which might update
         *   dynamically,Call stack or Fav list
                  							 
               returns:
         *   numResults: The number of records matching the search criteria.
              
         *   returns: SessionQueryID:The sessionQueryID allotted.This uniquely identifies a
         *   particular session query/filter for retrieving data in a session and it has to
         *   be passed 
                                        for furthur setting the
         *   sessionQuery window and retrieving the contents of that window.
         */
        "<method name=\"setSessionQuery\">\n"
            "<arg name=\"_sessionID\" type=\"y\" direction=\"in\" />\n"
            "<arg name=\"_databaseType\" type=\"i\" direction=\"in\" />\n"
            "<arg name=\"_filterIDs\" type=\"a{iy}\" direction=\"in\" />\n"
            "<arg name=\"_filters\" type=\"a{is}\" direction=\"in\" />\n"
            "<arg name=\"_RequiredField\" type=\"a{ib}\" direction=\"in\" />\n"
            "<arg name=\"_resetPrevious\" type=\"b\" direction=\"in\" />\n"
            "<arg name=\"_AutoUpdateEnabled\" type=\"b\" direction=\"in\" />\n"
            "<arg name=\"_AlphaJumpTable\" type=\"b\" direction=\"in\" />\n"
            "<arg name=\"_errorCode\" type=\"i\" direction=\"out\" />\n"
            "<arg name=\"_numResults\" type=\"u\" direction=\"out\" />\n"
            "<arg name=\"_sessionQueryID\" type=\"y\" direction=\"out\" />\n"
            "<arg name=\"_unreadCount\" type=\"y\" direction=\"out\" />\n"
            "<arg name=\"_alphaList\" type=\"a(sq)\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: Essentially re-initializes a session and stops all background tasks.
         * param: sessionID: The Session ID alloted.
         */
        "<method name=\"cancelSessionQuery\">\n"
            "<arg name=\"_sessionID\" type=\"y\" direction=\"in\" />\n"
            "<arg name=\"_errorCode\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: Ask presentation control to fetch the desired set of entries for a particular
         *   session query. This call does not block for the result to complete, and will
         *   override
                             the last request given to Pres Ctrl.
         * param: sessionID: The Session ID alloted.
         * param: sessionQueryID: The sessionQueryID allotted.This uniquely identifies a
         *   particular session query/filter for retrieving data in a session and it has to
         *   be passed 
                                       for furthur setting the sessionQuery
         *   window and retrieving the contents of that window.
         * param: startIndex: The index to start fetching.
         * param: numItems: The number of items to fetch.     
                 
               returns:
         *   windowID: A unique identifier for the client to track data responses to the
         *   queries.
         */
        "<method name=\"setSessionQueryWindow\">\n"
            "<arg name=\"_sessionID\" type=\"y\" direction=\"in\" />\n"
            "<arg name=\"_sessionQueryID\" type=\"y\" direction=\"in\" />\n"
            "<arg name=\"_startIndex\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"_numItems\" type=\"y\" direction=\"in\" />\n"
            "<arg name=\"_errorCode\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: This method is used for inserting contacts to Favourite list 
                         
         *      Hence the only acceptable value for "database" parameter is "ab".
         * param: inAddress: BD Address of Device
         * param: databaseType: Different database of Pim, Only Fav is allowed
         * param: requestID: Different type of user initiated DB operation
         * param: itemDetails: This list is a union of contactID list, NewPhonebook entry,
         *   SMSTemplateID list, SMStemplate
        	 		     
               returns: This method returns
         *   errorcode
         */
        "<method name=\"dbOperation\">\n"
            "<arg name=\"_inAddress\" type=\"s\" direction=\"in\" />\n"
            "<arg name=\"_databaseType\" type=\"i\" direction=\"in\" />\n"
            "<arg name=\"_requestID\" type=\"i\" direction=\"in\" />\n"
            "<arg name=\"_itemDetails\" type=\"(aqs(qqxia{is}a{ias}a{i(ssssssss)}a{ias}a{is})ay)\" direction=\"in\" />\n"
            "<arg name=\"_errorCode\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: This API can be used to get Contact Name by contactID
         * param: inAddress: BD Address of Device
         * param: databaseType: Different database of Pim.Currently only available for "pb" or
         *   "ab"
         * param: contactID: contactID for which contact details should be extracted
         * param: fieldList: Required filedlist using bit masking ()
        	 		     
               returns:	  
         *    phonebookEntry which will contain all the field
         */
        "<method name=\"getContactsByID\">\n"
            "<arg name=\"_inAddress\" type=\"s\" direction=\"in\" />\n"
            "<arg name=\"_databaseType\" type=\"i\" direction=\"in\" />\n"
            "<arg name=\"_contactID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"_FieldList\" type=\"a{iy}\" direction=\"in\" />\n"
            "<arg name=\"_errorCode\" type=\"i\" direction=\"out\" />\n"
            "<arg name=\"_detailedContact\" type=\"(qqxia{is}a{ias}a{i(ssssssss)}a{ias}a{is})\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: This API is used to get the full details of the SMS; this takes a unique id as
         *   input, which is received from the signal
         * param: inAddress: BD Address of Device
         * param: smsId: Unique id for SMS that is returned as part of the signal (multiple uid’s
         *   can be sent, separated)
        	 		     
               returns: This method returns SMS entry
         */
        "<method name=\"getSMSById\">\n"
            "<arg name=\"_inAddress\" type=\"s\" direction=\"in\" />\n"
            "<arg name=\"_smsId\" type=\"x\" direction=\"in\" />\n"
            "<arg name=\"_errorCode\" type=\"i\" direction=\"out\" />\n"
            "<arg name=\"_sms\" type=\"(ssssssxb)\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: This API can be used to get the following details on either phonebook 
                
         *               1.	The next valid characters mask that match the input string.
           
         *                    2.	The count of the names that matched the input string.
            
         *                   3.	The index of the first match of the input string sorted by
         *   givenName column. (This index can be used in getItems API to query for the
         *   details but the same sort criteria need to be applied).
         * param: inAddress: BD Address of Device
         * param: databaseType: Different database of Pim. Currently only available for Pb or ab
         * param: inputName: String to be searched
         * param: sortOrder: ascending or descending
         * param: condition: either or all based on notnullcolumnList 
               	 		     
              
         *   returns:      contactsCount:The count of the names that matched the input
         *   string.
               returns:      index:The index of the first match of the input
         *   string sorted by formattedName column.
               returns:      charactersMask:The
         *   next valid characters mask that match the input string.
               returns:     
         *   firstMatch:The “formattedName” of the first matched contact
         */
        "<method name=\"getNextValidCharacters\">\n"
            "<arg name=\"_inAddress\" type=\"s\" direction=\"in\" />\n"
            "<arg name=\"_databaseType\" type=\"i\" direction=\"in\" />\n"
            "<arg name=\"_inputName\" type=\"s\" direction=\"in\" />\n"
            "<arg name=\"_sortOrder\" type=\"s\" direction=\"in\" />\n"
            "<arg name=\"_condition\" type=\"s\" direction=\"in\" />\n"
            "<arg name=\"_errorCode\" type=\"i\" direction=\"out\" />\n"
            "<arg name=\"_contactsCount\" type=\"q\" direction=\"out\" />\n"
            "<arg name=\"_index\" type=\"q\" direction=\"out\" />\n"
            "<arg name=\"_charactersMask\" type=\"s\" direction=\"out\" />\n"
            "<arg name=\"_firstMatch\" type=\"s\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: This API is used to send the SMS to the destined number.
         * param: inAddress: BD Address of Device
         * param: destinationNumber: This indicates destination number of the SMS
         * param: smsBody: Describes the body of SMS to be sent
        	 		     
               returns:	This
         *   methods return success or failure
               returns: contactName: Contact Name to
         *   which SMS is sent
         */
        "<method name=\"sendSMSByTemplateID\">\n"
            "<arg name=\"_inAddress\" type=\"s\" direction=\"in\" />\n"
            "<arg name=\"_destinationNumber\" type=\"s\" direction=\"in\" />\n"
            "<arg name=\"_TemplateID\" type=\"y\" direction=\"in\" />\n"
            "<arg name=\"_smsBody\" type=\"s\" direction=\"in\" />\n"
            "<arg name=\"_errorCode\" type=\"i\" direction=\"out\" />\n"
            "<arg name=\"_contactName\" type=\"s\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: This API is used to set the status of a sms (as READ/UNREAD).
         * param: inAddress: BD Address of Device
         * param: smsId: Unique sms identifier
         * param: read_status: The status value that needs to be set. The valid values are “READ”
         *   or “UNREAD”
        	 		     
               returns: This method returns errorcode
         */
        "<method name=\"setSMSReadStatus\">\n"
            "<arg name=\"_inAddress\" type=\"s\" direction=\"in\" />\n"
            "<arg name=\"_smsId\" type=\"x\" direction=\"in\" />\n"
            "<arg name=\"_sms_read_status\" type=\"b\" direction=\"in\" />\n"
            "<arg name=\"_errorCode\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: This method is used to set the sorted name order.
         * param: inAddress: BD Address of Device (Considered only if project support device
         *   specific sorting order)
         * param: contact Name order
         */
        "<method name=\"setFormattedNameOrder\">\n"
            "<arg name=\"_inAddress\" type=\"s\" direction=\"in\" />\n"
            "<arg name=\"_contactNameOrder\" type=\"i\" direction=\"in\" />\n"
            "<arg name=\"_errorCode\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"

    ;
    return introspectionData.c_str();
}

CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        ::v1::com::harman::btpres::PimDbHandlerStub,
        CommonAPI::Version
        > PimDbHandlerDBusStubAdapterInternal::getPimDbHandlerInterfaceVersionStubDispatcher(&PimDbHandlerStub::getInterfaceVersion, "uu");

/**
 * description: formattedNameOrder is sorted name order, which can be set from HMI
 */
CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        ::v1::com::harman::btpres::PimDbHandlerStub,
        ::v1::com::harman::btpres::BTPresTypes::eContactNameOredr
        > PimDbHandlerDBusStubAdapterInternal::getContactNameOrderAttributeStubDispatcher(
            &::v1::com::harman::btpres::PimDbHandlerStub::getContactNameOrderAttribute
            , "i"
            );
/**
 * description: DeviceList will contain list of paired device and their syncstatus
 */
CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        ::v1::com::harman::btpres::PimDbHandlerStub,
        ::v1::com::harman::btpres::BTPresTypes::pimPropertiesList,
        ::v1::com::harman::btpres::BTPresTypes_::pimPropertiesListDeployment_t
        > PimDbHandlerDBusStubAdapterInternal::getDeviceListAttributeStubDispatcher(
            &::v1::com::harman::btpres::PimDbHandlerStub::getDeviceListAttribute
            , "a(sa{ii})"
            );



/**
 * description: Opens a session for the client communication. This session will be used
 *   internally to uniquely identify a client, and to maintain client specific
 *   caches.
                     The client need not create a new session for
 *   every request, this is rather used to identify different instances of clients.
 *     
                     
       returns: sessionID: Session identifier
 *   allocated to the client.
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v1::com::harman::btpres::PimDbHandlerStub,
    std::tuple<std::string>,
    std::tuple<uint8_t, ::v1::com::harman::btpres::BTPresTypes::eErrorType>,
    std::tuple<CommonAPI::DBus::StringDeployment>,
    std::tuple<CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment>
    
    > PimDbHandlerDBusStubAdapterInternal::openSessionStubDispatcher(
    &PimDbHandlerStub::openSession, "yi",
					std::make_tuple(static_cast<CommonAPI::DBus::StringDeployment*>(nullptr)),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr)));

/**
 * description: Close a client session and release all associated resources.
 * param: sessionID: The Session ID to close.
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v1::com::harman::btpres::PimDbHandlerStub,
    std::tuple<uint8_t>,
    std::tuple<::v1::com::harman::btpres::BTPresTypes::eErrorType>,
    std::tuple<CommonAPI::EmptyDeployment>,
    std::tuple<CommonAPI::EmptyDeployment>
    
    > PimDbHandlerDBusStubAdapterInternal::closeSessionStubDispatcher(
    &PimDbHandlerStub::closeSession, "i",
					std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)));

/**
 * description: Sets a session query. This api handles all requests to fetch Phonebook results,
 *   database searches, etc. 
                     As an example. If the HMI wanted
 *   to fetch a list of all contacts. The filterID's' and filter's' will be empty,
 *   and the result type would be set to Required field list.
 * param: filterIDs: The previously communicated numeric identifiers of the different
 *   filter categories.
 * param: filters: The string filters which should be applied to the result.
 * param: resultType: The data which is expected from the query.
 * param: sessionID: Session ID obtained from OpenSession.
 * param: databaseType: Related database for this sessionquery.
 * param: RequiredField: List of required field , if default is set browsing item will be
 *   sent with default avlues based on config
 * param: resetPrevious: Whether to use old history or not.If true treat this as a new
 *   session query, do not use any old selection history.
 * param: AutoUpdateEnabled: This is applicable for result sets which might update
 *   dynamically,Call stack or Fav list
          							 
       returns:
 *   numResults: The number of records matching the search criteria.
      
 *   returns: SessionQueryID:The sessionQueryID allotted.This uniquely identifies a
 *   particular session query/filter for retrieving data in a session and it has to
 *   be passed 
                                for furthur setting the
 *   sessionQuery window and retrieving the contents of that window.
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v1::com::harman::btpres::PimDbHandlerStub,
    std::tuple<uint8_t, ::v1::com::harman::btpres::BTPresTypes::eDatabaseType, ::v1::com::harman::btpres::BTPresTypes::phonebookResultMap, ::v1::com::harman::btpres::BTPresTypes::filterMap, ::v1::com::harman::btpres::BTPresTypes::requiredFieldMap, bool, bool, bool>,
    std::tuple<::v1::com::harman::btpres::BTPresTypes::eErrorType, uint32_t, uint8_t, uint8_t, ::v1::com::harman::btpres::BTPresTypes::alphaJumpList>,
    std::tuple<CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment, ::v1::com::harman::btpres::BTPresTypes_::phonebookResultMapDeployment_t, ::v1::com::harman::btpres::BTPresTypes_::filterMapDeployment_t, ::v1::com::harman::btpres::BTPresTypes_::requiredFieldMapDeployment_t, CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment>,
    std::tuple<CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment, ::v1::com::harman::btpres::BTPresTypes_::alphaJumpListDeployment_t>
    
    > PimDbHandlerDBusStubAdapterInternal::setSessionQueryStubDispatcher(
    &PimDbHandlerStub::setSessionQuery, "iuyya(sq)",
					std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<::v1::com::harman::btpres::BTPresTypes_::phonebookResultMapDeployment_t*>(nullptr), static_cast<::v1::com::harman::btpres::BTPresTypes_::filterMapDeployment_t*>(nullptr), static_cast<::v1::com::harman::btpres::BTPresTypes_::requiredFieldMapDeployment_t*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<::v1::com::harman::btpres::BTPresTypes_::alphaJumpListDeployment_t*>(nullptr)));

/**
 * description: Essentially re-initializes a session and stops all background tasks.
 * param: sessionID: The Session ID alloted.
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v1::com::harman::btpres::PimDbHandlerStub,
    std::tuple<uint8_t>,
    std::tuple<::v1::com::harman::btpres::BTPresTypes::eErrorType>,
    std::tuple<CommonAPI::EmptyDeployment>,
    std::tuple<CommonAPI::EmptyDeployment>
    
    > PimDbHandlerDBusStubAdapterInternal::cancelSessionQueryStubDispatcher(
    &PimDbHandlerStub::cancelSessionQuery, "i",
					std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)));

/**
 * description: Ask presentation control to fetch the desired set of entries for a particular
 *   session query. This call does not block for the result to complete, and will
 *   override
                     the last request given to Pres Ctrl.
 * param: sessionID: The Session ID alloted.
 * param: sessionQueryID: The sessionQueryID allotted.This uniquely identifies a
 *   particular session query/filter for retrieving data in a session and it has to
 *   be passed 
                               for furthur setting the sessionQuery
 *   window and retrieving the contents of that window.
 * param: startIndex: The index to start fetching.
 * param: numItems: The number of items to fetch.     
         
       returns:
 *   windowID: A unique identifier for the client to track data responses to the
 *   queries.
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v1::com::harman::btpres::PimDbHandlerStub,
    std::tuple<uint8_t, uint8_t, uint16_t, uint8_t>,
    std::tuple<::v1::com::harman::btpres::BTPresTypes::eErrorType>,
    std::tuple<CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment>,
    std::tuple<CommonAPI::EmptyDeployment>
    
    > PimDbHandlerDBusStubAdapterInternal::setSessionQueryWindowStubDispatcher(
    &PimDbHandlerStub::setSessionQueryWindow, "i",
					std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)));

/**
 * description: This method is used for inserting contacts to Favourite list 
                 
 *      Hence the only acceptable value for "database" parameter is "ab".
 * param: inAddress: BD Address of Device
 * param: databaseType: Different database of Pim, Only Fav is allowed
 * param: requestID: Different type of user initiated DB operation
 * param: itemDetails: This list is a union of contactID list, NewPhonebook entry,
 *   SMSTemplateID list, SMStemplate
	 		     
       returns: This method returns
 *   errorcode
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v1::com::harman::btpres::PimDbHandlerStub,
    std::tuple<std::string, ::v1::com::harman::btpres::BTPresTypes::eDatabaseType, ::v1::com::harman::btpres::BTPresTypes::eDbOperationId, ::v1::com::harman::btpres::BTPresTypes::InsertItems>,
    std::tuple<::v1::com::harman::btpres::BTPresTypes::eErrorType>,
    std::tuple<CommonAPI::DBus::StringDeployment, CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment, ::v1::com::harman::btpres::BTPresTypes_::InsertItemsDeployment_t>,
    std::tuple<CommonAPI::EmptyDeployment>
    
    > PimDbHandlerDBusStubAdapterInternal::dbOperationStubDispatcher(
    &PimDbHandlerStub::dbOperation, "i",
					std::make_tuple(static_cast<CommonAPI::DBus::StringDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<::v1::com::harman::btpres::BTPresTypes_::InsertItemsDeployment_t*>(nullptr)),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)));

/**
 * description: This API can be used to get Contact Name by contactID
 * param: inAddress: BD Address of Device
 * param: databaseType: Different database of Pim.Currently only available for "pb" or
 *   "ab"
 * param: contactID: contactID for which contact details should be extracted
 * param: fieldList: Required filedlist using bit masking ()
	 		     
       returns:	  
 *    phonebookEntry which will contain all the field
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v1::com::harman::btpres::PimDbHandlerStub,
    std::tuple<std::string, ::v1::com::harman::btpres::BTPresTypes::eDatabaseType, uint16_t, ::v1::com::harman::btpres::BTPresTypes::phonebookResultMap>,
    std::tuple<::v1::com::harman::btpres::BTPresTypes::eErrorType, ::v1::com::harman::btpres::BTPresTypes::phonebookEntry>,
    std::tuple<CommonAPI::DBus::StringDeployment, CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment, ::v1::com::harman::btpres::BTPresTypes_::phonebookResultMapDeployment_t>,
    std::tuple<CommonAPI::EmptyDeployment, ::v1::com::harman::btpres::BTPresTypes_::phonebookEntryDeployment_t>
    
    > PimDbHandlerDBusStubAdapterInternal::getContactsByIDStubDispatcher(
    &PimDbHandlerStub::getContactsByID, "i(qqxia{is}a{ias}a{i(ssssssss)}a{ias}a{is})",
					std::make_tuple(static_cast<CommonAPI::DBus::StringDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<::v1::com::harman::btpres::BTPresTypes_::phonebookResultMapDeployment_t*>(nullptr)),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<::v1::com::harman::btpres::BTPresTypes_::phonebookEntryDeployment_t*>(nullptr)));

/**
 * description: This API is used to get the full details of the SMS; this takes a unique id as
 *   input, which is received from the signal
 * param: inAddress: BD Address of Device
 * param: smsId: Unique id for SMS that is returned as part of the signal (multiple uid’s
 *   can be sent, separated)
	 		     
       returns: This method returns SMS entry
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v1::com::harman::btpres::PimDbHandlerStub,
    std::tuple<std::string, int64_t>,
    std::tuple<::v1::com::harman::btpres::BTPresTypes::eErrorType, ::v1::com::harman::btpres::BTPresTypes::smsEntry>,
    std::tuple<CommonAPI::DBus::StringDeployment, CommonAPI::EmptyDeployment>,
    std::tuple<CommonAPI::EmptyDeployment, ::v1::com::harman::btpres::BTPresTypes_::smsEntryDeployment_t>
    
    > PimDbHandlerDBusStubAdapterInternal::getSMSByIdStubDispatcher(
    &PimDbHandlerStub::getSMSById, "i(ssssssxb)",
					std::make_tuple(static_cast<CommonAPI::DBus::StringDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<::v1::com::harman::btpres::BTPresTypes_::smsEntryDeployment_t*>(nullptr)));

/**
 * description: This API can be used to get the following details on either phonebook 
        
 *               1.	The next valid characters mask that match the input string.
   
 *                    2.	The count of the names that matched the input string.
    
 *                   3.	The index of the first match of the input string sorted by
 *   givenName column. (This index can be used in getItems API to query for the
 *   details but the same sort criteria need to be applied).
 * param: inAddress: BD Address of Device
 * param: databaseType: Different database of Pim. Currently only available for Pb or ab
 * param: inputName: String to be searched
 * param: sortOrder: ascending or descending
 * param: condition: either or all based on notnullcolumnList 
       	 		     
      
 *   returns:      contactsCount:The count of the names that matched the input
 *   string.
       returns:      index:The index of the first match of the input
 *   string sorted by formattedName column.
       returns:      charactersMask:The
 *   next valid characters mask that match the input string.
       returns:     
 *   firstMatch:The “formattedName” of the first matched contact
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v1::com::harman::btpres::PimDbHandlerStub,
    std::tuple<std::string, ::v1::com::harman::btpres::BTPresTypes::eDatabaseType, std::string, std::string, std::string>,
    std::tuple<::v1::com::harman::btpres::BTPresTypes::eErrorType, uint16_t, uint16_t, std::string, std::string>,
    std::tuple<CommonAPI::DBus::StringDeployment, CommonAPI::EmptyDeployment, CommonAPI::DBus::StringDeployment, CommonAPI::DBus::StringDeployment, CommonAPI::DBus::StringDeployment>,
    std::tuple<CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment, CommonAPI::DBus::StringDeployment, CommonAPI::DBus::StringDeployment>
    
    > PimDbHandlerDBusStubAdapterInternal::getNextValidCharactersStubDispatcher(
    &PimDbHandlerStub::getNextValidCharacters, "iqqss",
					std::make_tuple(static_cast<CommonAPI::DBus::StringDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::DBus::StringDeployment*>(nullptr), static_cast<CommonAPI::DBus::StringDeployment*>(nullptr), static_cast<CommonAPI::DBus::StringDeployment*>(nullptr)),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::DBus::StringDeployment*>(nullptr), static_cast<CommonAPI::DBus::StringDeployment*>(nullptr)));

/**
 * description: This API is used to send the SMS to the destined number.
 * param: inAddress: BD Address of Device
 * param: destinationNumber: This indicates destination number of the SMS
 * param: smsBody: Describes the body of SMS to be sent
	 		     
       returns:	This
 *   methods return success or failure
       returns: contactName: Contact Name to
 *   which SMS is sent
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v1::com::harman::btpres::PimDbHandlerStub,
    std::tuple<std::string, std::string, uint8_t, std::string>,
    std::tuple<::v1::com::harman::btpres::BTPresTypes::eErrorType, std::string>,
    std::tuple<CommonAPI::DBus::StringDeployment, CommonAPI::DBus::StringDeployment, CommonAPI::EmptyDeployment, CommonAPI::DBus::StringDeployment>,
    std::tuple<CommonAPI::EmptyDeployment, CommonAPI::DBus::StringDeployment>
    
    > PimDbHandlerDBusStubAdapterInternal::sendSMSByTemplateIDStubDispatcher(
    &PimDbHandlerStub::sendSMSByTemplateID, "is",
					std::make_tuple(static_cast<CommonAPI::DBus::StringDeployment*>(nullptr), static_cast<CommonAPI::DBus::StringDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::DBus::StringDeployment*>(nullptr)),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::DBus::StringDeployment*>(nullptr)));

/**
 * description: This API is used to set the status of a sms (as READ/UNREAD).
 * param: inAddress: BD Address of Device
 * param: smsId: Unique sms identifier
 * param: read_status: The status value that needs to be set. The valid values are “READ”
 *   or “UNREAD”
	 		     
       returns: This method returns errorcode
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v1::com::harman::btpres::PimDbHandlerStub,
    std::tuple<std::string, int64_t, bool>,
    std::tuple<::v1::com::harman::btpres::BTPresTypes::eErrorType>,
    std::tuple<CommonAPI::DBus::StringDeployment, CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment>,
    std::tuple<CommonAPI::EmptyDeployment>
    
    > PimDbHandlerDBusStubAdapterInternal::setSMSReadStatusStubDispatcher(
    &PimDbHandlerStub::setSMSReadStatus, "i",
					std::make_tuple(static_cast<CommonAPI::DBus::StringDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)));

/**
 * description: This method is used to set the sorted name order.
 * param: inAddress: BD Address of Device (Considered only if project support device
 *   specific sorting order)
 * param: contact Name order
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v1::com::harman::btpres::PimDbHandlerStub,
    std::tuple<std::string, ::v1::com::harman::btpres::BTPresTypes::eContactNameOredr>,
    std::tuple<::v1::com::harman::btpres::BTPresTypes::eErrorType>,
    std::tuple<CommonAPI::DBus::StringDeployment, CommonAPI::EmptyDeployment>,
    std::tuple<CommonAPI::EmptyDeployment>
    
    > PimDbHandlerDBusStubAdapterInternal::setFormattedNameOrderStubDispatcher(
    &PimDbHandlerStub::setFormattedNameOrder, "i",
					std::make_tuple(static_cast<CommonAPI::DBus::StringDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)));


/**
 * description: formattedNameOrder is sorted name order, which can be set from HMI
 */
void PimDbHandlerDBusStubAdapterInternal::fireContactNameOrderAttributeChanged(const ::v1::com::harman::btpres::BTPresTypes::eContactNameOredr& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<
    ::v1::com::harman::btpres::BTPresTypes::eContactNameOredr
    >>
        ::sendSignal(
            *this,
            "onContactNameOrderAttributeChanged",
            "i",
            value
    
    );
}
/**
 * description: DeviceList will contain list of paired device and their syncstatus
 */
void PimDbHandlerDBusStubAdapterInternal::fireDeviceListAttributeChanged(const ::v1::com::harman::btpres::BTPresTypes::pimPropertiesList& value) {
    CommonAPI::Deployable<::v1::com::harman::btpres::BTPresTypes::pimPropertiesList, ::v1::com::harman::btpres::BTPresTypes_::pimPropertiesListDeployment_t> deployedValue(value, static_cast<::v1::com::harman::btpres::BTPresTypes_::pimPropertiesListDeployment_t*>(nullptr));
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<
    CommonAPI::Deployable<
        ::v1::com::harman::btpres::BTPresTypes::pimPropertiesList,
        ::v1::com::harman::btpres::BTPresTypes_::pimPropertiesListDeployment_t
    >
    >>
        ::sendSignal(
            *this,
            "onDeviceListAttributeChanged",
            "a(sa{ii})",
            deployedValue
    
    );
}

/**
 * description: Will only be posted to the respective listeners if the session query parameters
 *   have changed. 
                     For example, for  Calllist and SMS can be
 *   changed dynamically based on new SMS or new Call Stack.  Will be published 
  
 *                     only if auto update was enabled when setting the query.
 * param: sessionID: The Session ID alloted.
 * param: sessionQueryID: Allocated session queruy ID
 * param: numResults: Total number of result
 * param: unreadCount: This will be sent updated for unread SMS count and unread missed
 *   call count
 */
CommonAPI::DBus::DBusMethodWithReplyAdapterDispatcher<
    ::v1::com::harman::btpres::PimDbHandlerStub,
    PimDbHandlerStubAdapter,
    std::tuple<>,
    std::tuple<bool>
    > PimDbHandlerDBusStubAdapterInternal::subscribeSessionQueryUpdateSelectiveStubDispatcher(&PimDbHandlerStubAdapter::subscribeForsessionQueryUpdateSelective, "b");

CommonAPI::DBus::DBusMethodWithReplyAdapterDispatcher<
    ::v1::com::harman::btpres::PimDbHandlerStub,
    PimDbHandlerStubAdapter,
    std::tuple<>,
    std::tuple<>
    > PimDbHandlerDBusStubAdapterInternal::unsubscribeSessionQueryUpdateSelectiveStubDispatcher(&PimDbHandlerStubAdapter::unsubscribeFromsessionQueryUpdateSelective, "");

void PimDbHandlerDBusStubAdapterInternal::fireSessionQueryUpdateSelective(const std::shared_ptr<CommonAPI::ClientId> _client, const uint8_t &_sessionID, const uint8_t &_sessionQueryID, const uint16_t &_numResults, const uint8_t &_unreadCount, const ::v1::com::harman::btpres::BTPresTypes::alphaJumpList &_alphaList) {
    std::shared_ptr<CommonAPI::DBus::DBusClientId> dbusClient = std::dynamic_pointer_cast<CommonAPI::DBus::DBusClientId, CommonAPI::ClientId>(_client);

    if(dbusClient)
    {
        CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<
        uint8_t,
        uint8_t,
        uint16_t,
        uint8_t,
        CommonAPI::Deployable<::v1::com::harman::btpres::BTPresTypes::alphaJumpList, ::v1::com::harman::btpres::BTPresTypes_::alphaJumpListDeployment_t>
        >>::sendSignal(
                dbusClient->getDBusId(),
                *this,
                "sessionQueryUpdate",
                "yyqya(sq)",
        _sessionID,
        _sessionQueryID,
        _numResults,
        _unreadCount,
        CommonAPI::Deployable<::v1::com::harman::btpres::BTPresTypes::alphaJumpList, ::v1::com::harman::btpres::BTPresTypes_::alphaJumpListDeployment_t>(_alphaList, static_cast<::v1::com::harman::btpres::BTPresTypes_::alphaJumpListDeployment_t*>(nullptr))
        );
    }
}

void PimDbHandlerDBusStubAdapterInternal::sendSessionQueryUpdateSelective(const uint8_t &_sessionID, const uint8_t &_sessionQueryID, const uint16_t &_numResults, const uint8_t &_unreadCount, const ::v1::com::harman::btpres::BTPresTypes::alphaJumpList &_alphaList, const std::shared_ptr<CommonAPI::ClientIdList> _receivers) {
    std::shared_ptr<CommonAPI::ClientIdList> actualReceiverList = _receivers;

    if (!_receivers)
        actualReceiverList = subscribersForSessionQueryUpdateSelective_;

    for (auto clientIdIterator = actualReceiverList->cbegin(); clientIdIterator != actualReceiverList->cend(); clientIdIterator++) {
        if (!_receivers || subscribersForSessionQueryUpdateSelective_->find(*clientIdIterator) != subscribersForSessionQueryUpdateSelective_->end()) {
            fireSessionQueryUpdateSelective(*clientIdIterator, _sessionID, _sessionQueryID, _numResults, _unreadCount, _alphaList);
        }
    }
}

void PimDbHandlerDBusStubAdapterInternal::subscribeForsessionQueryUpdateSelective(const std::shared_ptr<CommonAPI::ClientId> clientId, bool& success) {
    bool ok = PimDbHandlerDBusStubAdapterHelper::stub_->onSessionQueryUpdateSelectiveSubscriptionRequested(clientId);
    if (ok) {
        subscribersForSessionQueryUpdateSelective_->insert(clientId);
        PimDbHandlerDBusStubAdapterHelper::stub_->onSessionQueryUpdateSelectiveSubscriptionChanged(clientId, CommonAPI::SelectiveBroadcastSubscriptionEvent::SUBSCRIBED);
        success = true;
    } else {
        success = false;
    }
}

void PimDbHandlerDBusStubAdapterInternal::unsubscribeFromsessionQueryUpdateSelective(const std::shared_ptr<CommonAPI::ClientId> clientId) {
    subscribersForSessionQueryUpdateSelective_->erase(clientId);
    PimDbHandlerDBusStubAdapterHelper::stub_->onSessionQueryUpdateSelectiveSubscriptionChanged(clientId, CommonAPI::SelectiveBroadcastSubscriptionEvent::UNSUBSCRIBED);
}

std::shared_ptr<CommonAPI::ClientIdList> const PimDbHandlerDBusStubAdapterInternal::getSubscribersForSessionQueryUpdateSelective() {
    return subscribersForSessionQueryUpdateSelective_;
}
/**
 * description: Publishes the query status to all clients. The client can get the data once the
 *   query is "finished"
 */
CommonAPI::DBus::DBusMethodWithReplyAdapterDispatcher<
    ::v1::com::harman::btpres::PimDbHandlerStub,
    PimDbHandlerStubAdapter,
    std::tuple<>,
    std::tuple<bool>
    > PimDbHandlerDBusStubAdapterInternal::subscribeSessionQueryWindowUpdateSelectiveStubDispatcher(&PimDbHandlerStubAdapter::subscribeForsessionQueryWindowUpdateSelective, "b");

CommonAPI::DBus::DBusMethodWithReplyAdapterDispatcher<
    ::v1::com::harman::btpres::PimDbHandlerStub,
    PimDbHandlerStubAdapter,
    std::tuple<>,
    std::tuple<>
    > PimDbHandlerDBusStubAdapterInternal::unsubscribeSessionQueryWindowUpdateSelectiveStubDispatcher(&PimDbHandlerStubAdapter::unsubscribeFromsessionQueryWindowUpdateSelective, "");

void PimDbHandlerDBusStubAdapterInternal::fireSessionQueryWindowUpdateSelective(const std::shared_ptr<CommonAPI::ClientId> _client, const uint8_t &_sessionID, const uint8_t &_sessionQueryID, const uint16_t &_startIndex, const uint8_t &_numItems, const ::v1::com::harman::btpres::BTPresTypes::phonebook &_phonebookList) {
    std::shared_ptr<CommonAPI::DBus::DBusClientId> dbusClient = std::dynamic_pointer_cast<CommonAPI::DBus::DBusClientId, CommonAPI::ClientId>(_client);

    if(dbusClient)
    {
        CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<
        uint8_t,
        uint8_t,
        uint16_t,
        uint8_t,
        CommonAPI::Deployable<::v1::com::harman::btpres::BTPresTypes::phonebook, ::v1::com::harman::btpres::BTPresTypes_::phonebookDeployment_t>
        >>::sendSignal(
                dbusClient->getDBusId(),
                *this,
                "sessionQueryWindowUpdate",
                "yyqya(qqxia{is}a{ias}a{i(ssssssss)}a{ias}a{is})",
        _sessionID,
        _sessionQueryID,
        _startIndex,
        _numItems,
        CommonAPI::Deployable<::v1::com::harman::btpres::BTPresTypes::phonebook, ::v1::com::harman::btpres::BTPresTypes_::phonebookDeployment_t>(_phonebookList, static_cast<::v1::com::harman::btpres::BTPresTypes_::phonebookDeployment_t*>(nullptr))
        );
    }
}

void PimDbHandlerDBusStubAdapterInternal::sendSessionQueryWindowUpdateSelective(const uint8_t &_sessionID, const uint8_t &_sessionQueryID, const uint16_t &_startIndex, const uint8_t &_numItems, const ::v1::com::harman::btpres::BTPresTypes::phonebook &_phonebookList, const std::shared_ptr<CommonAPI::ClientIdList> _receivers) {
    std::shared_ptr<CommonAPI::ClientIdList> actualReceiverList = _receivers;

    if (!_receivers)
        actualReceiverList = subscribersForSessionQueryWindowUpdateSelective_;

    for (auto clientIdIterator = actualReceiverList->cbegin(); clientIdIterator != actualReceiverList->cend(); clientIdIterator++) {
        if (!_receivers || subscribersForSessionQueryWindowUpdateSelective_->find(*clientIdIterator) != subscribersForSessionQueryWindowUpdateSelective_->end()) {
            fireSessionQueryWindowUpdateSelective(*clientIdIterator, _sessionID, _sessionQueryID, _startIndex, _numItems, _phonebookList);
        }
    }
}

void PimDbHandlerDBusStubAdapterInternal::subscribeForsessionQueryWindowUpdateSelective(const std::shared_ptr<CommonAPI::ClientId> clientId, bool& success) {
    bool ok = PimDbHandlerDBusStubAdapterHelper::stub_->onSessionQueryWindowUpdateSelectiveSubscriptionRequested(clientId);
    if (ok) {
        subscribersForSessionQueryWindowUpdateSelective_->insert(clientId);
        PimDbHandlerDBusStubAdapterHelper::stub_->onSessionQueryWindowUpdateSelectiveSubscriptionChanged(clientId, CommonAPI::SelectiveBroadcastSubscriptionEvent::SUBSCRIBED);
        success = true;
    } else {
        success = false;
    }
}

void PimDbHandlerDBusStubAdapterInternal::unsubscribeFromsessionQueryWindowUpdateSelective(const std::shared_ptr<CommonAPI::ClientId> clientId) {
    subscribersForSessionQueryWindowUpdateSelective_->erase(clientId);
    PimDbHandlerDBusStubAdapterHelper::stub_->onSessionQueryWindowUpdateSelectiveSubscriptionChanged(clientId, CommonAPI::SelectiveBroadcastSubscriptionEvent::UNSUBSCRIBED);
}

std::shared_ptr<CommonAPI::ClientIdList> const PimDbHandlerDBusStubAdapterInternal::getSubscribersForSessionQueryWindowUpdateSelective() {
    return subscribersForSessionQueryWindowUpdateSelective_;
}
/**
 * description: Publishes only when session is closed due to device disconnect or client request
 */
CommonAPI::DBus::DBusMethodWithReplyAdapterDispatcher<
    ::v1::com::harman::btpres::PimDbHandlerStub,
    PimDbHandlerStubAdapter,
    std::tuple<>,
    std::tuple<bool>
    > PimDbHandlerDBusStubAdapterInternal::subscribeSessionClosedSelectiveStubDispatcher(&PimDbHandlerStubAdapter::subscribeForsessionClosedSelective, "b");

CommonAPI::DBus::DBusMethodWithReplyAdapterDispatcher<
    ::v1::com::harman::btpres::PimDbHandlerStub,
    PimDbHandlerStubAdapter,
    std::tuple<>,
    std::tuple<>
    > PimDbHandlerDBusStubAdapterInternal::unsubscribeSessionClosedSelectiveStubDispatcher(&PimDbHandlerStubAdapter::unsubscribeFromsessionClosedSelective, "");

void PimDbHandlerDBusStubAdapterInternal::fireSessionClosedSelective(const std::shared_ptr<CommonAPI::ClientId> _client, const uint8_t &_sessionID, const uint8_t &_sessionQueryID, const ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode) {
    std::shared_ptr<CommonAPI::DBus::DBusClientId> dbusClient = std::dynamic_pointer_cast<CommonAPI::DBus::DBusClientId, CommonAPI::ClientId>(_client);

    if(dbusClient)
    {
        CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<
        uint8_t,
        uint8_t,
        ::v1::com::harman::btpres::BTPresTypes::eErrorType
        >>::sendSignal(
                dbusClient->getDBusId(),
                *this,
                "sessionClosed",
                "yyi",
        _sessionID,
        _sessionQueryID,
        _errorCode
        );
    }
}

void PimDbHandlerDBusStubAdapterInternal::sendSessionClosedSelective(const uint8_t &_sessionID, const uint8_t &_sessionQueryID, const ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const std::shared_ptr<CommonAPI::ClientIdList> _receivers) {
    std::shared_ptr<CommonAPI::ClientIdList> actualReceiverList = _receivers;

    if (!_receivers)
        actualReceiverList = subscribersForSessionClosedSelective_;

    for (auto clientIdIterator = actualReceiverList->cbegin(); clientIdIterator != actualReceiverList->cend(); clientIdIterator++) {
        if (!_receivers || subscribersForSessionClosedSelective_->find(*clientIdIterator) != subscribersForSessionClosedSelective_->end()) {
            fireSessionClosedSelective(*clientIdIterator, _sessionID, _sessionQueryID, _errorCode);
        }
    }
}

void PimDbHandlerDBusStubAdapterInternal::subscribeForsessionClosedSelective(const std::shared_ptr<CommonAPI::ClientId> clientId, bool& success) {
    bool ok = PimDbHandlerDBusStubAdapterHelper::stub_->onSessionClosedSelectiveSubscriptionRequested(clientId);
    if (ok) {
        subscribersForSessionClosedSelective_->insert(clientId);
        PimDbHandlerDBusStubAdapterHelper::stub_->onSessionClosedSelectiveSubscriptionChanged(clientId, CommonAPI::SelectiveBroadcastSubscriptionEvent::SUBSCRIBED);
        success = true;
    } else {
        success = false;
    }
}

void PimDbHandlerDBusStubAdapterInternal::unsubscribeFromsessionClosedSelective(const std::shared_ptr<CommonAPI::ClientId> clientId) {
    subscribersForSessionClosedSelective_->erase(clientId);
    PimDbHandlerDBusStubAdapterHelper::stub_->onSessionClosedSelectiveSubscriptionChanged(clientId, CommonAPI::SelectiveBroadcastSubscriptionEvent::UNSUBSCRIBED);
}

std::shared_ptr<CommonAPI::ClientIdList> const PimDbHandlerDBusStubAdapterInternal::getSubscribersForSessionClosedSelective() {
    return subscribersForSessionClosedSelective_;
}
/**
 * description: This signal will be sent when a new missed call notification is received (after
 *   the phone is connected to Head Unit).
 * param: inAddress: BD Address of Device
 * param: number: Missed call number of latest missed call
 * param: name: formatted Name of the contact
 * param: unreadCount: This is the current count of unread-missed call.
 */
void PimDbHandlerDBusStubAdapterInternal::fireUnreadMissedCallEvent(const std::string& inAddress, const std::string& number, const std::string& name, const uint8_t& unreadCount) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<
    CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment>,
    CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment>,
    CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment>,
    uint8_t
    >>::sendSignal(
            *this,
            "unreadMissedCall",
            "sssy",
    CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment>(inAddress, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr)),
    CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment>(number, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr)),
    CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment>(name, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr)),
    unreadCount
    );
}
/**
 * description: This signal will be sent when a newCallList is available, after a call.
 * param: inAddress: BD Address of Device
 * param: newCallStackEntry : New call stack entry
 */
void PimDbHandlerDBusStubAdapterInternal::fireNewCallListEvent(const std::string& inAddress, const ::v1::com::harman::btpres::BTPresTypes::callstackEntry& newCallStackEntry) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<
    CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment>,
    CommonAPI::Deployable<::v1::com::harman::btpres::BTPresTypes::callstackEntry, ::v1::com::harman::btpres::BTPresTypes_::callstackEntryDeployment_t>
    >>::sendSignal(
            *this,
            "newCallList",
            "s(a{is}isssiu)",
    CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment>(inAddress, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr)),
    CommonAPI::Deployable<::v1::com::harman::btpres::BTPresTypes::callstackEntry, ::v1::com::harman::btpres::BTPresTypes_::callstackEntryDeployment_t>(newCallStackEntry, static_cast<::v1::com::harman::btpres::BTPresTypes_::callstackEntryDeployment_t*>(nullptr))
    );
}
/**
 * description: This signal will be emitted , when send sms is invoked : sent & delivered
 *   (success or failure)
 * param: inAddress: BD Address of Device
 * param: smsId: smsID of the sent SMS
 * param: notification: Status of the sent SMS
 */
void PimDbHandlerDBusStubAdapterInternal::fireSMSNotificationEvent(const std::string& inAddress, const int64_t& smsId, const ::v1::com::harman::btpres::BTPresTypes::eMsgNotification& notification) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<
    CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment>,
    int64_t,
    ::v1::com::harman::btpres::BTPresTypes::eMsgNotification
    >>::sendSignal(
            *this,
            "SMSNotification",
            "sxi",
    CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment>(inAddress, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr)),
    smsId,
    notification
    );
}


const PimDbHandlerDBusStubAdapterHelper::StubDispatcherTable& PimDbHandlerDBusStubAdapterInternal::getStubDispatcherTable() {
    return stubDispatcherTable_;
}

const CommonAPI::DBus::StubAttributeTable& PimDbHandlerDBusStubAdapterInternal::getStubAttributeTable() {
    return stubAttributeTable_;
}

PimDbHandlerDBusStubAdapterInternal::PimDbHandlerDBusStubAdapterInternal(
        const CommonAPI::DBus::DBusAddress &_address,
        const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection,
        const std::shared_ptr<CommonAPI::StubBase> &_stub)
	: CommonAPI::DBus::DBusStubAdapter(_address, _connection,false),
      PimDbHandlerDBusStubAdapterHelper(_address, _connection, std::dynamic_pointer_cast<PimDbHandlerStub>(_stub), false),
      stubDispatcherTable_({
            /**
             * description: formattedNameOrder is sorted name order, which can be set from HMI
             */
            { { "getContactNameOrderAttribute", "" }, &com::harman::btpres::PimDbHandlerDBusStubAdapterInternal::getContactNameOrderAttributeStubDispatcher },
            /**
             * description: DeviceList will contain list of paired device and their syncstatus
             */
            { { "getDeviceListAttribute", "" }, &com::harman::btpres::PimDbHandlerDBusStubAdapterInternal::getDeviceListAttributeStubDispatcher }
            ,
            /**
             * description: Opens a session for the client communication. This session will be used
             *   internally to uniquely identify a client, and to maintain client specific
             *   caches.
                                 The client need not create a new session for
             *   every request, this is rather used to identify different instances of clients.
             *     
                                 
                   returns: sessionID: Session identifier
             *   allocated to the client.
             */
            { { "openSession", "s" }, &com::harman::btpres::PimDbHandlerDBusStubAdapterInternal::openSessionStubDispatcher },
            /**
             * description: Close a client session and release all associated resources.
             * param: sessionID: The Session ID to close.
             */
            { { "closeSession", "y" }, &com::harman::btpres::PimDbHandlerDBusStubAdapterInternal::closeSessionStubDispatcher },
            /**
             * description: Sets a session query. This api handles all requests to fetch Phonebook results,
             *   database searches, etc. 
                                 As an example. If the HMI wanted
             *   to fetch a list of all contacts. The filterID's' and filter's' will be empty,
             *   and the result type would be set to Required field list.
             * param: filterIDs: The previously communicated numeric identifiers of the different
             *   filter categories.
             * param: filters: The string filters which should be applied to the result.
             * param: resultType: The data which is expected from the query.
             * param: sessionID: Session ID obtained from OpenSession.
             * param: databaseType: Related database for this sessionquery.
             * param: RequiredField: List of required field , if default is set browsing item will be
             *   sent with default avlues based on config
             * param: resetPrevious: Whether to use old history or not.If true treat this as a new
             *   session query, do not use any old selection history.
             * param: AutoUpdateEnabled: This is applicable for result sets which might update
             *   dynamically,Call stack or Fav list
                      							 
                   returns:
             *   numResults: The number of records matching the search criteria.
                  
             *   returns: SessionQueryID:The sessionQueryID allotted.This uniquely identifies a
             *   particular session query/filter for retrieving data in a session and it has to
             *   be passed 
                                            for furthur setting the
             *   sessionQuery window and retrieving the contents of that window.
             */
            { { "setSessionQuery", "yia{iy}a{is}a{ib}bbb" }, &com::harman::btpres::PimDbHandlerDBusStubAdapterInternal::setSessionQueryStubDispatcher },
            /**
             * description: Essentially re-initializes a session and stops all background tasks.
             * param: sessionID: The Session ID alloted.
             */
            { { "cancelSessionQuery", "y" }, &com::harman::btpres::PimDbHandlerDBusStubAdapterInternal::cancelSessionQueryStubDispatcher },
            /**
             * description: Ask presentation control to fetch the desired set of entries for a particular
             *   session query. This call does not block for the result to complete, and will
             *   override
                                 the last request given to Pres Ctrl.
             * param: sessionID: The Session ID alloted.
             * param: sessionQueryID: The sessionQueryID allotted.This uniquely identifies a
             *   particular session query/filter for retrieving data in a session and it has to
             *   be passed 
                                           for furthur setting the sessionQuery
             *   window and retrieving the contents of that window.
             * param: startIndex: The index to start fetching.
             * param: numItems: The number of items to fetch.     
                     
                   returns:
             *   windowID: A unique identifier for the client to track data responses to the
             *   queries.
             */
            { { "setSessionQueryWindow", "yyqy" }, &com::harman::btpres::PimDbHandlerDBusStubAdapterInternal::setSessionQueryWindowStubDispatcher },
            /**
             * description: This method is used for inserting contacts to Favourite list 
                             
             *      Hence the only acceptable value for "database" parameter is "ab".
             * param: inAddress: BD Address of Device
             * param: databaseType: Different database of Pim, Only Fav is allowed
             * param: requestID: Different type of user initiated DB operation
             * param: itemDetails: This list is a union of contactID list, NewPhonebook entry,
             *   SMSTemplateID list, SMStemplate
            	 		     
                   returns: This method returns
             *   errorcode
             */
            { { "dbOperation", "sii(aqs(qqxia{is}a{ias}a{i(ssssssss)}a{ias}a{is})ay)" }, &com::harman::btpres::PimDbHandlerDBusStubAdapterInternal::dbOperationStubDispatcher },
            /**
             * description: This API can be used to get Contact Name by contactID
             * param: inAddress: BD Address of Device
             * param: databaseType: Different database of Pim.Currently only available for "pb" or
             *   "ab"
             * param: contactID: contactID for which contact details should be extracted
             * param: fieldList: Required filedlist using bit masking ()
            	 		     
                   returns:	  
             *    phonebookEntry which will contain all the field
             */
            { { "getContactsByID", "siqa{iy}" }, &com::harman::btpres::PimDbHandlerDBusStubAdapterInternal::getContactsByIDStubDispatcher },
            /**
             * description: This API is used to get the full details of the SMS; this takes a unique id as
             *   input, which is received from the signal
             * param: inAddress: BD Address of Device
             * param: smsId: Unique id for SMS that is returned as part of the signal (multiple uid’s
             *   can be sent, separated)
            	 		     
                   returns: This method returns SMS entry
             */
            { { "getSMSById", "sx" }, &com::harman::btpres::PimDbHandlerDBusStubAdapterInternal::getSMSByIdStubDispatcher },
            /**
             * description: This API can be used to get the following details on either phonebook 
                    
             *               1.	The next valid characters mask that match the input string.
               
             *                    2.	The count of the names that matched the input string.
                
             *                   3.	The index of the first match of the input string sorted by
             *   givenName column. (This index can be used in getItems API to query for the
             *   details but the same sort criteria need to be applied).
             * param: inAddress: BD Address of Device
             * param: databaseType: Different database of Pim. Currently only available for Pb or ab
             * param: inputName: String to be searched
             * param: sortOrder: ascending or descending
             * param: condition: either or all based on notnullcolumnList 
                   	 		     
                  
             *   returns:      contactsCount:The count of the names that matched the input
             *   string.
                   returns:      index:The index of the first match of the input
             *   string sorted by formattedName column.
                   returns:      charactersMask:The
             *   next valid characters mask that match the input string.
                   returns:     
             *   firstMatch:The “formattedName” of the first matched contact
             */
            { { "getNextValidCharacters", "sisss" }, &com::harman::btpres::PimDbHandlerDBusStubAdapterInternal::getNextValidCharactersStubDispatcher },
            /**
             * description: This API is used to send the SMS to the destined number.
             * param: inAddress: BD Address of Device
             * param: destinationNumber: This indicates destination number of the SMS
             * param: smsBody: Describes the body of SMS to be sent
            	 		     
                   returns:	This
             *   methods return success or failure
                   returns: contactName: Contact Name to
             *   which SMS is sent
             */
            { { "sendSMSByTemplateID", "ssys" }, &com::harman::btpres::PimDbHandlerDBusStubAdapterInternal::sendSMSByTemplateIDStubDispatcher },
            /**
             * description: This API is used to set the status of a sms (as READ/UNREAD).
             * param: inAddress: BD Address of Device
             * param: smsId: Unique sms identifier
             * param: read_status: The status value that needs to be set. The valid values are “READ”
             *   or “UNREAD”
            	 		     
                   returns: This method returns errorcode
             */
            { { "setSMSReadStatus", "sxb" }, &com::harman::btpres::PimDbHandlerDBusStubAdapterInternal::setSMSReadStatusStubDispatcher },
            /**
             * description: This method is used to set the sorted name order.
             * param: inAddress: BD Address of Device (Considered only if project support device
             *   specific sorting order)
             * param: contact Name order
             */
            { { "setFormattedNameOrder", "si" }, &com::harman::btpres::PimDbHandlerDBusStubAdapterInternal::setFormattedNameOrderStubDispatcher }
            ,
            { { "subscribeForsessionQueryUpdateSelective", "" }, &com::harman::btpres::PimDbHandlerDBusStubAdapterInternal::subscribeSessionQueryUpdateSelectiveStubDispatcher }
            ,
            { { "unsubscribeFromsessionQueryUpdateSelective", "" }, &com::harman::btpres::PimDbHandlerDBusStubAdapterInternal::unsubscribeSessionQueryUpdateSelectiveStubDispatcher },
            { { "subscribeForsessionQueryWindowUpdateSelective", "" }, &com::harman::btpres::PimDbHandlerDBusStubAdapterInternal::subscribeSessionQueryWindowUpdateSelectiveStubDispatcher }
            ,
            { { "unsubscribeFromsessionQueryWindowUpdateSelective", "" }, &com::harman::btpres::PimDbHandlerDBusStubAdapterInternal::unsubscribeSessionQueryWindowUpdateSelectiveStubDispatcher },
            { { "subscribeForsessionClosedSelective", "" }, &com::harman::btpres::PimDbHandlerDBusStubAdapterInternal::subscribeSessionClosedSelectiveStubDispatcher }
            ,
            { { "unsubscribeFromsessionClosedSelective", "" }, &com::harman::btpres::PimDbHandlerDBusStubAdapterInternal::unsubscribeSessionClosedSelectiveStubDispatcher }
            }),
        stubAttributeTable_() {
    subscribersForSessionQueryUpdateSelective_ = std::make_shared<CommonAPI::ClientIdList>();
    subscribersForSessionQueryWindowUpdateSelective_ = std::make_shared<CommonAPI::ClientIdList>();
    subscribersForSessionClosedSelective_ = std::make_shared<CommonAPI::ClientIdList>();

    stubDispatcherTable_.insert({ { "getInterfaceVersion", "" }, &com::harman::btpres::PimDbHandlerDBusStubAdapterInternal::getPimDbHandlerInterfaceVersionStubDispatcher });
}

bool PimDbHandlerDBusStubAdapterInternal::hasFreedesktopProperties() {
    return false;
}

} // namespace btpres
} // namespace harman
} // namespace com
} // namespace v1
