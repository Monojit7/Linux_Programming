/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Thu Sep 22 00:23:23 IST 2016
*/
#include <v1/com/harman/btpres/PimDbHandlerStubDefault.hpp>
#include <assert.h>

namespace v1 {
namespace com {
namespace harman {
namespace btpres {

PimDbHandlerStubDefault::PimDbHandlerStubDefault():
        remoteEventHandler_(this),
        interfaceVersion_(PimDbHandler::getInterfaceVersion()) {
}

const CommonAPI::Version& PimDbHandlerStubDefault::getInterfaceVersion(std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return interfaceVersion_;
}

PimDbHandlerStubRemoteEvent* PimDbHandlerStubDefault::initStubAdapter(const std::shared_ptr<PimDbHandlerStubAdapter> &_adapter) {
    CommonAPI::Stub<PimDbHandlerStubAdapter, PimDbHandlerStubRemoteEvent>::stubAdapter_ = _adapter;
    return &remoteEventHandler_;
}

const ::v1::com::harman::btpres::BTPresTypes::eContactNameOredr& PimDbHandlerStubDefault::getContactNameOrderAttribute() {
    return contactNameOrderAttributeValue_;
}

const ::v1::com::harman::btpres::BTPresTypes::eContactNameOredr& PimDbHandlerStubDefault::getContactNameOrderAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getContactNameOrderAttribute();
}

void PimDbHandlerStubDefault::setContactNameOrderAttribute(::v1::com::harman::btpres::BTPresTypes::eContactNameOredr _value) {
    const bool valueChanged = trySetContactNameOrderAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<PimDbHandlerStubAdapter, PimDbHandlerStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireContactNameOrderAttributeChanged(contactNameOrderAttributeValue_);
    }
}

bool PimDbHandlerStubDefault::trySetContactNameOrderAttribute(::v1::com::harman::btpres::BTPresTypes::eContactNameOredr _value) {
    if (!validateContactNameOrderAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (contactNameOrderAttributeValue_ != _value);
    contactNameOrderAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool PimDbHandlerStubDefault::validateContactNameOrderAttributeRequestedValue(const ::v1::com::harman::btpres::BTPresTypes::eContactNameOredr &_value) {
    (void)_value;
	return _value.validate();
}


const ::v1::com::harman::btpres::BTPresTypes::pimPropertiesList& PimDbHandlerStubDefault::getDeviceListAttribute() {
    return deviceListAttributeValue_;
}

const ::v1::com::harman::btpres::BTPresTypes::pimPropertiesList& PimDbHandlerStubDefault::getDeviceListAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getDeviceListAttribute();
}

void PimDbHandlerStubDefault::setDeviceListAttribute(::v1::com::harman::btpres::BTPresTypes::pimPropertiesList _value) {
    const bool valueChanged = trySetDeviceListAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<PimDbHandlerStubAdapter, PimDbHandlerStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireDeviceListAttributeChanged(deviceListAttributeValue_);
    }
}

bool PimDbHandlerStubDefault::trySetDeviceListAttribute(::v1::com::harman::btpres::BTPresTypes::pimPropertiesList _value) {
    if (!validateDeviceListAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (deviceListAttributeValue_ != _value);
    deviceListAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool PimDbHandlerStubDefault::validateDeviceListAttributeRequestedValue(const ::v1::com::harman::btpres::BTPresTypes::pimPropertiesList &_value) {
    (void)_value;
	return true;
}



/**
 * description: Opens a session for the client communication. This session will be used
 *   internally to uniquely identify a client, and to maintain client specific
 *   caches.
                     The client need not create a new session for
 *   every request, this is rather used to identify different instances of clients.
 *     
                     
       returns: sessionID: Session identifier
 *   allocated to the client.
 */
void PimDbHandlerStubDefault::openSession(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _inAddress, openSessionReply_t _reply) {
    (void)_client;
    (void) _inAddress;
    uint8_t sessionID = 0u;
    ::v1::com::harman::btpres::BTPresTypes::eErrorType ErrorCode = ::v1::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
    if (!ErrorCode.validate()) {
        return;
    }
    _reply(sessionID, ErrorCode);
}

/**
 * description: Close a client session and release all associated resources.
 * param: sessionID: The Session ID to close.
 */
void PimDbHandlerStubDefault::closeSession(const std::shared_ptr<CommonAPI::ClientId> _client, uint8_t _sessionID, closeSessionReply_t _reply) {
    (void)_client;
    (void) _sessionID;
    ::v1::com::harman::btpres::BTPresTypes::eErrorType ErrorCode = ::v1::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
    if (!ErrorCode.validate()) {
        return;
    }
    _reply(ErrorCode);
}

/**
 * description: Sets a session query. This api handles all requests to fetch Phonebook results,
 *   database searches, etc. 
                     As an example. If the HMI wanted
 *   to fetch a list of all contacts. The filterID's' and filter's' will be empty,
 *   and the result type would be set to Required field list.
 * param: filterIDs: The previously communicated numeric identifiers of the different
 *   filter categories.
 * param: filters: The string filters which should be applied to the result.
 * param: resultType: The data which is expected from the query.
 * param: sessionID: Session ID obtained from OpenSession.
 * param: databaseType: Related database for this sessionquery.
 * param: RequiredField: List of required field , if default is set browsing item will be
 *   sent with default avlues based on config
 * param: resetPrevious: Whether to use old history or not.If true treat this as a new
 *   session query, do not use any old selection history.
 * param: AutoUpdateEnabled: This is applicable for result sets which might update
 *   dynamically,Call stack or Fav list
          							 
       returns:
 *   numResults: The number of records matching the search criteria.
      
 *   returns: SessionQueryID:The sessionQueryID allotted.This uniquely identifies a
 *   particular session query/filter for retrieving data in a session and it has to
 *   be passed 
                                for furthur setting the
 *   sessionQuery window and retrieving the contents of that window.
 */
void PimDbHandlerStubDefault::setSessionQuery(const std::shared_ptr<CommonAPI::ClientId> _client, uint8_t _sessionID, ::v1::com::harman::btpres::BTPresTypes::eDatabaseType _databaseType, ::v1::com::harman::btpres::BTPresTypes::phonebookResultMap _filterIDs, ::v1::com::harman::btpres::BTPresTypes::filterMap _filters, ::v1::com::harman::btpres::BTPresTypes::requiredFieldMap _RequiredField, bool _resetPrevious, bool _AutoUpdateEnabled, bool _AlphaJumpTable, setSessionQueryReply_t _reply) {
    (void)_client;
    (void) _sessionID;
    (void) _databaseType;
    (void) _filterIDs;
    (void) _filters;
    (void) _RequiredField;
    (void) _resetPrevious;
    (void) _AutoUpdateEnabled;
    (void) _AlphaJumpTable;
    ::v1::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v1::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
    uint32_t numResults = 0ul;
    uint8_t sessionQueryID = 0u;
    uint8_t unreadCount = 0u;
    ::v1::com::harman::btpres::BTPresTypes::alphaJumpList alphaList = {};
    if (!errorCode.validate()) {
        return;
    }
    _reply(errorCode, numResults, sessionQueryID, unreadCount, alphaList);
}

/**
 * description: Essentially re-initializes a session and stops all background tasks.
 * param: sessionID: The Session ID alloted.
 */
void PimDbHandlerStubDefault::cancelSessionQuery(const std::shared_ptr<CommonAPI::ClientId> _client, uint8_t _sessionID, cancelSessionQueryReply_t _reply) {
    (void)_client;
    (void) _sessionID;
    ::v1::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v1::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
    if (!errorCode.validate()) {
        return;
    }
    _reply(errorCode);
}

/**
 * description: Ask presentation control to fetch the desired set of entries for a particular
 *   session query. This call does not block for the result to complete, and will
 *   override
                     the last request given to Pres Ctrl.
 * param: sessionID: The Session ID alloted.
 * param: sessionQueryID: The sessionQueryID allotted.This uniquely identifies a
 *   particular session query/filter for retrieving data in a session and it has to
 *   be passed 
                               for furthur setting the sessionQuery
 *   window and retrieving the contents of that window.
 * param: startIndex: The index to start fetching.
 * param: numItems: The number of items to fetch.     
         
       returns:
 *   windowID: A unique identifier for the client to track data responses to the
 *   queries.
 */
void PimDbHandlerStubDefault::setSessionQueryWindow(const std::shared_ptr<CommonAPI::ClientId> _client, uint8_t _sessionID, uint8_t _sessionQueryID, uint16_t _startIndex, uint8_t _numItems, setSessionQueryWindowReply_t _reply) {
    (void)_client;
    (void) _sessionID;
    (void) _sessionQueryID;
    (void) _startIndex;
    (void) _numItems;
    ::v1::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v1::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
    if (!errorCode.validate()) {
        return;
    }
    _reply(errorCode);
}

/**
 * description: This method is used for inserting contacts to Favourite list 
                 
 *      Hence the only acceptable value for "database" parameter is "ab".
 * param: inAddress: BD Address of Device
 * param: databaseType: Different database of Pim, Only Fav is allowed
 * param: requestID: Different type of user initiated DB operation
 * param: itemDetails: This list is a union of contactID list, NewPhonebook entry,
 *   SMSTemplateID list, SMStemplate
	 		     
       returns: This method returns
 *   errorcode
 */
void PimDbHandlerStubDefault::dbOperation(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _inAddress, ::v1::com::harman::btpres::BTPresTypes::eDatabaseType _databaseType, ::v1::com::harman::btpres::BTPresTypes::eDbOperationId _requestID, ::v1::com::harman::btpres::BTPresTypes::InsertItems _itemDetails, dbOperationReply_t _reply) {
    (void)_client;
    (void) _inAddress;
    (void) _databaseType;
    (void) _requestID;
    (void) _itemDetails;
    ::v1::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v1::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
    if (!errorCode.validate()) {
        return;
    }
    _reply(errorCode);
}

/**
 * description: This API can be used to get Contact Name by contactID
 * param: inAddress: BD Address of Device
 * param: databaseType: Different database of Pim.Currently only available for "pb" or
 *   "ab"
 * param: contactID: contactID for which contact details should be extracted
 * param: fieldList: Required filedlist using bit masking ()
	 		     
       returns:	  
 *    phonebookEntry which will contain all the field
 */
void PimDbHandlerStubDefault::getContactsByID(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _inAddress, ::v1::com::harman::btpres::BTPresTypes::eDatabaseType _databaseType, uint16_t _contactID, ::v1::com::harman::btpres::BTPresTypes::phonebookResultMap _FieldList, getContactsByIDReply_t _reply) {
    (void)_client;
    (void) _inAddress;
    (void) _databaseType;
    (void) _contactID;
    (void) _FieldList;
    ::v1::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v1::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
    ::v1::com::harman::btpres::BTPresTypes::phonebookEntry detailedContact = {};
    if (!errorCode.validate()) {
        return;
    }
    _reply(errorCode, detailedContact);
}

/**
 * description: This API is used to get the full details of the SMS; this takes a unique id as
 *   input, which is received from the signal
 * param: inAddress: BD Address of Device
 * param: smsId: Unique id for SMS that is returned as part of the signal (multiple uid’s
 *   can be sent, separated)
	 		     
       returns: This method returns SMS entry
 */
void PimDbHandlerStubDefault::getSMSById(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _inAddress, int64_t _smsId, getSMSByIdReply_t _reply) {
    (void)_client;
    (void) _inAddress;
    (void) _smsId;
    ::v1::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v1::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
    ::v1::com::harman::btpres::BTPresTypes::smsEntry sms = {};
    if (!errorCode.validate()) {
        return;
    }
    _reply(errorCode, sms);
}

/**
 * description: This API can be used to get the following details on either phonebook 
        
 *               1.	The next valid characters mask that match the input string.
   
 *                    2.	The count of the names that matched the input string.
    
 *                   3.	The index of the first match of the input string sorted by
 *   givenName column. (This index can be used in getItems API to query for the
 *   details but the same sort criteria need to be applied).
 * param: inAddress: BD Address of Device
 * param: databaseType: Different database of Pim. Currently only available for Pb or ab
 * param: inputName: String to be searched
 * param: sortOrder: ascending or descending
 * param: condition: either or all based on notnullcolumnList 
       	 		     
      
 *   returns:      contactsCount:The count of the names that matched the input
 *   string.
       returns:      index:The index of the first match of the input
 *   string sorted by formattedName column.
       returns:      charactersMask:The
 *   next valid characters mask that match the input string.
       returns:     
 *   firstMatch:The “formattedName” of the first matched contact
 */
void PimDbHandlerStubDefault::getNextValidCharacters(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _inAddress, ::v1::com::harman::btpres::BTPresTypes::eDatabaseType _databaseType, std::string _inputName, std::string _sortOrder, std::string _condition, getNextValidCharactersReply_t _reply) {
    (void)_client;
    (void) _inAddress;
    (void) _databaseType;
    (void) _inputName;
    (void) _sortOrder;
    (void) _condition;
    ::v1::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v1::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
    uint16_t contactsCount = 0u;
    uint16_t index = 0u;
    std::string charactersMask = "";
    std::string firstMatch = "";
    if (!errorCode.validate()) {
        return;
    }
    _reply(errorCode, contactsCount, index, charactersMask, firstMatch);
}

/**
 * description: This API is used to send the SMS to the destined number.
 * param: inAddress: BD Address of Device
 * param: destinationNumber: This indicates destination number of the SMS
 * param: smsBody: Describes the body of SMS to be sent
	 		     
       returns:	This
 *   methods return success or failure
       returns: contactName: Contact Name to
 *   which SMS is sent
 */
void PimDbHandlerStubDefault::sendSMSByTemplateID(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _inAddress, std::string _destinationNumber, uint8_t _TemplateID, std::string _smsBody, sendSMSByTemplateIDReply_t _reply) {
    (void)_client;
    (void) _inAddress;
    (void) _destinationNumber;
    (void) _TemplateID;
    (void) _smsBody;
    ::v1::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v1::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
    std::string contactName = "";
    if (!errorCode.validate()) {
        return;
    }
    _reply(errorCode, contactName);
}

/**
 * description: This API is used to set the status of a sms (as READ/UNREAD).
 * param: inAddress: BD Address of Device
 * param: smsId: Unique sms identifier
 * param: read_status: The status value that needs to be set. The valid values are “READ”
 *   or “UNREAD”
	 		     
       returns: This method returns errorcode
 */
void PimDbHandlerStubDefault::setSMSReadStatus(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _inAddress, int64_t _smsId, bool _sms_read_status, setSMSReadStatusReply_t _reply) {
    (void)_client;
    (void) _inAddress;
    (void) _smsId;
    (void) _sms_read_status;
    ::v1::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v1::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
    if (!errorCode.validate()) {
        return;
    }
    _reply(errorCode);
}

/**
 * description: This method is used to set the sorted name order.
 * param: inAddress: BD Address of Device (Considered only if project support device
 *   specific sorting order)
 * param: contact Name order
 */
void PimDbHandlerStubDefault::setFormattedNameOrder(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _inAddress, ::v1::com::harman::btpres::BTPresTypes::eContactNameOredr _contactNameOrder, setFormattedNameOrderReply_t _reply) {
    (void)_client;
    (void) _inAddress;
    (void) _contactNameOrder;
    ::v1::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v1::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
    if (!errorCode.validate()) {
        return;
    }
    _reply(errorCode);
}


/**
 * description: Will only be posted to the respective listeners if the session query parameters
 *   have changed. 
                     For example, for  Calllist and SMS can be
 *   changed dynamically based on new SMS or new Call Stack.  Will be published 
  
 *                     only if auto update was enabled when setting the query.
 * param: sessionID: The Session ID alloted.
 * param: sessionQueryID: Allocated session queruy ID
 * param: numResults: Total number of result
 * param: unreadCount: This will be sent updated for unread SMS count and unread missed
 *   call count
 */
void PimDbHandlerStubDefault::fireSessionQueryUpdateSelective(const uint8_t &_sessionID, const uint8_t &_sessionQueryID, const uint16_t &_numResults, const uint8_t &_unreadCount, const ::v1::com::harman::btpres::BTPresTypes::alphaJumpList &_alphaList, const std::shared_ptr<CommonAPI::ClientIdList> _receivers) {
    assert((CommonAPI::Stub<PimDbHandlerStubAdapter, PimDbHandlerStubRemoteEvent>::stubAdapter_.lock()) !=NULL);
    auto stubAdapter = CommonAPI::Stub<PimDbHandlerStubAdapter, PimDbHandlerStubRemoteEvent>::stubAdapter_.lock();
    if (stubAdapter)
        stubAdapter->sendSessionQueryUpdateSelective(_sessionID, _sessionQueryID, _numResults, _unreadCount, _alphaList, _receivers);
}
void PimDbHandlerStubDefault::onSessionQueryUpdateSelectiveSubscriptionChanged(const std::shared_ptr<CommonAPI::ClientId> _client, const CommonAPI::SelectiveBroadcastSubscriptionEvent _event) {
    (void)_client;
    (void)_event;
    // No operation in default
}
bool PimDbHandlerStubDefault::onSessionQueryUpdateSelectiveSubscriptionRequested(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    // Accept in default
    return true;
}
std::shared_ptr<CommonAPI::ClientIdList> const PimDbHandlerStubDefault::getSubscribersForSessionQueryUpdateSelective() {
    assert((CommonAPI::Stub<PimDbHandlerStubAdapter, PimDbHandlerStubRemoteEvent>::stubAdapter_.lock()) !=NULL);
    auto stubAdapter = CommonAPI::Stub<PimDbHandlerStubAdapter, PimDbHandlerStubRemoteEvent>::stubAdapter_.lock();
   	if (stubAdapter)
        return(stubAdapter->getSubscribersForSessionQueryUpdateSelective());
    else
        return NULL;
}

/**
 * description: Publishes the query status to all clients. The client can get the data once the
 *   query is "finished"
 */
void PimDbHandlerStubDefault::fireSessionQueryWindowUpdateSelective(const uint8_t &_sessionID, const uint8_t &_sessionQueryID, const uint16_t &_startIndex, const uint8_t &_numItems, const ::v1::com::harman::btpres::BTPresTypes::phonebook &_phonebookList, const std::shared_ptr<CommonAPI::ClientIdList> _receivers) {
    assert((CommonAPI::Stub<PimDbHandlerStubAdapter, PimDbHandlerStubRemoteEvent>::stubAdapter_.lock()) !=NULL);
    auto stubAdapter = CommonAPI::Stub<PimDbHandlerStubAdapter, PimDbHandlerStubRemoteEvent>::stubAdapter_.lock();
    if (stubAdapter)
        stubAdapter->sendSessionQueryWindowUpdateSelective(_sessionID, _sessionQueryID, _startIndex, _numItems, _phonebookList, _receivers);
}
void PimDbHandlerStubDefault::onSessionQueryWindowUpdateSelectiveSubscriptionChanged(const std::shared_ptr<CommonAPI::ClientId> _client, const CommonAPI::SelectiveBroadcastSubscriptionEvent _event) {
    (void)_client;
    (void)_event;
    // No operation in default
}
bool PimDbHandlerStubDefault::onSessionQueryWindowUpdateSelectiveSubscriptionRequested(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    // Accept in default
    return true;
}
std::shared_ptr<CommonAPI::ClientIdList> const PimDbHandlerStubDefault::getSubscribersForSessionQueryWindowUpdateSelective() {
    assert((CommonAPI::Stub<PimDbHandlerStubAdapter, PimDbHandlerStubRemoteEvent>::stubAdapter_.lock()) !=NULL);
    auto stubAdapter = CommonAPI::Stub<PimDbHandlerStubAdapter, PimDbHandlerStubRemoteEvent>::stubAdapter_.lock();
   	if (stubAdapter)
        return(stubAdapter->getSubscribersForSessionQueryWindowUpdateSelective());
    else
        return NULL;
}

/**
 * description: Publishes only when session is closed due to device disconnect or client request
 */
void PimDbHandlerStubDefault::fireSessionClosedSelective(const uint8_t &_sessionID, const uint8_t &_sessionQueryID, const ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const std::shared_ptr<CommonAPI::ClientIdList> _receivers) {
    if (!_errorCode.validate()) {
        return;
    }
    assert((CommonAPI::Stub<PimDbHandlerStubAdapter, PimDbHandlerStubRemoteEvent>::stubAdapter_.lock()) !=NULL);
    auto stubAdapter = CommonAPI::Stub<PimDbHandlerStubAdapter, PimDbHandlerStubRemoteEvent>::stubAdapter_.lock();
    if (stubAdapter)
        stubAdapter->sendSessionClosedSelective(_sessionID, _sessionQueryID, _errorCode, _receivers);
}
void PimDbHandlerStubDefault::onSessionClosedSelectiveSubscriptionChanged(const std::shared_ptr<CommonAPI::ClientId> _client, const CommonAPI::SelectiveBroadcastSubscriptionEvent _event) {
    (void)_client;
    (void)_event;
    // No operation in default
}
bool PimDbHandlerStubDefault::onSessionClosedSelectiveSubscriptionRequested(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    // Accept in default
    return true;
}
std::shared_ptr<CommonAPI::ClientIdList> const PimDbHandlerStubDefault::getSubscribersForSessionClosedSelective() {
    assert((CommonAPI::Stub<PimDbHandlerStubAdapter, PimDbHandlerStubRemoteEvent>::stubAdapter_.lock()) !=NULL);
    auto stubAdapter = CommonAPI::Stub<PimDbHandlerStubAdapter, PimDbHandlerStubRemoteEvent>::stubAdapter_.lock();
   	if (stubAdapter)
        return(stubAdapter->getSubscribersForSessionClosedSelective());
    else
        return NULL;
}

/**
 * description: This signal will be sent when a new missed call notification is received (after
 *   the phone is connected to Head Unit).
 * param: inAddress: BD Address of Device
 * param: number: Missed call number of latest missed call
 * param: name: formatted Name of the contact
 * param: unreadCount: This is the current count of unread-missed call.
 */
void PimDbHandlerStubDefault::fireUnreadMissedCallEvent(const std::string &_inAddress, const std::string &_number, const std::string &_name, const uint8_t &_unreadCount) {
    assert((CommonAPI::Stub<PimDbHandlerStubAdapter, PimDbHandlerStubRemoteEvent>::stubAdapter_.lock()) !=NULL);
    auto stubAdapter = CommonAPI::Stub<PimDbHandlerStubAdapter, PimDbHandlerStubRemoteEvent>::stubAdapter_.lock();
   	if (stubAdapter)
        stubAdapter->fireUnreadMissedCallEvent(_inAddress, _number, _name, _unreadCount);
}
/**
 * description: This signal will be sent when a newCallList is available, after a call.
 * param: inAddress: BD Address of Device
 * param: newCallStackEntry : New call stack entry
 */
void PimDbHandlerStubDefault::fireNewCallListEvent(const std::string &_inAddress, const ::v1::com::harman::btpres::BTPresTypes::callstackEntry &_newCallStackEntry) {
    assert((CommonAPI::Stub<PimDbHandlerStubAdapter, PimDbHandlerStubRemoteEvent>::stubAdapter_.lock()) !=NULL);
    auto stubAdapter = CommonAPI::Stub<PimDbHandlerStubAdapter, PimDbHandlerStubRemoteEvent>::stubAdapter_.lock();
   	if (stubAdapter)
        stubAdapter->fireNewCallListEvent(_inAddress, _newCallStackEntry);
}
/**
 * description: This signal will be emitted , when send sms is invoked : sent & delivered
 *   (success or failure)
 * param: inAddress: BD Address of Device
 * param: smsId: smsID of the sent SMS
 * param: notification: Status of the sent SMS
 */
void PimDbHandlerStubDefault::fireSMSNotificationEvent(const std::string &_inAddress, const int64_t &_smsId, const ::v1::com::harman::btpres::BTPresTypes::eMsgNotification &_notification) {
    if (!_notification.validate()) {
        return;
    }
    assert((CommonAPI::Stub<PimDbHandlerStubAdapter, PimDbHandlerStubRemoteEvent>::stubAdapter_.lock()) !=NULL);
    auto stubAdapter = CommonAPI::Stub<PimDbHandlerStubAdapter, PimDbHandlerStubRemoteEvent>::stubAdapter_.lock();
   	if (stubAdapter)
        stubAdapter->fireSMSNotificationEvent(_inAddress, _smsId, _notification);
}


PimDbHandlerStubDefault::RemoteEventHandler::RemoteEventHandler(PimDbHandlerStubDefault *_defaultStub)
    : 
      defaultStub_(_defaultStub) {
}

} // namespace btpres
} // namespace harman
} // namespace com
} // namespace v1
