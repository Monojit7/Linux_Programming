/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Thu Sep 22 00:23:23 IST 2016
*/
#ifndef V1_COM_HARMAN_CONNECTIVITY_Phone_Book_PROXY_HPP_
#define V1_COM_HARMAN_CONNECTIVITY_Phone_Book_PROXY_HPP_

#include <v1/com/harman/connectivity/PhoneBookProxyBase.hpp>


#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif


#undef COMMONAPI_INTERNAL_COMPILATION

namespace v1 {
namespace com {
namespace harman {
namespace connectivity {

template <typename ... _AttributeExtensions>
class PhoneBookProxy
    : virtual public PhoneBook, 
      virtual public PhoneBookProxyBase,
      virtual public _AttributeExtensions... {
public:
    PhoneBookProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~PhoneBookProxy();

    typedef PhoneBook InterfaceType;



    /**
     * Returns the wrapper class that provides access to the broadcast PIMSYNCSTATUS.
     */
    virtual PIMSYNCSTATUSEvent& getPIMSYNCSTATUSEvent() {
        return delegate_->getPIMSYNCSTATUSEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast pimObjectBackGndSyncInfo.
     */
    virtual PimObjectBackGndSyncInfoEvent& getPimObjectBackGndSyncInfoEvent() {
        return delegate_->getPimObjectBackGndSyncInfoEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast databaseReady.
     */
    virtual DatabaseReadyEvent& getDatabaseReadyEvent() {
        return delegate_->getDatabaseReadyEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast databaseChanged.
     */
    virtual DatabaseChangedEvent& getDatabaseChangedEvent() {
        return delegate_->getDatabaseChangedEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast unreadMissedCall.
     */
    virtual UnreadMissedCallEvent& getUnreadMissedCallEvent() {
        return delegate_->getUnreadMissedCallEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast newCallList.
     */
    virtual NewCallListEvent& getNewCallListEvent() {
        return delegate_->getNewCallListEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast connectedDeviceTableUpdated.
     */
    virtual ConnectedDeviceTableUpdatedEvent& getConnectedDeviceTableUpdatedEvent() {
        return delegate_->getConnectedDeviceTableUpdatedEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast connectedBtDevice.
     */
    virtual ConnectedBtDeviceEvent& getConnectedBtDeviceEvent() {
        return delegate_->getConnectedBtDeviceEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast newSMS.
     */
    virtual NewSMSEvent& getNewSMSEvent() {
        return delegate_->getNewSMSEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast sendSMSNotification.
     */
    virtual SendSMSNotificationEvent& getSendSMSNotificationEvent() {
        return delegate_->getSendSMSNotificationEvent();
    }

    /**
     * Calls getProperties with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getProperties(const std::string &_bdAddr, const ::v2::com::harman::connectivity::BaseType::arString &_properties, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_Description, ::v2::com::harman::connectivity::BaseType::arString &_propertiesValue, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getProperties with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getPropertiesAsync(const std::string &_bdAddr, const ::v2::com::harman::connectivity::BaseType::arString &_properties, GetPropertiesAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getItemsCount with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getItemsCount(const std::string &_bdAddr, const std::string &_databaseType, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_Description, int32_t &_contactsCount, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getItemsCount with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getItemsCountAsync(const std::string &_bdAddr, const std::string &_databaseType, GetItemsCountAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getItems with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getItems(const std::string &_bdAddr, const std::string &_databaseType, const ::v2::com::harman::connectivity::BaseType::arString &_fieldsList, const int32_t &_index, const int32_t &_count, const std::string &_sortCriteria, const std::string &_sortOrder, const std::string &_condition, const std::string &_filterCriteria, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_Description, ::v2::com::harman::connectivity::BaseType::arString &_resultPhonebook, int32_t &_outIndex, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getItems with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getItemsAsync(const std::string &_bdAddr, const std::string &_databaseType, const ::v2::com::harman::connectivity::BaseType::arString &_fieldsList, const int32_t &_index, const int32_t &_count, const std::string &_sortCriteria, const std::string &_sortOrder, const std::string &_condition, const std::string &_filterCriteria, GetItemsAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getItemsMoreInfo with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getItemsMoreInfo(const std::string &_bdAddr, const int32_t &_moreInfoByte, const int32_t &_contactsId, const std::string &_databaseType, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_Description, ::v2::com::harman::connectivity::BaseType::arString &_moreInfo, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getItemsMoreInfo with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getItemsMoreInfoAsync(const std::string &_bdAddr, const int32_t &_moreInfoByte, const int32_t &_contactsId, const std::string &_databaseType, GetItemsMoreInfoAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls manualSync with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void manualSync(const std::string &_bdAddr, const std::string &_databaseType, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_Description, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls manualSync with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> manualSyncAsync(const std::string &_bdAddr, const std::string &_databaseType, ManualSyncAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls refreshPhonebook with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void refreshPhonebook(const std::string &_bdAddr, const std::string &_databaseType, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_refresh_status, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls refreshPhonebook with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> refreshPhonebookAsync(const std::string &_bdAddr, const std::string &_databaseType, RefreshPhonebookAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getCallStackCount with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getCallStackCount(const std::string &_bdAddr, const std::string &_storageType, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_description, int32_t &_callStackCount, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getCallStackCount with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getCallStackCountAsync(const std::string &_bdAddr, const std::string &_storageType, GetCallStackCountAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getCallStackList with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getCallStackList(const std::string &_bdAddr, const std::string &_storageType, const int32_t &_startCallstacksFrom, const int32_t &_numCallstacks, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_Description, ::v2::com::harman::connectivity::BaseType::arString &_resultCallstacks, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getCallStackList with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getCallStackListAsync(const std::string &_bdAddr, const std::string &_storageType, const int32_t &_startCallstacksFrom, const int32_t &_numCallstacks, GetCallStackListAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getAlphaJumpTable with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getAlphaJumpTable(const std::string &_bdAddr, const std::string &_database, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, ::v2::com::harman::connectivity::BaseType::arAlphaTable &_alphaTable, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getAlphaJumpTable with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getAlphaJumpTableAsync(const std::string &_bdAddr, const std::string &_database, GetAlphaJumpTableAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getNameByPhoneNum with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getNameByPhoneNum(const std::string &_bdAddr, const std::string &_database, const std::string &_phoneNumber, const std::string &_fieldList, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_get_status, ::v2::com::harman::connectivity::BaseType::arString &_result, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getNameByPhoneNum with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getNameByPhoneNumAsync(const std::string &_bdAddr, const std::string &_database, const std::string &_phoneNumber, const std::string &_fieldList, GetNameByPhoneNumAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls searchContactsByNumber with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void searchContactsByNumber(const std::string &_bdAddr, const std::string &_database, const std::string &_sortCriteria, const std::string &_condition, const std::string &_sortOrder, const int32_t &_startId, const int32_t &_count, const std::string &_filterCriteria, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_search_status, int32_t &_itemNumber, ::v2::com::harman::connectivity::BaseType::arString &_result, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls searchContactsByNumber with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> searchContactsByNumberAsync(const std::string &_bdAddr, const std::string &_database, const std::string &_sortCriteria, const std::string &_condition, const std::string &_sortOrder, const int32_t &_startId, const int32_t &_count, const std::string &_filterCriteria, SearchContactsByNumberAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getNextValidCharacters with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getNextValidCharacters(const std::string &_bdAddr, const std::string &_databaseType, const std::string &_inputName, const std::string &_sortCriteria, const std::string &_sortOrder, const std::string &_condition, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_get_char_status, int32_t &_contactsCount, int32_t &_index, std::string &_charactersMask, std::string &_firstMatch, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getNextValidCharacters with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getNextValidCharactersAsync(const std::string &_bdAddr, const std::string &_databaseType, const std::string &_inputName, const std::string &_sortCriteria, const std::string &_sortOrder, const std::string &_condition, GetNextValidCharactersAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setFormattedNameOrder with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setFormattedNameOrder(const std::string &_bdAddr, const std::string &_formattedNameOrder, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_Description, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setFormattedNameOrder with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setFormattedNameOrderAsync(const std::string &_bdAddr, const std::string &_formattedNameOrder, SetFormattedNameOrderAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getFormattedNameOrder with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getFormattedNameOrder(const std::string &_bdAddr, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_Description, std::string &_formattedNameOrder, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getFormattedNameOrder with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getFormattedNameOrderAsync(const std::string &_bdAddr, GetFormattedNameOrderAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getSMS with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getSMS(const std::string &_bdAddr, const int32_t &_smsId, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, ::v2::com::harman::connectivity::BaseType::smsentry &_sms, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getSMS with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getSMSAsync(const std::string &_bdAddr, const int32_t &_smsId, GetSMSAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getSMSCount with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getSMSCount(const std::string &_bdAddr, const ::v2::com::harman::connectivity::BaseType::foldertype &_folder, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, int32_t &_count, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getSMSCount with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getSMSCountAsync(const std::string &_bdAddr, const ::v2::com::harman::connectivity::BaseType::foldertype &_folder, GetSMSCountAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getSMSList with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getSMSList(const std::string &_bdAddr, const int32_t &_startSMSFrom, const ::v2::com::harman::connectivity::BaseType::foldertype &_folder, const int32_t &_numSMS, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, ::v2::com::harman::connectivity::BaseType::arSMS &_smsList, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getSMSList with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getSMSListAsync(const std::string &_bdAddr, const int32_t &_startSMSFrom, const ::v2::com::harman::connectivity::BaseType::foldertype &_folder, const int32_t &_numSMS, GetSMSListAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getUnreadSMSCount with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getUnreadSMSCount(const std::string &_bdAddr, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, int32_t &_count, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getUnreadSMSCount with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getUnreadSMSCountAsync(const std::string &_bdAddr, GetUnreadSMSCountAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getUnreadSMSList with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getUnreadSMSList(const std::string &_bdAddr, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, ::v2::com::harman::connectivity::BaseType::arSMS &_smsList, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getUnreadSMSList with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getUnreadSMSListAsync(const std::string &_bdAddr, GetUnreadSMSListAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls sendSMS with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void sendSMS(const std::string &_bdAddr, const std::string &_destinationNumber, const std::string &_smsBody, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_contactName, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls sendSMS with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> sendSMSAsync(const std::string &_bdAddr, const std::string &_destinationNumber, const std::string &_smsBody, SendSMSAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setSMSReadStatus with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setSMSReadStatus(const std::string &_bdAddr, const int32_t &_smsId, const std::string &_read_status, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setSMSReadStatus with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setSMSReadStatusAsync(const std::string &_bdAddr, const int32_t &_smsId, const std::string &_read_status, SetSMSReadStatusAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls insertItem with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void insertItem(const std::string &_bdAddr, const std::string &_database, const int32_t &_contactId, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls insertItem with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> insertItemAsync(const std::string &_bdAddr, const std::string &_database, const int32_t &_contactId, InsertItemAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls deleteItem with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void deleteItem(const std::string &_bdAddr, const std::string &_database, const int32_t &_contactId, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls deleteItem with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> deleteItemAsync(const std::string &_bdAddr, const std::string &_database, const int32_t &_contactId, DeleteItemAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls deleteAllItems with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void deleteAllItems(const std::string &_bdAddr, const std::string &_database, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls deleteAllItems with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> deleteAllItemsAsync(const std::string &_bdAddr, const std::string &_database, DeleteAllItemsAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);


    /**
     * Returns the CommonAPI address of the remote partner this proxy communicates with.
     */
    virtual const CommonAPI::Address &getAddress() const;

    /**
     * Returns true if the remote partner for this proxy is currently known to be available.
     */
    virtual bool isAvailable() const;

    /**
     * Returns true if the remote partner for this proxy is available.
     */
    virtual bool isAvailableBlocking() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<PhoneBookProxyBase> delegate_;
};

typedef PhoneBookProxy<> PhoneBookProxyDefault;


//
// PhoneBookProxy Implementation
//
template <typename ... _AttributeExtensions>
PhoneBookProxy<_AttributeExtensions...>::PhoneBookProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        _AttributeExtensions(*(std::dynamic_pointer_cast<PhoneBookProxyBase>(delegate)))...,
        delegate_(std::dynamic_pointer_cast<PhoneBookProxyBase>(delegate)) {
}

template <typename ... _AttributeExtensions>
PhoneBookProxy<_AttributeExtensions...>::~PhoneBookProxy() {
}

template <typename ... _AttributeExtensions>
void PhoneBookProxy<_AttributeExtensions...>::getProperties(const std::string &_bdAddr, const ::v2::com::harman::connectivity::BaseType::arString &_properties, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_Description, ::v2::com::harman::connectivity::BaseType::arString &_propertiesValue, const CommonAPI::CallInfo *_info) {
    delegate_->getProperties(_bdAddr, _properties, _internalCallStatus, _errorCode, _Description, _propertiesValue, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PhoneBookProxy<_AttributeExtensions...>::getPropertiesAsync(const std::string &_bdAddr, const ::v2::com::harman::connectivity::BaseType::arString &_properties, GetPropertiesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getPropertiesAsync(_bdAddr, _properties, _callback, _info);
}
template <typename ... _AttributeExtensions>
void PhoneBookProxy<_AttributeExtensions...>::getItemsCount(const std::string &_bdAddr, const std::string &_databaseType, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_Description, int32_t &_contactsCount, const CommonAPI::CallInfo *_info) {
    delegate_->getItemsCount(_bdAddr, _databaseType, _internalCallStatus, _errorCode, _Description, _contactsCount, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PhoneBookProxy<_AttributeExtensions...>::getItemsCountAsync(const std::string &_bdAddr, const std::string &_databaseType, GetItemsCountAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getItemsCountAsync(_bdAddr, _databaseType, _callback, _info);
}
template <typename ... _AttributeExtensions>
void PhoneBookProxy<_AttributeExtensions...>::getItems(const std::string &_bdAddr, const std::string &_databaseType, const ::v2::com::harman::connectivity::BaseType::arString &_fieldsList, const int32_t &_index, const int32_t &_count, const std::string &_sortCriteria, const std::string &_sortOrder, const std::string &_condition, const std::string &_filterCriteria, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_Description, ::v2::com::harman::connectivity::BaseType::arString &_resultPhonebook, int32_t &_outIndex, const CommonAPI::CallInfo *_info) {
    delegate_->getItems(_bdAddr, _databaseType, _fieldsList, _index, _count, _sortCriteria, _sortOrder, _condition, _filterCriteria, _internalCallStatus, _errorCode, _Description, _resultPhonebook, _outIndex, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PhoneBookProxy<_AttributeExtensions...>::getItemsAsync(const std::string &_bdAddr, const std::string &_databaseType, const ::v2::com::harman::connectivity::BaseType::arString &_fieldsList, const int32_t &_index, const int32_t &_count, const std::string &_sortCriteria, const std::string &_sortOrder, const std::string &_condition, const std::string &_filterCriteria, GetItemsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getItemsAsync(_bdAddr, _databaseType, _fieldsList, _index, _count, _sortCriteria, _sortOrder, _condition, _filterCriteria, _callback, _info);
}
template <typename ... _AttributeExtensions>
void PhoneBookProxy<_AttributeExtensions...>::getItemsMoreInfo(const std::string &_bdAddr, const int32_t &_moreInfoByte, const int32_t &_contactsId, const std::string &_databaseType, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_Description, ::v2::com::harman::connectivity::BaseType::arString &_moreInfo, const CommonAPI::CallInfo *_info) {
    delegate_->getItemsMoreInfo(_bdAddr, _moreInfoByte, _contactsId, _databaseType, _internalCallStatus, _errorCode, _Description, _moreInfo, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PhoneBookProxy<_AttributeExtensions...>::getItemsMoreInfoAsync(const std::string &_bdAddr, const int32_t &_moreInfoByte, const int32_t &_contactsId, const std::string &_databaseType, GetItemsMoreInfoAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getItemsMoreInfoAsync(_bdAddr, _moreInfoByte, _contactsId, _databaseType, _callback, _info);
}
template <typename ... _AttributeExtensions>
void PhoneBookProxy<_AttributeExtensions...>::manualSync(const std::string &_bdAddr, const std::string &_databaseType, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_Description, const CommonAPI::CallInfo *_info) {
    delegate_->manualSync(_bdAddr, _databaseType, _internalCallStatus, _errorCode, _Description, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PhoneBookProxy<_AttributeExtensions...>::manualSyncAsync(const std::string &_bdAddr, const std::string &_databaseType, ManualSyncAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->manualSyncAsync(_bdAddr, _databaseType, _callback, _info);
}
template <typename ... _AttributeExtensions>
void PhoneBookProxy<_AttributeExtensions...>::refreshPhonebook(const std::string &_bdAddr, const std::string &_databaseType, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_refresh_status, const CommonAPI::CallInfo *_info) {
    delegate_->refreshPhonebook(_bdAddr, _databaseType, _internalCallStatus, _errorCode, _refresh_status, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PhoneBookProxy<_AttributeExtensions...>::refreshPhonebookAsync(const std::string &_bdAddr, const std::string &_databaseType, RefreshPhonebookAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->refreshPhonebookAsync(_bdAddr, _databaseType, _callback, _info);
}
template <typename ... _AttributeExtensions>
void PhoneBookProxy<_AttributeExtensions...>::getCallStackCount(const std::string &_bdAddr, const std::string &_storageType, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_description, int32_t &_callStackCount, const CommonAPI::CallInfo *_info) {
    delegate_->getCallStackCount(_bdAddr, _storageType, _internalCallStatus, _errorCode, _description, _callStackCount, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PhoneBookProxy<_AttributeExtensions...>::getCallStackCountAsync(const std::string &_bdAddr, const std::string &_storageType, GetCallStackCountAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getCallStackCountAsync(_bdAddr, _storageType, _callback, _info);
}
template <typename ... _AttributeExtensions>
void PhoneBookProxy<_AttributeExtensions...>::getCallStackList(const std::string &_bdAddr, const std::string &_storageType, const int32_t &_startCallstacksFrom, const int32_t &_numCallstacks, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_Description, ::v2::com::harman::connectivity::BaseType::arString &_resultCallstacks, const CommonAPI::CallInfo *_info) {
    delegate_->getCallStackList(_bdAddr, _storageType, _startCallstacksFrom, _numCallstacks, _internalCallStatus, _errorCode, _Description, _resultCallstacks, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PhoneBookProxy<_AttributeExtensions...>::getCallStackListAsync(const std::string &_bdAddr, const std::string &_storageType, const int32_t &_startCallstacksFrom, const int32_t &_numCallstacks, GetCallStackListAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getCallStackListAsync(_bdAddr, _storageType, _startCallstacksFrom, _numCallstacks, _callback, _info);
}
template <typename ... _AttributeExtensions>
void PhoneBookProxy<_AttributeExtensions...>::getAlphaJumpTable(const std::string &_bdAddr, const std::string &_database, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, ::v2::com::harman::connectivity::BaseType::arAlphaTable &_alphaTable, const CommonAPI::CallInfo *_info) {
    delegate_->getAlphaJumpTable(_bdAddr, _database, _internalCallStatus, _errorCode, _alphaTable, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PhoneBookProxy<_AttributeExtensions...>::getAlphaJumpTableAsync(const std::string &_bdAddr, const std::string &_database, GetAlphaJumpTableAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getAlphaJumpTableAsync(_bdAddr, _database, _callback, _info);
}
template <typename ... _AttributeExtensions>
void PhoneBookProxy<_AttributeExtensions...>::getNameByPhoneNum(const std::string &_bdAddr, const std::string &_database, const std::string &_phoneNumber, const std::string &_fieldList, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_get_status, ::v2::com::harman::connectivity::BaseType::arString &_result, const CommonAPI::CallInfo *_info) {
    delegate_->getNameByPhoneNum(_bdAddr, _database, _phoneNumber, _fieldList, _internalCallStatus, _errorCode, _get_status, _result, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PhoneBookProxy<_AttributeExtensions...>::getNameByPhoneNumAsync(const std::string &_bdAddr, const std::string &_database, const std::string &_phoneNumber, const std::string &_fieldList, GetNameByPhoneNumAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getNameByPhoneNumAsync(_bdAddr, _database, _phoneNumber, _fieldList, _callback, _info);
}
template <typename ... _AttributeExtensions>
void PhoneBookProxy<_AttributeExtensions...>::searchContactsByNumber(const std::string &_bdAddr, const std::string &_database, const std::string &_sortCriteria, const std::string &_condition, const std::string &_sortOrder, const int32_t &_startId, const int32_t &_count, const std::string &_filterCriteria, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_search_status, int32_t &_itemNumber, ::v2::com::harman::connectivity::BaseType::arString &_result, const CommonAPI::CallInfo *_info) {
    delegate_->searchContactsByNumber(_bdAddr, _database, _sortCriteria, _condition, _sortOrder, _startId, _count, _filterCriteria, _internalCallStatus, _errorCode, _search_status, _itemNumber, _result, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PhoneBookProxy<_AttributeExtensions...>::searchContactsByNumberAsync(const std::string &_bdAddr, const std::string &_database, const std::string &_sortCriteria, const std::string &_condition, const std::string &_sortOrder, const int32_t &_startId, const int32_t &_count, const std::string &_filterCriteria, SearchContactsByNumberAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->searchContactsByNumberAsync(_bdAddr, _database, _sortCriteria, _condition, _sortOrder, _startId, _count, _filterCriteria, _callback, _info);
}
template <typename ... _AttributeExtensions>
void PhoneBookProxy<_AttributeExtensions...>::getNextValidCharacters(const std::string &_bdAddr, const std::string &_databaseType, const std::string &_inputName, const std::string &_sortCriteria, const std::string &_sortOrder, const std::string &_condition, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_get_char_status, int32_t &_contactsCount, int32_t &_index, std::string &_charactersMask, std::string &_firstMatch, const CommonAPI::CallInfo *_info) {
    delegate_->getNextValidCharacters(_bdAddr, _databaseType, _inputName, _sortCriteria, _sortOrder, _condition, _internalCallStatus, _errorCode, _get_char_status, _contactsCount, _index, _charactersMask, _firstMatch, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PhoneBookProxy<_AttributeExtensions...>::getNextValidCharactersAsync(const std::string &_bdAddr, const std::string &_databaseType, const std::string &_inputName, const std::string &_sortCriteria, const std::string &_sortOrder, const std::string &_condition, GetNextValidCharactersAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getNextValidCharactersAsync(_bdAddr, _databaseType, _inputName, _sortCriteria, _sortOrder, _condition, _callback, _info);
}
template <typename ... _AttributeExtensions>
void PhoneBookProxy<_AttributeExtensions...>::setFormattedNameOrder(const std::string &_bdAddr, const std::string &_formattedNameOrder, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_Description, const CommonAPI::CallInfo *_info) {
    delegate_->setFormattedNameOrder(_bdAddr, _formattedNameOrder, _internalCallStatus, _errorCode, _Description, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PhoneBookProxy<_AttributeExtensions...>::setFormattedNameOrderAsync(const std::string &_bdAddr, const std::string &_formattedNameOrder, SetFormattedNameOrderAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setFormattedNameOrderAsync(_bdAddr, _formattedNameOrder, _callback, _info);
}
template <typename ... _AttributeExtensions>
void PhoneBookProxy<_AttributeExtensions...>::getFormattedNameOrder(const std::string &_bdAddr, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_Description, std::string &_formattedNameOrder, const CommonAPI::CallInfo *_info) {
    delegate_->getFormattedNameOrder(_bdAddr, _internalCallStatus, _errorCode, _Description, _formattedNameOrder, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PhoneBookProxy<_AttributeExtensions...>::getFormattedNameOrderAsync(const std::string &_bdAddr, GetFormattedNameOrderAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getFormattedNameOrderAsync(_bdAddr, _callback, _info);
}
template <typename ... _AttributeExtensions>
void PhoneBookProxy<_AttributeExtensions...>::getSMS(const std::string &_bdAddr, const int32_t &_smsId, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, ::v2::com::harman::connectivity::BaseType::smsentry &_sms, const CommonAPI::CallInfo *_info) {
    delegate_->getSMS(_bdAddr, _smsId, _internalCallStatus, _errorCode, _sms, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PhoneBookProxy<_AttributeExtensions...>::getSMSAsync(const std::string &_bdAddr, const int32_t &_smsId, GetSMSAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getSMSAsync(_bdAddr, _smsId, _callback, _info);
}
template <typename ... _AttributeExtensions>
void PhoneBookProxy<_AttributeExtensions...>::getSMSCount(const std::string &_bdAddr, const ::v2::com::harman::connectivity::BaseType::foldertype &_folder, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, int32_t &_count, const CommonAPI::CallInfo *_info) {
    if (!_folder.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->getSMSCount(_bdAddr, _folder, _internalCallStatus, _errorCode, _count, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PhoneBookProxy<_AttributeExtensions...>::getSMSCountAsync(const std::string &_bdAddr, const ::v2::com::harman::connectivity::BaseType::foldertype &_folder, GetSMSCountAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_folder.validate()) {
        int32_t errorCode = 0;
        int32_t count = 0;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, errorCode, count);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->getSMSCountAsync(_bdAddr, _folder, _callback, _info);
}
template <typename ... _AttributeExtensions>
void PhoneBookProxy<_AttributeExtensions...>::getSMSList(const std::string &_bdAddr, const int32_t &_startSMSFrom, const ::v2::com::harman::connectivity::BaseType::foldertype &_folder, const int32_t &_numSMS, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, ::v2::com::harman::connectivity::BaseType::arSMS &_smsList, const CommonAPI::CallInfo *_info) {
    if (!_folder.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->getSMSList(_bdAddr, _startSMSFrom, _folder, _numSMS, _internalCallStatus, _errorCode, _smsList, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PhoneBookProxy<_AttributeExtensions...>::getSMSListAsync(const std::string &_bdAddr, const int32_t &_startSMSFrom, const ::v2::com::harman::connectivity::BaseType::foldertype &_folder, const int32_t &_numSMS, GetSMSListAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_folder.validate()) {
        int32_t errorCode = 0;
        ::v2::com::harman::connectivity::BaseType::arSMS smsList = {};
        _callback(CommonAPI::CallStatus::INVALID_VALUE, errorCode, smsList);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->getSMSListAsync(_bdAddr, _startSMSFrom, _folder, _numSMS, _callback, _info);
}
template <typename ... _AttributeExtensions>
void PhoneBookProxy<_AttributeExtensions...>::getUnreadSMSCount(const std::string &_bdAddr, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, int32_t &_count, const CommonAPI::CallInfo *_info) {
    delegate_->getUnreadSMSCount(_bdAddr, _internalCallStatus, _errorCode, _count, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PhoneBookProxy<_AttributeExtensions...>::getUnreadSMSCountAsync(const std::string &_bdAddr, GetUnreadSMSCountAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getUnreadSMSCountAsync(_bdAddr, _callback, _info);
}
template <typename ... _AttributeExtensions>
void PhoneBookProxy<_AttributeExtensions...>::getUnreadSMSList(const std::string &_bdAddr, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, ::v2::com::harman::connectivity::BaseType::arSMS &_smsList, const CommonAPI::CallInfo *_info) {
    delegate_->getUnreadSMSList(_bdAddr, _internalCallStatus, _errorCode, _smsList, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PhoneBookProxy<_AttributeExtensions...>::getUnreadSMSListAsync(const std::string &_bdAddr, GetUnreadSMSListAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getUnreadSMSListAsync(_bdAddr, _callback, _info);
}
template <typename ... _AttributeExtensions>
void PhoneBookProxy<_AttributeExtensions...>::sendSMS(const std::string &_bdAddr, const std::string &_destinationNumber, const std::string &_smsBody, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_contactName, const CommonAPI::CallInfo *_info) {
    delegate_->sendSMS(_bdAddr, _destinationNumber, _smsBody, _internalCallStatus, _errorCode, _contactName, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PhoneBookProxy<_AttributeExtensions...>::sendSMSAsync(const std::string &_bdAddr, const std::string &_destinationNumber, const std::string &_smsBody, SendSMSAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->sendSMSAsync(_bdAddr, _destinationNumber, _smsBody, _callback, _info);
}
template <typename ... _AttributeExtensions>
void PhoneBookProxy<_AttributeExtensions...>::setSMSReadStatus(const std::string &_bdAddr, const int32_t &_smsId, const std::string &_read_status, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->setSMSReadStatus(_bdAddr, _smsId, _read_status, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PhoneBookProxy<_AttributeExtensions...>::setSMSReadStatusAsync(const std::string &_bdAddr, const int32_t &_smsId, const std::string &_read_status, SetSMSReadStatusAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setSMSReadStatusAsync(_bdAddr, _smsId, _read_status, _callback, _info);
}
template <typename ... _AttributeExtensions>
void PhoneBookProxy<_AttributeExtensions...>::insertItem(const std::string &_bdAddr, const std::string &_database, const int32_t &_contactId, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->insertItem(_bdAddr, _database, _contactId, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PhoneBookProxy<_AttributeExtensions...>::insertItemAsync(const std::string &_bdAddr, const std::string &_database, const int32_t &_contactId, InsertItemAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->insertItemAsync(_bdAddr, _database, _contactId, _callback, _info);
}
template <typename ... _AttributeExtensions>
void PhoneBookProxy<_AttributeExtensions...>::deleteItem(const std::string &_bdAddr, const std::string &_database, const int32_t &_contactId, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->deleteItem(_bdAddr, _database, _contactId, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PhoneBookProxy<_AttributeExtensions...>::deleteItemAsync(const std::string &_bdAddr, const std::string &_database, const int32_t &_contactId, DeleteItemAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->deleteItemAsync(_bdAddr, _database, _contactId, _callback, _info);
}
template <typename ... _AttributeExtensions>
void PhoneBookProxy<_AttributeExtensions...>::deleteAllItems(const std::string &_bdAddr, const std::string &_database, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->deleteAllItems(_bdAddr, _database, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PhoneBookProxy<_AttributeExtensions...>::deleteAllItemsAsync(const std::string &_bdAddr, const std::string &_database, DeleteAllItemsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->deleteAllItemsAsync(_bdAddr, _database, _callback, _info);
}

template <typename ... _AttributeExtensions>
const CommonAPI::Address &PhoneBookProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
bool PhoneBookProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
bool PhoneBookProxy<_AttributeExtensions...>::isAvailableBlocking() const {
    return delegate_->isAvailableBlocking();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& PhoneBookProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& PhoneBookProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}


} // namespace connectivity
} // namespace harman
} // namespace com
} // namespace v1



// Compatibility
namespace v1_0 = v1;

#endif // V1_COM_HARMAN_CONNECTIVITY_Phone_Book_PROXY_HPP_
