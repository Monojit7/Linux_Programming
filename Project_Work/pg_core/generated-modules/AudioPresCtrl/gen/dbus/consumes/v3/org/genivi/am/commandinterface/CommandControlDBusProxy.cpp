/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Sun Oct 16 06:59:52 IST 2016
*/
/**
 * description: The interface towards the Controlling Instance (e.g. HMI). It handles the
 *   communication towards the HMI and other system components who need to interact
 *   with the audio management. There are two rules that have to be kept in mind
 *   when implementing against this interface:
 * author: Christian Linke
 */
#include <v3/org/genivi/am/commandinterface/CommandControlDBusProxy.hpp>

namespace v3 {
namespace org {
namespace genivi {
namespace am {
namespace commandinterface {

std::shared_ptr<CommonAPI::DBus::DBusProxy> createCommandControlDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection) {
	return std::make_shared<CommandControlDBusProxy>(_address, _connection);
}

INITIALIZER(registerCommandControlDBusProxy) {
     CommonAPI::DBus::Factory::get()->registerProxyCreateMethod(
		CommandControl::getInterface(),
		&createCommandControlDBusProxy);
}

CommandControlDBusProxy::CommandControlDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection)
	:	CommonAPI::DBus::DBusProxy(_address, _connection)
,		listOfMainConnetions_(*this, "onListOfMainConnetionsAttributeChanged", "a(qqqni)", "getListOfMainConnetionsAttribute", static_cast<::v3::org::genivi::am_t_::am_MainConnection_LDeployment_t*>(nullptr))
,		newMainConnection_(*this, "newMainConnection", "(qqqni)", std::make_tuple(static_cast<::v3::org::genivi::am_t_::am_MainConnectionType_sDeployment_t*>(nullptr))),
		removedMainConnection_(*this, "removedMainConnection", "q", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr))),
		newSink_(*this, "newSink", "(qs(iq)niq)", std::make_tuple(static_cast<::v3::org::genivi::am_t_::am_SinkType_sDeployment_t*>(nullptr))),
		removedSink_(*this, "removedSink", "q", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr))),
		newSource_(*this, "newSource", "(qs(iq)q)", std::make_tuple(static_cast<::v3::org::genivi::am_t_::am_SourceType_sDeployment_t*>(nullptr))),
		removedSource_(*this, "removedSource", "q", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr))),
		numberOfSinkClassesChanged_(*this, "numberOfSinkClassesChanged", "", std::make_tuple()),
		numberOfSourceClassesChanged_(*this, "numberOfSourceClassesChanged", "", std::make_tuple()),
		mainConnectionStateChanged_(*this, "mainConnectionStateChanged", "qi", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr))),
		mainSinkSoundPropertyChanged_(*this, "mainSinkSoundPropertyChanged", "q(in)", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<::v3::org::genivi::am_t_::am_MainSoundProperty_sDeployment_t*>(nullptr))),
		mainSourceSoundPropertyChanged_(*this, "mainSourceSoundPropertyChanged", "q(in)", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<::v3::org::genivi::am_t_::am_MainSoundProperty_sDeployment_t*>(nullptr))),
		sinkAvailabilityChanged_(*this, "sinkAvailabilityChanged", "q(iq)", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<::v3::org::genivi::am_t_::am_Availability_sDeployment_t*>(nullptr))),
		sourceAvailabilityChanged_(*this, "sourceAvailabilityChanged", "q(iq)", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<::v3::org::genivi::am_t_::am_Availability_sDeployment_t*>(nullptr))),
		volumeChanged_(*this, "volumeChanged", "qn", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr))),
		sinkMuteStateChanged_(*this, "sinkMuteStateChanged", "qi", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr))),
		systemPropertyChanged_(*this, "systemPropertyChanged", "(in)", std::make_tuple(static_cast<::v3::org::genivi::am_t_::am_SystemProperty_sDeployment_t*>(nullptr))),
		timingInformationChanged_(*this, "timingInformationChanged", "qn", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr))),
		sinkUpdated_(*this, "sinkUpdated", "qqa(in)", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<::v3::org::genivi::am_t_::am_MainSoundProperty_LDeployment_t*>(nullptr))),
		sourceUpdated_(*this, "sourceUpdated", "qqa(in)", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<::v3::org::genivi::am_t_::am_MainSoundProperty_LDeployment_t*>(nullptr))),
		sinkNotification_(*this, "sinkNotification", "q(qn)", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<::v3::org::genivi::am_t_::am_NotificationPayload_sDeployment_t*>(nullptr))),
		sourceNotification_(*this, "sourceNotification", "q(qn)", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<::v3::org::genivi::am_t_::am_NotificationPayload_sDeployment_t*>(nullptr))),
		mainSinkNotificationConfigurationChanged_(*this, "mainSinkNotificationConfigurationChanged", "q(qin)", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<::v3::org::genivi::am_t_::am_NotificationConfiguration_sDeployment_t*>(nullptr))),
		mainSourceNotificationConfigurationChanged_(*this, "mainSourceNotificationConfigurationChanged", "q(qin)", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<::v3::org::genivi::am_t_::am_NotificationConfiguration_sDeployment_t*>(nullptr)))
{
}

      CommandControlDBusProxy::ListOfMainConnetionsAttribute& CommandControlDBusProxy::getListOfMainConnetionsAttribute() {
          return listOfMainConnetions_;
      }

CommandControlDBusProxy::NewMainConnectionEvent& CommandControlDBusProxy::getNewMainConnectionEvent() {
    return newMainConnection_;
}
CommandControlDBusProxy::RemovedMainConnectionEvent& CommandControlDBusProxy::getRemovedMainConnectionEvent() {
    return removedMainConnection_;
}
CommandControlDBusProxy::NewSinkEvent& CommandControlDBusProxy::getNewSinkEvent() {
    return newSink_;
}
CommandControlDBusProxy::RemovedSinkEvent& CommandControlDBusProxy::getRemovedSinkEvent() {
    return removedSink_;
}
CommandControlDBusProxy::NewSourceEvent& CommandControlDBusProxy::getNewSourceEvent() {
    return newSource_;
}
CommandControlDBusProxy::RemovedSourceEvent& CommandControlDBusProxy::getRemovedSourceEvent() {
    return removedSource_;
}
CommandControlDBusProxy::NumberOfSinkClassesChangedEvent& CommandControlDBusProxy::getNumberOfSinkClassesChangedEvent() {
    return numberOfSinkClassesChanged_;
}
CommandControlDBusProxy::NumberOfSourceClassesChangedEvent& CommandControlDBusProxy::getNumberOfSourceClassesChangedEvent() {
    return numberOfSourceClassesChanged_;
}
CommandControlDBusProxy::MainConnectionStateChangedEvent& CommandControlDBusProxy::getMainConnectionStateChangedEvent() {
    return mainConnectionStateChanged_;
}
CommandControlDBusProxy::MainSinkSoundPropertyChangedEvent& CommandControlDBusProxy::getMainSinkSoundPropertyChangedEvent() {
    return mainSinkSoundPropertyChanged_;
}
CommandControlDBusProxy::MainSourceSoundPropertyChangedEvent& CommandControlDBusProxy::getMainSourceSoundPropertyChangedEvent() {
    return mainSourceSoundPropertyChanged_;
}
CommandControlDBusProxy::SinkAvailabilityChangedEvent& CommandControlDBusProxy::getSinkAvailabilityChangedEvent() {
    return sinkAvailabilityChanged_;
}
CommandControlDBusProxy::SourceAvailabilityChangedEvent& CommandControlDBusProxy::getSourceAvailabilityChangedEvent() {
    return sourceAvailabilityChanged_;
}
CommandControlDBusProxy::VolumeChangedEvent& CommandControlDBusProxy::getVolumeChangedEvent() {
    return volumeChanged_;
}
CommandControlDBusProxy::SinkMuteStateChangedEvent& CommandControlDBusProxy::getSinkMuteStateChangedEvent() {
    return sinkMuteStateChanged_;
}
CommandControlDBusProxy::SystemPropertyChangedEvent& CommandControlDBusProxy::getSystemPropertyChangedEvent() {
    return systemPropertyChanged_;
}
CommandControlDBusProxy::TimingInformationChangedEvent& CommandControlDBusProxy::getTimingInformationChangedEvent() {
    return timingInformationChanged_;
}
CommandControlDBusProxy::SinkUpdatedEvent& CommandControlDBusProxy::getSinkUpdatedEvent() {
    return sinkUpdated_;
}
CommandControlDBusProxy::SourceUpdatedEvent& CommandControlDBusProxy::getSourceUpdatedEvent() {
    return sourceUpdated_;
}
CommandControlDBusProxy::SinkNotificationEvent& CommandControlDBusProxy::getSinkNotificationEvent() {
    return sinkNotification_;
}
CommandControlDBusProxy::SourceNotificationEvent& CommandControlDBusProxy::getSourceNotificationEvent() {
    return sourceNotification_;
}
CommandControlDBusProxy::MainSinkNotificationConfigurationChangedEvent& CommandControlDBusProxy::getMainSinkNotificationConfigurationChangedEvent() {
    return mainSinkNotificationConfigurationChanged_;
}
CommandControlDBusProxy::MainSourceNotificationConfigurationChangedEvent& CommandControlDBusProxy::getMainSourceNotificationConfigurationChangedEvent() {
    return mainSourceNotificationConfigurationChanged_;
}
    
    /**
     * description: Connects a source to sink. (at)return E_OK on success, E_NOT_POSSIBLE on
     *   failure, E_ALREADY_EXISTS if the connection does already exists
     */
    void CommandControlDBusProxy::connect(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_mainConnectionID_t &_mainConnectionID, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment> deploy_sinkID(_sinkID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_mainConnectionID_t, CommonAPI::EmptyDeployment> deploy_mainConnectionID(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_mainConnectionID_t,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "connect",
        "qq",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sourceID, deploy_sinkID,
_internalCallStatus,
deploy_mainConnectionID, deploy_amError);
_mainConnectionID = deploy_mainConnectionID.getValue();
_amError = deploy_amError.getValue();
}
    std::future<CommonAPI::CallStatus> CommandControlDBusProxy::connectAsync(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, ConnectAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment> deploy_sinkID(_sinkID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_mainConnectionID_t, CommonAPI::EmptyDeployment> deploy_mainConnectionID(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_mainConnectionID_t,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "connect",
        "qq",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sourceID, deploy_sinkID,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_mainConnectionID_t, CommonAPI::EmptyDeployment> _mainConnectionID, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _amError) {
        	if (_callback)
        		_callback(_internalCallStatus, _mainConnectionID.getValue(), _amError.getValue());
        },
        std::make_tuple(deploy_mainConnectionID, deploy_amError));
    }
    /**
     * description: Disconnects a main connection. (at)return E_OK on successes, E_NON_EXISTENT if
     *   the connection does not exist, E_NOT_POSSIBLE on error.
     */
    void CommandControlDBusProxy::disconnect(const ::v3::org::genivi::am_t::am_mainConnectionID_t &_mainConnectionID, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_mainConnectionID_t, CommonAPI::EmptyDeployment> deploy_mainConnectionID(_mainConnectionID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_mainConnectionID_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "disconnect",
        "q",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_mainConnectionID,
_internalCallStatus,
deploy_amError);
_amError = deploy_amError.getValue();
}
    std::future<CommonAPI::CallStatus> CommandControlDBusProxy::disconnectAsync(const ::v3::org::genivi::am_t::am_mainConnectionID_t &_mainConnectionID, DisconnectAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_mainConnectionID_t, CommonAPI::EmptyDeployment> deploy_mainConnectionID(_mainConnectionID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_mainConnectionID_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "disconnect",
        "q",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_mainConnectionID,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _amError) {
        	if (_callback)
        		_callback(_internalCallStatus, _amError.getValue());
        },
        std::make_tuple(deploy_amError));
    }
    /**
     * description: Sets the volume for a sink. (at)return E_OK on success, E_UNKNOWN on error,
     *   E_OUT_OF_RANGE in case the value is out of range
     */
    void CommandControlDBusProxy::setVolume(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const ::v3::org::genivi::am_t::am_mainVolume_t &_volume, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment> deploy_sinkID(_sinkID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_mainVolume_t, CommonAPI::EmptyDeployment> deploy_volume(_volume, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_mainVolume_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "setVolume",
        "qn",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sinkID, deploy_volume,
_internalCallStatus,
deploy_amError);
_amError = deploy_amError.getValue();
}
    std::future<CommonAPI::CallStatus> CommandControlDBusProxy::setVolumeAsync(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const ::v3::org::genivi::am_t::am_mainVolume_t &_volume, SetVolumeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment> deploy_sinkID(_sinkID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_mainVolume_t, CommonAPI::EmptyDeployment> deploy_volume(_volume, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_mainVolume_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "setVolume",
        "qn",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sinkID, deploy_volume,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _amError) {
        	if (_callback)
        		_callback(_internalCallStatus, _amError.getValue());
        },
        std::make_tuple(deploy_amError));
    }
    /**
     * description: This function is used to increment or decrement the current volume for a sink.
     *   (at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if the value
     *   is not in the given volume range.
     */
    void CommandControlDBusProxy::volumeStep(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const int16_t &_step, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment> deploy_sinkID(_sinkID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment> deploy_step(_step, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "volumeStep",
        "qn",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sinkID, deploy_step,
_internalCallStatus,
deploy_amError);
_amError = deploy_amError.getValue();
}
    std::future<CommonAPI::CallStatus> CommandControlDBusProxy::volumeStepAsync(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const int16_t &_step, VolumeStepAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment> deploy_sinkID(_sinkID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment> deploy_step(_step, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "volumeStep",
        "qn",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sinkID, deploy_step,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _amError) {
        	if (_callback)
        		_callback(_internalCallStatus, _amError.getValue());
        },
        std::make_tuple(deploy_amError));
    }
    /**
     * description: Sets the mute state of a sink. (at)return E_OK on success, E_UNKNOWN on error.
     *   If the mute state is already the desired one, the Daemon will return E_OK
     */
    void CommandControlDBusProxy::setSinkMuteState(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const ::v3::org::genivi::am_t::am_MuteState_e &_muteState, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment> deploy_sinkID(_sinkID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_MuteState_e, CommonAPI::EmptyDeployment> deploy_muteState(_muteState, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_MuteState_e, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "setSinkMuteState",
        "qi",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sinkID, deploy_muteState,
_internalCallStatus,
deploy_amError);
_amError = deploy_amError.getValue();
}
    std::future<CommonAPI::CallStatus> CommandControlDBusProxy::setSinkMuteStateAsync(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const ::v3::org::genivi::am_t::am_MuteState_e &_muteState, SetSinkMuteStateAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment> deploy_sinkID(_sinkID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_MuteState_e, CommonAPI::EmptyDeployment> deploy_muteState(_muteState, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_MuteState_e, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "setSinkMuteState",
        "qi",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sinkID, deploy_muteState,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _amError) {
        	if (_callback)
        		_callback(_internalCallStatus, _amError.getValue());
        },
        std::make_tuple(deploy_amError));
    }
    /**
     * description: This method is used to set sound properties, e.g. equalizer values. Since the
     *   capabilities of the system can differ, the exact key value pairs can be
     *   extended in each product. (at)return E_OK on success, E_OUT_OF_RANGE if value
     *   exceeds range, E_UNKNOWN in case of an error
     */
    void CommandControlDBusProxy::setMainSinkSoundProperty(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const ::v3::org::genivi::am_t::am_MainSoundProperty_s &_soundProperty, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment> deploy_sinkID(_sinkID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_MainSoundProperty_s, ::v3::org::genivi::am_t_::am_MainSoundProperty_sDeployment_t> deploy_soundProperty(_soundProperty, static_cast<::v3::org::genivi::am_t_::am_MainSoundProperty_sDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_MainSoundProperty_s, ::v3::org::genivi::am_t_::am_MainSoundProperty_sDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "setMainSinkSoundProperty",
        "q(in)",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sinkID, deploy_soundProperty,
_internalCallStatus,
deploy_amError);
_amError = deploy_amError.getValue();
}
    std::future<CommonAPI::CallStatus> CommandControlDBusProxy::setMainSinkSoundPropertyAsync(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const ::v3::org::genivi::am_t::am_MainSoundProperty_s &_soundProperty, SetMainSinkSoundPropertyAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment> deploy_sinkID(_sinkID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_MainSoundProperty_s, ::v3::org::genivi::am_t_::am_MainSoundProperty_sDeployment_t> deploy_soundProperty(_soundProperty, static_cast<::v3::org::genivi::am_t_::am_MainSoundProperty_sDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_MainSoundProperty_s, ::v3::org::genivi::am_t_::am_MainSoundProperty_sDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "setMainSinkSoundProperty",
        "q(in)",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sinkID, deploy_soundProperty,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _amError) {
        	if (_callback)
        		_callback(_internalCallStatus, _amError.getValue());
        },
        std::make_tuple(deploy_amError));
    }
    /**
     * description: This method is used to set sound properties, e.g. equalizer values. Since the
     *   capabilities of the system can differ, the exact key value pairs can be
     *   extended in each product. (at)return E_OK on success, E_OUT_OF_RANGE if value
     *   exceeds range, E_UNKNOWN in case of an error
     */
    void CommandControlDBusProxy::setMainSourceSoundProperty(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::am_MainSoundProperty_s &_soundProperty, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_MainSoundProperty_s, ::v3::org::genivi::am_t_::am_MainSoundProperty_sDeployment_t> deploy_soundProperty(_soundProperty, static_cast<::v3::org::genivi::am_t_::am_MainSoundProperty_sDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_MainSoundProperty_s, ::v3::org::genivi::am_t_::am_MainSoundProperty_sDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "setMainSourceSoundProperty",
        "q(in)",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sourceID, deploy_soundProperty,
_internalCallStatus,
deploy_amError);
_amError = deploy_amError.getValue();
}
    std::future<CommonAPI::CallStatus> CommandControlDBusProxy::setMainSourceSoundPropertyAsync(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::am_MainSoundProperty_s &_soundProperty, SetMainSourceSoundPropertyAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_MainSoundProperty_s, ::v3::org::genivi::am_t_::am_MainSoundProperty_sDeployment_t> deploy_soundProperty(_soundProperty, static_cast<::v3::org::genivi::am_t_::am_MainSoundProperty_sDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_MainSoundProperty_s, ::v3::org::genivi::am_t_::am_MainSoundProperty_sDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "setMainSourceSoundProperty",
        "q(in)",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sourceID, deploy_soundProperty,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _amError) {
        	if (_callback)
        		_callback(_internalCallStatus, _amError.getValue());
        },
        std::make_tuple(deploy_amError));
    }
    /**
     * description: Sets a specific system property. (at)return E_OK on success, E_OUT_OF_RANGE if
     *   value exceeds range, E_UNKNOWN in case of an error
     */
    void CommandControlDBusProxy::setSystemProperty(const ::v3::org::genivi::am_t::am_SystemProperty_s &_property, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_SystemProperty_s, ::v3::org::genivi::am_t_::am_SystemProperty_sDeployment_t> deploy_property(_property, static_cast<::v3::org::genivi::am_t_::am_SystemProperty_sDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_SystemProperty_s, ::v3::org::genivi::am_t_::am_SystemProperty_sDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "setSystemProperty",
        "(in)",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_property,
_internalCallStatus,
deploy_amError);
_amError = deploy_amError.getValue();
}
    std::future<CommonAPI::CallStatus> CommandControlDBusProxy::setSystemPropertyAsync(const ::v3::org::genivi::am_t::am_SystemProperty_s &_property, SetSystemPropertyAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_SystemProperty_s, ::v3::org::genivi::am_t_::am_SystemProperty_sDeployment_t> deploy_property(_property, static_cast<::v3::org::genivi::am_t_::am_SystemProperty_sDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_SystemProperty_s, ::v3::org::genivi::am_t_::am_SystemProperty_sDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "setSystemProperty",
        "(in)",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_property,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _amError) {
        	if (_callback)
        		_callback(_internalCallStatus, _amError.getValue());
        },
        std::make_tuple(deploy_amError));
    }
    /**
     * description: Returns the current list of main connections. (at)return E_OK on success,
     *   E_DATABASE_ERROR on error
     */
    void CommandControlDBusProxy::getListMainConnections(CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_MainConnection_L &_listConnections, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_MainConnection_L, ::v3::org::genivi::am_t_::am_MainConnection_LDeployment_t> deploy_listConnections(static_cast<::v3::org::genivi::am_t_::am_MainConnection_LDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_MainConnection_L,::v3::org::genivi::am_t_::am_MainConnection_LDeployment_t>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getListMainConnections",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_listConnections, deploy_amError);
_listConnections = deploy_listConnections.getValue();
_amError = deploy_amError.getValue();
}
    std::future<CommonAPI::CallStatus> CommandControlDBusProxy::getListMainConnectionsAsync(GetListMainConnectionsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_MainConnection_L, ::v3::org::genivi::am_t_::am_MainConnection_LDeployment_t> deploy_listConnections(static_cast<::v3::org::genivi::am_t_::am_MainConnection_LDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_MainConnection_L,::v3::org::genivi::am_t_::am_MainConnection_LDeployment_t>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getListMainConnections",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_MainConnection_L, ::v3::org::genivi::am_t_::am_MainConnection_LDeployment_t> _listConnections, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _amError) {
        	if (_callback)
        		_callback(_internalCallStatus, _listConnections.getValue(), _amError.getValue());
        },
        std::make_tuple(deploy_listConnections, deploy_amError));
    }
    /**
     * description: Returns the current list of sinks. (at)return E_OK on success, E_DATABASE_ERROR
     *   on error
     */
    void CommandControlDBusProxy::getListMainSinks(CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_SinkType_L &_listMainSinks, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_SinkType_L, ::v3::org::genivi::am_t_::am_SinkType_LDeployment_t> deploy_listMainSinks(static_cast<::v3::org::genivi::am_t_::am_SinkType_LDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_SinkType_L,::v3::org::genivi::am_t_::am_SinkType_LDeployment_t>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getListMainSinks",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_listMainSinks, deploy_amError);
_listMainSinks = deploy_listMainSinks.getValue();
_amError = deploy_amError.getValue();
}
    std::future<CommonAPI::CallStatus> CommandControlDBusProxy::getListMainSinksAsync(GetListMainSinksAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_SinkType_L, ::v3::org::genivi::am_t_::am_SinkType_LDeployment_t> deploy_listMainSinks(static_cast<::v3::org::genivi::am_t_::am_SinkType_LDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_SinkType_L,::v3::org::genivi::am_t_::am_SinkType_LDeployment_t>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getListMainSinks",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_SinkType_L, ::v3::org::genivi::am_t_::am_SinkType_LDeployment_t> _listMainSinks, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _amError) {
        	if (_callback)
        		_callback(_internalCallStatus, _listMainSinks.getValue(), _amError.getValue());
        },
        std::make_tuple(deploy_listMainSinks, deploy_amError));
    }
    /**
     * description: Returns the current list of sources. (at)return E_OK on success,
     *   E_DATABASE_ERROR on error
     */
    void CommandControlDBusProxy::getListMainSources(CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_SourceType_L &_listMainSources, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_SourceType_L, ::v3::org::genivi::am_t_::am_SourceType_LDeployment_t> deploy_listMainSources(static_cast<::v3::org::genivi::am_t_::am_SourceType_LDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_SourceType_L,::v3::org::genivi::am_t_::am_SourceType_LDeployment_t>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getListMainSources",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_listMainSources, deploy_amError);
_listMainSources = deploy_listMainSources.getValue();
_amError = deploy_amError.getValue();
}
    std::future<CommonAPI::CallStatus> CommandControlDBusProxy::getListMainSourcesAsync(GetListMainSourcesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_SourceType_L, ::v3::org::genivi::am_t_::am_SourceType_LDeployment_t> deploy_listMainSources(static_cast<::v3::org::genivi::am_t_::am_SourceType_LDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_SourceType_L,::v3::org::genivi::am_t_::am_SourceType_LDeployment_t>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getListMainSources",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_SourceType_L, ::v3::org::genivi::am_t_::am_SourceType_LDeployment_t> _listMainSources, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _amError) {
        	if (_callback)
        		_callback(_internalCallStatus, _listMainSources.getValue(), _amError.getValue());
        },
        std::make_tuple(deploy_listMainSources, deploy_amError));
    }
    /**
     * description: This is used to retrieve all sink sound properties related to a sink. Returns a
     *   vector of the sound properties and values as pair. (at)return E_OK on success,
     *   E_DATABASE_ERROR on error
     */
    void CommandControlDBusProxy::getListMainSinkSoundProperties(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_MainSoundProperty_L &_listSoundProperties, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment> deploy_sinkID(_sinkID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_MainSoundProperty_L, ::v3::org::genivi::am_t_::am_MainSoundProperty_LDeployment_t> deploy_listSoundProperties(static_cast<::v3::org::genivi::am_t_::am_MainSoundProperty_LDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_MainSoundProperty_L,::v3::org::genivi::am_t_::am_MainSoundProperty_LDeployment_t>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getListMainSinkSoundProperties",
        "q",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sinkID,
_internalCallStatus,
deploy_listSoundProperties, deploy_amError);
_listSoundProperties = deploy_listSoundProperties.getValue();
_amError = deploy_amError.getValue();
}
    std::future<CommonAPI::CallStatus> CommandControlDBusProxy::getListMainSinkSoundPropertiesAsync(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, GetListMainSinkSoundPropertiesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment> deploy_sinkID(_sinkID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_MainSoundProperty_L, ::v3::org::genivi::am_t_::am_MainSoundProperty_LDeployment_t> deploy_listSoundProperties(static_cast<::v3::org::genivi::am_t_::am_MainSoundProperty_LDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_MainSoundProperty_L,::v3::org::genivi::am_t_::am_MainSoundProperty_LDeployment_t>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getListMainSinkSoundProperties",
        "q",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sinkID,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_MainSoundProperty_L, ::v3::org::genivi::am_t_::am_MainSoundProperty_LDeployment_t> _listSoundProperties, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _amError) {
        	if (_callback)
        		_callback(_internalCallStatus, _listSoundProperties.getValue(), _amError.getValue());
        },
        std::make_tuple(deploy_listSoundProperties, deploy_amError));
    }
    /**
     * description: This is used to retrieve all source sound properties related to a source.
     *   Returns a vector of the sound properties and values as pair. (at)return E_OK
     *   on success, E_DATABASE_ERROR on error
     */
    void CommandControlDBusProxy::getListMainSourceSoundProperties(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_MainSoundProperty_L &_listSoundProperties, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_MainSoundProperty_L, ::v3::org::genivi::am_t_::am_MainSoundProperty_LDeployment_t> deploy_listSoundProperties(static_cast<::v3::org::genivi::am_t_::am_MainSoundProperty_LDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_MainSoundProperty_L,::v3::org::genivi::am_t_::am_MainSoundProperty_LDeployment_t>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getListMainSourceSoundProperties",
        "q",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sourceID,
_internalCallStatus,
deploy_listSoundProperties, deploy_amError);
_listSoundProperties = deploy_listSoundProperties.getValue();
_amError = deploy_amError.getValue();
}
    std::future<CommonAPI::CallStatus> CommandControlDBusProxy::getListMainSourceSoundPropertiesAsync(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, GetListMainSourceSoundPropertiesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_MainSoundProperty_L, ::v3::org::genivi::am_t_::am_MainSoundProperty_LDeployment_t> deploy_listSoundProperties(static_cast<::v3::org::genivi::am_t_::am_MainSoundProperty_LDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_MainSoundProperty_L,::v3::org::genivi::am_t_::am_MainSoundProperty_LDeployment_t>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getListMainSourceSoundProperties",
        "q",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sourceID,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_MainSoundProperty_L, ::v3::org::genivi::am_t_::am_MainSoundProperty_LDeployment_t> _listSoundProperties, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _amError) {
        	if (_callback)
        		_callback(_internalCallStatus, _listSoundProperties.getValue(), _amError.getValue());
        },
        std::make_tuple(deploy_listSoundProperties, deploy_amError));
    }
    /**
     * description: This is used to retrieve sink class information of all sink classes. (at)return
     *   E_OK on success, E_DATABASE_ERROR on error
     */
    void CommandControlDBusProxy::getListSinkClasses(CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_SinkClass_L &_listSinkClasses, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_SinkClass_L, ::v3::org::genivi::am_t_::am_SinkClass_LDeployment_t> deploy_listSinkClasses(static_cast<::v3::org::genivi::am_t_::am_SinkClass_LDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_SinkClass_L,::v3::org::genivi::am_t_::am_SinkClass_LDeployment_t>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getListSinkClasses",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_listSinkClasses, deploy_amError);
_listSinkClasses = deploy_listSinkClasses.getValue();
_amError = deploy_amError.getValue();
}
    std::future<CommonAPI::CallStatus> CommandControlDBusProxy::getListSinkClassesAsync(GetListSinkClassesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_SinkClass_L, ::v3::org::genivi::am_t_::am_SinkClass_LDeployment_t> deploy_listSinkClasses(static_cast<::v3::org::genivi::am_t_::am_SinkClass_LDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_SinkClass_L,::v3::org::genivi::am_t_::am_SinkClass_LDeployment_t>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getListSinkClasses",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_SinkClass_L, ::v3::org::genivi::am_t_::am_SinkClass_LDeployment_t> _listSinkClasses, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _amError) {
        	if (_callback)
        		_callback(_internalCallStatus, _listSinkClasses.getValue(), _amError.getValue());
        },
        std::make_tuple(deploy_listSinkClasses, deploy_amError));
    }
    /**
     * description: This is used to retrieve source class information of all source classes.
     *   (at)return E_OK on success, E_DATABASE_ERROR on error
     */
    void CommandControlDBusProxy::getListSourceClasses(CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_SourceClass_L &_listSourceClasses, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_SourceClass_L, ::v3::org::genivi::am_t_::am_SourceClass_LDeployment_t> deploy_listSourceClasses(static_cast<::v3::org::genivi::am_t_::am_SourceClass_LDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_SourceClass_L,::v3::org::genivi::am_t_::am_SourceClass_LDeployment_t>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getListSourceClasses",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_listSourceClasses, deploy_amError);
_listSourceClasses = deploy_listSourceClasses.getValue();
_amError = deploy_amError.getValue();
}
    std::future<CommonAPI::CallStatus> CommandControlDBusProxy::getListSourceClassesAsync(GetListSourceClassesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_SourceClass_L, ::v3::org::genivi::am_t_::am_SourceClass_LDeployment_t> deploy_listSourceClasses(static_cast<::v3::org::genivi::am_t_::am_SourceClass_LDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_SourceClass_L,::v3::org::genivi::am_t_::am_SourceClass_LDeployment_t>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getListSourceClasses",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_SourceClass_L, ::v3::org::genivi::am_t_::am_SourceClass_LDeployment_t> _listSourceClasses, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _amError) {
        	if (_callback)
        		_callback(_internalCallStatus, _listSourceClasses.getValue(), _amError.getValue());
        },
        std::make_tuple(deploy_listSourceClasses, deploy_amError));
    }
    /**
     * description: Retrieves a complete list of all system properties. (at)return E_OK on success,
     *   E_DATABASE_ERROR on error
     */
    void CommandControlDBusProxy::getListSystemProperties(CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_SystemProperty_L &_listSystemProperties, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_SystemProperty_L, ::v3::org::genivi::am_t_::am_SystemProperty_LDeployment_t> deploy_listSystemProperties(static_cast<::v3::org::genivi::am_t_::am_SystemProperty_LDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_SystemProperty_L,::v3::org::genivi::am_t_::am_SystemProperty_LDeployment_t>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getListSystemProperties",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_listSystemProperties, deploy_amError);
_listSystemProperties = deploy_listSystemProperties.getValue();
_amError = deploy_amError.getValue();
}
    std::future<CommonAPI::CallStatus> CommandControlDBusProxy::getListSystemPropertiesAsync(GetListSystemPropertiesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_SystemProperty_L, ::v3::org::genivi::am_t_::am_SystemProperty_LDeployment_t> deploy_listSystemProperties(static_cast<::v3::org::genivi::am_t_::am_SystemProperty_LDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_SystemProperty_L,::v3::org::genivi::am_t_::am_SystemProperty_LDeployment_t>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getListSystemProperties",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_SystemProperty_L, ::v3::org::genivi::am_t_::am_SystemProperty_LDeployment_t> _listSystemProperties, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _amError) {
        	if (_callback)
        		_callback(_internalCallStatus, _listSystemProperties.getValue(), _amError.getValue());
        },
        std::make_tuple(deploy_listSystemProperties, deploy_amError));
    }
    /**
     * description: Returns the delay in ms that the audio path for the given main connection.
     *   (at)return E_OK on success, E_NOT_POSSIBLE if timing information is not yet
     *   retrieved, E_DATABASE_ERROR on read error on the database
     */
    void CommandControlDBusProxy::getTimingInformation(const ::v3::org::genivi::am_t::am_mainConnectionID_t &_mainConnectionID, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_timeSync_t &_delay, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_mainConnectionID_t, CommonAPI::EmptyDeployment> deploy_mainConnectionID(_mainConnectionID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_timeSync_t, CommonAPI::EmptyDeployment> deploy_delay(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_mainConnectionID_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_timeSync_t,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getTimingInformation",
        "q",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_mainConnectionID,
_internalCallStatus,
deploy_delay, deploy_amError);
_delay = deploy_delay.getValue();
_amError = deploy_amError.getValue();
}
    std::future<CommonAPI::CallStatus> CommandControlDBusProxy::getTimingInformationAsync(const ::v3::org::genivi::am_t::am_mainConnectionID_t &_mainConnectionID, GetTimingInformationAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_mainConnectionID_t, CommonAPI::EmptyDeployment> deploy_mainConnectionID(_mainConnectionID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_timeSync_t, CommonAPI::EmptyDeployment> deploy_delay(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_mainConnectionID_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_timeSync_t,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getTimingInformation",
        "q",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_mainConnectionID,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_timeSync_t, CommonAPI::EmptyDeployment> _delay, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _amError) {
        	if (_callback)
        		_callback(_internalCallStatus, _delay.getValue(), _amError.getValue());
        },
        std::make_tuple(deploy_delay, deploy_amError));
    }
    /**
     * description: Retrieves the list of main notifications for a sink. Does not return the
     *   possible ones.
     */
    void CommandControlDBusProxy::getListMainSinkNotificationConfigurations(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_NotificationConfiguration_L &_listMainNotificationConfigurations, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment> deploy_sinkID(_sinkID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_NotificationConfiguration_L, ::v3::org::genivi::am_t_::am_NotificationConfiguration_LDeployment_t> deploy_listMainNotificationConfigurations(static_cast<::v3::org::genivi::am_t_::am_NotificationConfiguration_LDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_NotificationConfiguration_L,::v3::org::genivi::am_t_::am_NotificationConfiguration_LDeployment_t>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getListMainSinkNotificationConfigurations",
        "q",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sinkID,
_internalCallStatus,
deploy_listMainNotificationConfigurations, deploy_amError);
_listMainNotificationConfigurations = deploy_listMainNotificationConfigurations.getValue();
_amError = deploy_amError.getValue();
}
    std::future<CommonAPI::CallStatus> CommandControlDBusProxy::getListMainSinkNotificationConfigurationsAsync(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, GetListMainSinkNotificationConfigurationsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment> deploy_sinkID(_sinkID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_NotificationConfiguration_L, ::v3::org::genivi::am_t_::am_NotificationConfiguration_LDeployment_t> deploy_listMainNotificationConfigurations(static_cast<::v3::org::genivi::am_t_::am_NotificationConfiguration_LDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_NotificationConfiguration_L,::v3::org::genivi::am_t_::am_NotificationConfiguration_LDeployment_t>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getListMainSinkNotificationConfigurations",
        "q",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sinkID,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_NotificationConfiguration_L, ::v3::org::genivi::am_t_::am_NotificationConfiguration_LDeployment_t> _listMainNotificationConfigurations, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _amError) {
        	if (_callback)
        		_callback(_internalCallStatus, _listMainNotificationConfigurations.getValue(), _amError.getValue());
        },
        std::make_tuple(deploy_listMainNotificationConfigurations, deploy_amError));
    }
    /**
     * description: Retrieves the list of main notifications for a source. Does not return the
     *   possible ones.
     */
    void CommandControlDBusProxy::getListMainSourceNotificationConfigurations(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_NotificationConfiguration_L &_listMainNotificationConfigurations, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_NotificationConfiguration_L, ::v3::org::genivi::am_t_::am_NotificationConfiguration_LDeployment_t> deploy_listMainNotificationConfigurations(static_cast<::v3::org::genivi::am_t_::am_NotificationConfiguration_LDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_NotificationConfiguration_L,::v3::org::genivi::am_t_::am_NotificationConfiguration_LDeployment_t>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getListMainSourceNotificationConfigurations",
        "q",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sourceID,
_internalCallStatus,
deploy_listMainNotificationConfigurations, deploy_amError);
_listMainNotificationConfigurations = deploy_listMainNotificationConfigurations.getValue();
_amError = deploy_amError.getValue();
}
    std::future<CommonAPI::CallStatus> CommandControlDBusProxy::getListMainSourceNotificationConfigurationsAsync(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, GetListMainSourceNotificationConfigurationsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_NotificationConfiguration_L, ::v3::org::genivi::am_t_::am_NotificationConfiguration_LDeployment_t> deploy_listMainNotificationConfigurations(static_cast<::v3::org::genivi::am_t_::am_NotificationConfiguration_LDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_NotificationConfiguration_L,::v3::org::genivi::am_t_::am_NotificationConfiguration_LDeployment_t>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getListMainSourceNotificationConfigurations",
        "q",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sourceID,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_NotificationConfiguration_L, ::v3::org::genivi::am_t_::am_NotificationConfiguration_LDeployment_t> _listMainNotificationConfigurations, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _amError) {
        	if (_callback)
        		_callback(_internalCallStatus, _listMainNotificationConfigurations.getValue(), _amError.getValue());
        },
        std::make_tuple(deploy_listMainNotificationConfigurations, deploy_amError));
    }
    /**
     * description: Sets a MainNotificationConfiuration. This can be used to turn on an off
     *   notifications an to change the mode of the configuration. (at)return E_OK on
     *   success, E_NON_EXISTENT if sink ID does not exists, E_DATABASE_ERROR on error
     */
    void CommandControlDBusProxy::setMainSinkNotificationConfiguration(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const ::v3::org::genivi::am_t::am_NotificationConfiguration_s &_mainNotificationConfiguration, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment> deploy_sinkID(_sinkID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_NotificationConfiguration_s, ::v3::org::genivi::am_t_::am_NotificationConfiguration_sDeployment_t> deploy_mainNotificationConfiguration(_mainNotificationConfiguration, static_cast<::v3::org::genivi::am_t_::am_NotificationConfiguration_sDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_NotificationConfiguration_s, ::v3::org::genivi::am_t_::am_NotificationConfiguration_sDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "setMainSinkNotificationConfiguration",
        "q(qin)",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sinkID, deploy_mainNotificationConfiguration,
_internalCallStatus,
deploy_amError);
_amError = deploy_amError.getValue();
}
    std::future<CommonAPI::CallStatus> CommandControlDBusProxy::setMainSinkNotificationConfigurationAsync(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const ::v3::org::genivi::am_t::am_NotificationConfiguration_s &_mainNotificationConfiguration, SetMainSinkNotificationConfigurationAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment> deploy_sinkID(_sinkID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_NotificationConfiguration_s, ::v3::org::genivi::am_t_::am_NotificationConfiguration_sDeployment_t> deploy_mainNotificationConfiguration(_mainNotificationConfiguration, static_cast<::v3::org::genivi::am_t_::am_NotificationConfiguration_sDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_NotificationConfiguration_s, ::v3::org::genivi::am_t_::am_NotificationConfiguration_sDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "setMainSinkNotificationConfiguration",
        "q(qin)",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sinkID, deploy_mainNotificationConfiguration,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _amError) {
        	if (_callback)
        		_callback(_internalCallStatus, _amError.getValue());
        },
        std::make_tuple(deploy_amError));
    }
    /**
     * description: Sets a MainNotificationConfiuration. This can be used to turn on an off
     *   notifications an to change the mode of the configuration. (at)return E_OK on
     *   success, E_NON_EXISTENT if source ID does not exists, E_DATABASE_ERROR on error
     */
    void CommandControlDBusProxy::setMainSourceNotificationConfiguration(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::am_NotificationConfiguration_s &_mainNotificationConfiguration, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_NotificationConfiguration_s, ::v3::org::genivi::am_t_::am_NotificationConfiguration_sDeployment_t> deploy_mainNotificationConfiguration(_mainNotificationConfiguration, static_cast<::v3::org::genivi::am_t_::am_NotificationConfiguration_sDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_NotificationConfiguration_s, ::v3::org::genivi::am_t_::am_NotificationConfiguration_sDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "setMainSourceNotificationConfiguration",
        "q(qin)",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sourceID, deploy_mainNotificationConfiguration,
_internalCallStatus,
deploy_amError);
_amError = deploy_amError.getValue();
}
    std::future<CommonAPI::CallStatus> CommandControlDBusProxy::setMainSourceNotificationConfigurationAsync(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::am_NotificationConfiguration_s &_mainNotificationConfiguration, SetMainSourceNotificationConfigurationAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_NotificationConfiguration_s, ::v3::org::genivi::am_t_::am_NotificationConfiguration_sDeployment_t> deploy_mainNotificationConfiguration(_mainNotificationConfiguration, static_cast<::v3::org::genivi::am_t_::am_NotificationConfiguration_sDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_NotificationConfiguration_s, ::v3::org::genivi::am_t_::am_NotificationConfiguration_sDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "setMainSourceNotificationConfiguration",
        "q(qin)",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sourceID, deploy_mainNotificationConfiguration,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _amError) {
        	if (_callback)
        		_callback(_internalCallStatus, _amError.getValue());
        },
        std::make_tuple(deploy_amError));
    }


void CommandControlDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
          ownVersionMajor = 3;
          ownVersionMinor = 1;
      }

      } // namespace commandinterface
      } // namespace am
      } // namespace genivi
      } // namespace org
      } // namespace v3
